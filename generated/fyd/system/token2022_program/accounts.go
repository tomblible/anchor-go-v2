// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains parsers for the account defined in the IDL.

package token2022_program

import (
	"bytes"
	"fmt"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

type Multisig struct {
	// Number of signers required
	M uint8

	// Number of valid signers
	N uint8

	// Is `true` if this structure has been initialized
	IsInitialized bool

	// Signer public keys
	Signers [11]solanago.PublicKey
}

func (obj Multisig) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `M`:
	if err = encoder.Encode(obj.M); err != nil {
		return fmt.Errorf("error while marshaling M:%w", err)
	}
	// Serialize `N`:
	if err = encoder.Encode(obj.N); err != nil {
		return fmt.Errorf("error while marshaling N:%w", err)
	}
	// Serialize `IsInitialized`:
	if err = encoder.Encode(obj.IsInitialized); err != nil {
		return fmt.Errorf("error while marshaling IsInitialized:%w", err)
	}
	// Serialize `Signers`:
	if err = encoder.Encode(obj.Signers); err != nil {
		return fmt.Errorf("error while marshaling Signers:%w", err)
	}
	return nil
}

func (obj Multisig) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Multisig: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Multisig) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `M`:
	if err = decoder.Decode(&obj.M); err != nil {
		return fmt.Errorf("error while unmarshaling M:%w", err)
	}
	// Deserialize `N`:
	if err = decoder.Decode(&obj.N); err != nil {
		return fmt.Errorf("error while unmarshaling N:%w", err)
	}
	// Deserialize `IsInitialized`:
	if err = decoder.Decode(&obj.IsInitialized); err != nil {
		return fmt.Errorf("error while unmarshaling IsInitialized:%w", err)
	}
	// Deserialize `Signers`:
	if err = decoder.Decode(&obj.Signers); err != nil {
		return fmt.Errorf("error while unmarshaling Signers:%w", err)
	}
	return nil
}

func (obj *Multisig) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Multisig: %w", err)
	}
	return nil
}

func UnmarshalMultisig(buf []byte) (*Multisig, error) {
	obj := new(Multisig)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type Mint struct {
	// Optional authority used to mint new tokens. The mint authority may only be provided during
	// mint creation. If no mint authority is present then the mint has a fixed supply and no
	// further tokens may be minted.
	MintAuthority *solanago.PublicKey `bin:"coption"`

	// Total supply of tokens.
	Supply uint64

	// Number of base 10 digits to the right of the decimal place.
	Decimals uint8

	// Is `true` if this structure has been initialized
	IsInitialized bool

	// Optional authority to freeze token accounts.
	FreezeAuthority *solanago.PublicKey `bin:"coption"`
	Padding         [83]uint8
	AccountType     AccountType
	Tlv             []byte
}

func (obj Mint) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `MintAuthority` (optional):
	if err = encoder.WriteOption(obj.MintAuthority != nil); err != nil {
		return fmt.Errorf("error while marshaling MintAuthority optionality: %w", err)
	}
	if err = encoder.Encode(obj.MintAuthority); err != nil {
		return fmt.Errorf("error while marshaling MintAuthority:%w", err)
	}
	// Serialize `Supply`:
	if err = encoder.Encode(obj.Supply); err != nil {
		return fmt.Errorf("error while marshaling Supply:%w", err)
	}
	// Serialize `Decimals`:
	if err = encoder.Encode(obj.Decimals); err != nil {
		return fmt.Errorf("error while marshaling Decimals:%w", err)
	}
	// Serialize `IsInitialized`:
	if err = encoder.Encode(obj.IsInitialized); err != nil {
		return fmt.Errorf("error while marshaling IsInitialized:%w", err)
	}
	// Serialize `FreezeAuthority` (optional):
	if err = encoder.WriteOption(obj.FreezeAuthority != nil); err != nil {
		return fmt.Errorf("error while marshaling FreezeAuthority optionality: %w", err)
	}
	if err = encoder.Encode(obj.FreezeAuthority); err != nil {
		return fmt.Errorf("error while marshaling FreezeAuthority:%w", err)
	}
	// Serialize `Padding`:
	if err = encoder.Encode(obj.Padding); err != nil {
		return fmt.Errorf("error while marshaling Padding:%w", err)
	}
	// Serialize `AccountType`:
	if err = encoder.Encode(obj.AccountType); err != nil {
		return fmt.Errorf("error while marshaling AccountType:%w", err)
	}
	// Serialize `Tlv`:
	if err = encoder.WriteBytes(obj.Tlv, false); err != nil {
		return fmt.Errorf("error while marshaling Tlv:%w", err)
	}
	return nil
}

func (obj Mint) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Mint: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Mint) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `MintAuthority` (optional):
	{
		if _, err = decoder.ReadCOption(); err != nil {
			return fmt.Errorf("error while unmarshaling MintAuthority:%w", err)
		}
		if err = decoder.Decode(&obj.MintAuthority); err != nil {
			return fmt.Errorf("error while unmarshaling MintAuthority:%w", err)
		}
	}
	// Deserialize `Supply`:
	if err = decoder.Decode(&obj.Supply); err != nil {
		return fmt.Errorf("error while unmarshaling Supply:%w", err)
	}
	// Deserialize `Decimals`:
	if err = decoder.Decode(&obj.Decimals); err != nil {
		return fmt.Errorf("error while unmarshaling Decimals:%w", err)
	}
	// Deserialize `IsInitialized`:
	if err = decoder.Decode(&obj.IsInitialized); err != nil {
		return fmt.Errorf("error while unmarshaling IsInitialized:%w", err)
	}
	// Deserialize `FreezeAuthority` (optional):
	{
		if _, err = decoder.ReadCOption(); err != nil {
			return fmt.Errorf("error while unmarshaling FreezeAuthority:%w", err)
		}
		if err = decoder.Decode(&obj.FreezeAuthority); err != nil {
			return fmt.Errorf("error while unmarshaling FreezeAuthority:%w", err)
		}
	}
	// Deserialize `Padding`:
	if err = decoder.Decode(&obj.Padding); err != nil {
		return fmt.Errorf("error while unmarshaling Padding:%w", err)
	}
	// Deserialize `AccountType`:
	if err = decoder.Decode(&obj.AccountType); err != nil {
		return fmt.Errorf("error while unmarshaling AccountType:%w", err)
	}

	if obj.Tlv, err = decoder.ReadBytes(decoder.Remaining()); err != nil {
		return fmt.Errorf("error while unmarshaling Tlv:%w", err)
	}
	return nil
}

func (obj *Mint) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Mint: %w", err)
	}
	return nil
}

func UnmarshalMint(buf []byte) (*Mint, error) {
	obj := new(Mint)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type Account struct {
	// The mint associated with this account
	Mint solanago.PublicKey

	// The owner of this account.
	Owner solanago.PublicKey

	// The amount of tokens this account holds.
	Amount uint64

	// If `delegate` is `Some` then `delegated_amount` represents
	// the amount authorized by the delegate
	Delegate *solanago.PublicKey `bin:"coption"`

	// The account's state
	State AccountState

	// If is_some, this is a native token, and the value logs the rent-exempt reserve. An Account
	// is required to be rent-exempt, so the value is used by the Processor to ensure that wrapped
	// SOL accounts do not drop below this threshold.
	IsNative *uint64 `bin:"optional"`

	// The amount delegated
	DelegatedAmount uint64

	// Optional authority to close the account.
	CloseAuthority *solanago.PublicKey `bin:"coption"`
	AccountType    AccountType
	Tlv            []byte
}

func (obj Account) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Mint`:
	if err = encoder.Encode(obj.Mint); err != nil {
		return fmt.Errorf("error while marshaling Mint:%w", err)
	}
	// Serialize `Owner`:
	if err = encoder.Encode(obj.Owner); err != nil {
		return fmt.Errorf("error while marshaling Owner:%w", err)
	}
	// Serialize `Amount`:
	if err = encoder.Encode(obj.Amount); err != nil {
		return fmt.Errorf("error while marshaling Amount:%w", err)
	}
	// Serialize `Delegate` (optional):
	if err = encoder.WriteOption(obj.Delegate != nil); err != nil {
		return fmt.Errorf("error while marshaling Delegate optionality: %w", err)
	}
	if err = encoder.Encode(obj.Delegate); err != nil {
		return fmt.Errorf("error while marshaling Delegate:%w", err)
	}
	// Serialize `State`:
	if err = encoder.Encode(obj.State); err != nil {
		return fmt.Errorf("error while marshaling State:%w", err)
	}
	// Serialize `IsNative` (optional):
	{
		if obj.IsNative == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling IsNative optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling IsNative optionality: %w", err)
			}
			if err = encoder.Encode(obj.IsNative); err != nil {
				return fmt.Errorf("error while marshaling IsNative: %w", err)
			}
		}
	}
	// Serialize `DelegatedAmount`:
	if err = encoder.Encode(obj.DelegatedAmount); err != nil {
		return fmt.Errorf("error while marshaling DelegatedAmount:%w", err)
	}
	// Serialize `CloseAuthority` (optional):
	if err = encoder.WriteOption(obj.CloseAuthority != nil); err != nil {
		return fmt.Errorf("error while marshaling CloseAuthority optionality: %w", err)
	}
	if err = encoder.Encode(obj.CloseAuthority); err != nil {
		return fmt.Errorf("error while marshaling CloseAuthority:%w", err)
	}
	// Serialize `AccountType`:
	if err = encoder.Encode(obj.AccountType); err != nil {
		return fmt.Errorf("error while marshaling AccountType:%w", err)
	}
	// Serialize `Tlv`:
	if err = encoder.WriteBytes(obj.Tlv, false); err != nil {
		return fmt.Errorf("error while marshaling Tlv:%w", err)
	}
	return nil
}

func (obj Account) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Account: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Account) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Mint`:
	if err = decoder.Decode(&obj.Mint); err != nil {
		return fmt.Errorf("error while unmarshaling Mint:%w", err)
	}
	// Deserialize `Owner`:
	if err = decoder.Decode(&obj.Owner); err != nil {
		return fmt.Errorf("error while unmarshaling Owner:%w", err)
	}
	// Deserialize `Amount`:
	if err = decoder.Decode(&obj.Amount); err != nil {
		return fmt.Errorf("error while unmarshaling Amount:%w", err)
	}
	// Deserialize `Delegate` (optional):
	{
		if _, err = decoder.ReadCOption(); err != nil {
			return fmt.Errorf("error while unmarshaling Delegate:%w", err)
		}
		if err = decoder.Decode(&obj.Delegate); err != nil {
			return fmt.Errorf("error while unmarshaling Delegate:%w", err)
		}
	}
	// Deserialize `State`:
	if err = decoder.Decode(&obj.State); err != nil {
		return fmt.Errorf("error while unmarshaling State:%w", err)
	}
	// Deserialize `IsNative` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling IsNative:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.IsNative); err != nil {
				return fmt.Errorf("error while unmarshaling IsNative:%w", err)
			}
		}
	}
	// Deserialize `DelegatedAmount`:
	if err = decoder.Decode(&obj.DelegatedAmount); err != nil {
		return fmt.Errorf("error while unmarshaling DelegatedAmount:%w", err)
	}
	// Deserialize `CloseAuthority` (optional):
	{
		if _, err = decoder.ReadCOption(); err != nil {
			return fmt.Errorf("error while unmarshaling CloseAuthority:%w", err)
		}
		if err = decoder.Decode(&obj.CloseAuthority); err != nil {
			return fmt.Errorf("error while unmarshaling CloseAuthority:%w", err)
		}
	}
	// Deserialize `AccountType`:
	if err = decoder.Decode(&obj.AccountType); err != nil {
		return fmt.Errorf("error while unmarshaling AccountType:%w", err)
	}
	// Deserialize `Tlv`:
	if obj.Tlv, err = decoder.ReadBytes(decoder.Remaining()); err != nil {
		return fmt.Errorf("error while unmarshaling Tlv:%w", err)
	}
	return nil
}

func (obj *Account) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Account: %w", err)
	}
	return nil
}

func UnmarshalAccount(buf []byte) (*Account, error) {
	obj := new(Account)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}
