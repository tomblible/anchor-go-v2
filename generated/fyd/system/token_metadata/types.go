// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains parsers for the types defined in the IDL.

package token_metadata

import (
	"bytes"
	"fmt"

	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

type Instruction interface {
	TypeID() binary.TypeID
	SetAccounts(accounts solanago.PublicKeySlice) error
	Copy() Instruction
}

type SetCollectionSizeArgs struct {
	Size uint64
}

func (obj SetCollectionSizeArgs) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Size`:
	if err = encoder.Encode(obj.Size); err != nil {
		return fmt.Errorf("error while marshaling Size:%w", err)
	}
	return nil
}

func (obj SetCollectionSizeArgs) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding SetCollectionSizeArgs: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *SetCollectionSizeArgs) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Size`:
	if err = decoder.Decode(&obj.Size); err != nil {
		return fmt.Errorf("error while unmarshaling Size:%w", err)
	}
	return nil
}

func (obj *SetCollectionSizeArgs) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SetCollectionSizeArgs: %w", err)
	}
	return nil
}

func UnmarshalSetCollectionSizeArgs(buf []byte) (*SetCollectionSizeArgs, error) {
	obj := new(SetCollectionSizeArgs)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type CreateMasterEditionArgs struct {
	MaxSupply *uint64 `bin:"optional"`
}

func (obj CreateMasterEditionArgs) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `MaxSupply` (optional):
	{
		if obj.MaxSupply == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling MaxSupply optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling MaxSupply optionality: %w", err)
			}
			if err = encoder.Encode(obj.MaxSupply); err != nil {
				return fmt.Errorf("error while marshaling MaxSupply: %w", err)
			}
		}
	}
	return nil
}

func (obj CreateMasterEditionArgs) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding CreateMasterEditionArgs: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *CreateMasterEditionArgs) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `MaxSupply` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling MaxSupply:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.MaxSupply); err != nil {
				return fmt.Errorf("error while unmarshaling MaxSupply:%w", err)
			}
		}
	}
	return nil
}

func (obj *CreateMasterEditionArgs) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CreateMasterEditionArgs: %w", err)
	}
	return nil
}

func UnmarshalCreateMasterEditionArgs(buf []byte) (*CreateMasterEditionArgs, error) {
	obj := new(CreateMasterEditionArgs)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type MintNewEditionFromMasterEditionViaTokenArgs struct {
	Edition uint64
}

func (obj MintNewEditionFromMasterEditionViaTokenArgs) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Edition`:
	if err = encoder.Encode(obj.Edition); err != nil {
		return fmt.Errorf("error while marshaling Edition:%w", err)
	}
	return nil
}

func (obj MintNewEditionFromMasterEditionViaTokenArgs) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding MintNewEditionFromMasterEditionViaTokenArgs: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *MintNewEditionFromMasterEditionViaTokenArgs) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Edition`:
	if err = decoder.Decode(&obj.Edition); err != nil {
		return fmt.Errorf("error while unmarshaling Edition:%w", err)
	}
	return nil
}

func (obj *MintNewEditionFromMasterEditionViaTokenArgs) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling MintNewEditionFromMasterEditionViaTokenArgs: %w", err)
	}
	return nil
}

func UnmarshalMintNewEditionFromMasterEditionViaTokenArgs(buf []byte) (*MintNewEditionFromMasterEditionViaTokenArgs, error) {
	obj := new(MintNewEditionFromMasterEditionViaTokenArgs)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type TransferOutOfEscrowArgs struct {
	Amount uint64
}

func (obj TransferOutOfEscrowArgs) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Amount`:
	if err = encoder.Encode(obj.Amount); err != nil {
		return fmt.Errorf("error while marshaling Amount:%w", err)
	}
	return nil
}

func (obj TransferOutOfEscrowArgs) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding TransferOutOfEscrowArgs: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *TransferOutOfEscrowArgs) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Amount`:
	if err = decoder.Decode(&obj.Amount); err != nil {
		return fmt.Errorf("error while unmarshaling Amount:%w", err)
	}
	return nil
}

func (obj *TransferOutOfEscrowArgs) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling TransferOutOfEscrowArgs: %w", err)
	}
	return nil
}

func UnmarshalTransferOutOfEscrowArgs(buf []byte) (*TransferOutOfEscrowArgs, error) {
	obj := new(TransferOutOfEscrowArgs)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type CreateMetadataAccountArgsV3 struct {
	Data              DataV2
	IsMutable         bool
	CollectionDetails *CollectionDetails `bin:"optional"`
}

func (obj CreateMetadataAccountArgsV3) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Data`:
	if err = encoder.Encode(obj.Data); err != nil {
		return fmt.Errorf("error while marshaling Data:%w", err)
	}
	// Serialize `IsMutable`:
	if err = encoder.Encode(obj.IsMutable); err != nil {
		return fmt.Errorf("error while marshaling IsMutable:%w", err)
	}
	// Serialize `CollectionDetails` (optional):
	{
		if obj.CollectionDetails == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling CollectionDetails optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling CollectionDetails optionality: %w", err)
			}
			if err = encoder.Encode(obj.CollectionDetails); err != nil {
				return fmt.Errorf("error while marshaling CollectionDetails: %w", err)
			}
		}
	}
	return nil
}

func (obj CreateMetadataAccountArgsV3) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding CreateMetadataAccountArgsV3: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *CreateMetadataAccountArgsV3) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Data`:
	if err = decoder.Decode(&obj.Data); err != nil {
		return fmt.Errorf("error while unmarshaling Data:%w", err)
	}
	// Deserialize `IsMutable`:
	if err = decoder.Decode(&obj.IsMutable); err != nil {
		return fmt.Errorf("error while unmarshaling IsMutable:%w", err)
	}
	// Deserialize `CollectionDetails` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling CollectionDetails:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.CollectionDetails); err != nil {
				return fmt.Errorf("error while unmarshaling CollectionDetails:%w", err)
			}
		}
	}
	return nil
}

func (obj *CreateMetadataAccountArgsV3) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CreateMetadataAccountArgsV3: %w", err)
	}
	return nil
}

func UnmarshalCreateMetadataAccountArgsV3(buf []byte) (*CreateMetadataAccountArgsV3, error) {
	obj := new(CreateMetadataAccountArgsV3)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UpdateMetadataAccountArgsV2 struct {
	Data                *DataV2             `bin:"optional"`
	UpdateAuthority     *solanago.PublicKey `bin:"optional"`
	PrimarySaleHappened *bool               `bin:"optional"`
	IsMutable           *bool               `bin:"optional"`
}

func (obj UpdateMetadataAccountArgsV2) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Data` (optional):
	{
		if obj.Data == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling Data optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling Data optionality: %w", err)
			}
			if err = encoder.Encode(obj.Data); err != nil {
				return fmt.Errorf("error while marshaling Data: %w", err)
			}
		}
	}
	// Serialize `UpdateAuthority` (optional):
	{
		if obj.UpdateAuthority == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling UpdateAuthority optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling UpdateAuthority optionality: %w", err)
			}
			if err = encoder.Encode(obj.UpdateAuthority); err != nil {
				return fmt.Errorf("error while marshaling UpdateAuthority: %w", err)
			}
		}
	}
	// Serialize `PrimarySaleHappened` (optional):
	{
		if obj.PrimarySaleHappened == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling PrimarySaleHappened optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling PrimarySaleHappened optionality: %w", err)
			}
			if err = encoder.Encode(obj.PrimarySaleHappened); err != nil {
				return fmt.Errorf("error while marshaling PrimarySaleHappened: %w", err)
			}
		}
	}
	// Serialize `IsMutable` (optional):
	{
		if obj.IsMutable == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling IsMutable optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling IsMutable optionality: %w", err)
			}
			if err = encoder.Encode(obj.IsMutable); err != nil {
				return fmt.Errorf("error while marshaling IsMutable: %w", err)
			}
		}
	}
	return nil
}

func (obj UpdateMetadataAccountArgsV2) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding UpdateMetadataAccountArgsV2: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *UpdateMetadataAccountArgsV2) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Data` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling Data:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.Data); err != nil {
				return fmt.Errorf("error while unmarshaling Data:%w", err)
			}
		}
	}
	// Deserialize `UpdateAuthority` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling UpdateAuthority:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.UpdateAuthority); err != nil {
				return fmt.Errorf("error while unmarshaling UpdateAuthority:%w", err)
			}
		}
	}
	// Deserialize `PrimarySaleHappened` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling PrimarySaleHappened:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.PrimarySaleHappened); err != nil {
				return fmt.Errorf("error while unmarshaling PrimarySaleHappened:%w", err)
			}
		}
	}
	// Deserialize `IsMutable` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling IsMutable:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.IsMutable); err != nil {
				return fmt.Errorf("error while unmarshaling IsMutable:%w", err)
			}
		}
	}
	return nil
}

func (obj *UpdateMetadataAccountArgsV2) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateMetadataAccountArgsV2: %w", err)
	}
	return nil
}

func UnmarshalUpdateMetadataAccountArgsV2(buf []byte) (*UpdateMetadataAccountArgsV2, error) {
	obj := new(UpdateMetadataAccountArgsV2)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ApproveUseAuthorityArgs struct {
	NumberOfUses uint64
}

func (obj ApproveUseAuthorityArgs) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `NumberOfUses`:
	if err = encoder.Encode(obj.NumberOfUses); err != nil {
		return fmt.Errorf("error while marshaling NumberOfUses:%w", err)
	}
	return nil
}

func (obj ApproveUseAuthorityArgs) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding ApproveUseAuthorityArgs: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *ApproveUseAuthorityArgs) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `NumberOfUses`:
	if err = decoder.Decode(&obj.NumberOfUses); err != nil {
		return fmt.Errorf("error while unmarshaling NumberOfUses:%w", err)
	}
	return nil
}

func (obj *ApproveUseAuthorityArgs) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ApproveUseAuthorityArgs: %w", err)
	}
	return nil
}

func UnmarshalApproveUseAuthorityArgs(buf []byte) (*ApproveUseAuthorityArgs, error) {
	obj := new(ApproveUseAuthorityArgs)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type UtilizeArgs struct {
	NumberOfUses uint64
}

func (obj UtilizeArgs) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `NumberOfUses`:
	if err = encoder.Encode(obj.NumberOfUses); err != nil {
		return fmt.Errorf("error while marshaling NumberOfUses:%w", err)
	}
	return nil
}

func (obj UtilizeArgs) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding UtilizeArgs: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *UtilizeArgs) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `NumberOfUses`:
	if err = decoder.Decode(&obj.NumberOfUses); err != nil {
		return fmt.Errorf("error while unmarshaling NumberOfUses:%w", err)
	}
	return nil
}

func (obj *UtilizeArgs) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UtilizeArgs: %w", err)
	}
	return nil
}

func UnmarshalUtilizeArgs(buf []byte) (*UtilizeArgs, error) {
	obj := new(UtilizeArgs)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type AuthorizationData struct {
	Payload any
}

func (obj AuthorizationData) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Payload`:
	if err = encoder.Encode(obj.Payload); err != nil {
		return fmt.Errorf("error while marshaling Payload:%w", err)
	}
	return nil
}

func (obj AuthorizationData) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding AuthorizationData: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *AuthorizationData) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Payload`:
	if err = decoder.Decode(&obj.Payload); err != nil {
		return fmt.Errorf("error while unmarshaling Payload:%w", err)
	}
	return nil
}

func (obj *AuthorizationData) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AuthorizationData: %w", err)
	}
	return nil
}

func UnmarshalAuthorizationData(buf []byte) (*AuthorizationData, error) {
	obj := new(AuthorizationData)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type AssetData struct {
	Name                 string
	Symbol               string
	Uri                  string
	SellerFeeBasisPoints uint16
	Creators             *[]Creator `bin:"optional"`
	PrimarySaleHappened  bool
	IsMutable            bool
	TokenStandard        TokenStandard
	Collection           *Collection         `bin:"optional"`
	Uses                 *Uses               `bin:"optional"`
	CollectionDetails    *CollectionDetails  `bin:"optional"`
	RuleSet              *solanago.PublicKey `bin:"optional"`
}

func (obj AssetData) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Name`:
	if err = encoder.Encode(obj.Name); err != nil {
		return fmt.Errorf("error while marshaling Name:%w", err)
	}
	// Serialize `Symbol`:
	if err = encoder.Encode(obj.Symbol); err != nil {
		return fmt.Errorf("error while marshaling Symbol:%w", err)
	}
	// Serialize `Uri`:
	if err = encoder.Encode(obj.Uri); err != nil {
		return fmt.Errorf("error while marshaling Uri:%w", err)
	}
	// Serialize `SellerFeeBasisPoints`:
	if err = encoder.Encode(obj.SellerFeeBasisPoints); err != nil {
		return fmt.Errorf("error while marshaling SellerFeeBasisPoints:%w", err)
	}
	// Serialize `Creators` (optional):
	{
		if obj.Creators == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling Creators optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling Creators optionality: %w", err)
			}
			if err = encoder.Encode(obj.Creators); err != nil {
				return fmt.Errorf("error while marshaling Creators: %w", err)
			}
		}
	}
	// Serialize `PrimarySaleHappened`:
	if err = encoder.Encode(obj.PrimarySaleHappened); err != nil {
		return fmt.Errorf("error while marshaling PrimarySaleHappened:%w", err)
	}
	// Serialize `IsMutable`:
	if err = encoder.Encode(obj.IsMutable); err != nil {
		return fmt.Errorf("error while marshaling IsMutable:%w", err)
	}
	// Serialize `TokenStandard`:
	if err = encoder.Encode(obj.TokenStandard); err != nil {
		return fmt.Errorf("error while marshaling TokenStandard:%w", err)
	}
	// Serialize `Collection` (optional):
	{
		if obj.Collection == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling Collection optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling Collection optionality: %w", err)
			}
			if err = encoder.Encode(obj.Collection); err != nil {
				return fmt.Errorf("error while marshaling Collection: %w", err)
			}
		}
	}
	// Serialize `Uses` (optional):
	{
		if obj.Uses == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling Uses optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling Uses optionality: %w", err)
			}
			if err = encoder.Encode(obj.Uses); err != nil {
				return fmt.Errorf("error while marshaling Uses: %w", err)
			}
		}
	}
	// Serialize `CollectionDetails` (optional):
	{
		if obj.CollectionDetails == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling CollectionDetails optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling CollectionDetails optionality: %w", err)
			}
			if err = encoder.Encode(obj.CollectionDetails); err != nil {
				return fmt.Errorf("error while marshaling CollectionDetails: %w", err)
			}
		}
	}
	// Serialize `RuleSet` (optional):
	{
		if obj.RuleSet == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling RuleSet optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling RuleSet optionality: %w", err)
			}
			if err = encoder.Encode(obj.RuleSet); err != nil {
				return fmt.Errorf("error while marshaling RuleSet: %w", err)
			}
		}
	}
	return nil
}

func (obj AssetData) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding AssetData: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *AssetData) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Name`:
	if err = decoder.Decode(&obj.Name); err != nil {
		return fmt.Errorf("error while unmarshaling Name:%w", err)
	}
	// Deserialize `Symbol`:
	if err = decoder.Decode(&obj.Symbol); err != nil {
		return fmt.Errorf("error while unmarshaling Symbol:%w", err)
	}
	// Deserialize `Uri`:
	if err = decoder.Decode(&obj.Uri); err != nil {
		return fmt.Errorf("error while unmarshaling Uri:%w", err)
	}
	// Deserialize `SellerFeeBasisPoints`:
	if err = decoder.Decode(&obj.SellerFeeBasisPoints); err != nil {
		return fmt.Errorf("error while unmarshaling SellerFeeBasisPoints:%w", err)
	}
	// Deserialize `Creators` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling Creators:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.Creators); err != nil {
				return fmt.Errorf("error while unmarshaling Creators:%w", err)
			}
		}
	}
	// Deserialize `PrimarySaleHappened`:
	if err = decoder.Decode(&obj.PrimarySaleHappened); err != nil {
		return fmt.Errorf("error while unmarshaling PrimarySaleHappened:%w", err)
	}
	// Deserialize `IsMutable`:
	if err = decoder.Decode(&obj.IsMutable); err != nil {
		return fmt.Errorf("error while unmarshaling IsMutable:%w", err)
	}
	// Deserialize `TokenStandard`:
	if err = decoder.Decode(&obj.TokenStandard); err != nil {
		return fmt.Errorf("error while unmarshaling TokenStandard:%w", err)
	}
	// Deserialize `Collection` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling Collection:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.Collection); err != nil {
				return fmt.Errorf("error while unmarshaling Collection:%w", err)
			}
		}
	}
	// Deserialize `Uses` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling Uses:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.Uses); err != nil {
				return fmt.Errorf("error while unmarshaling Uses:%w", err)
			}
		}
	}
	// Deserialize `CollectionDetails` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling CollectionDetails:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.CollectionDetails); err != nil {
				return fmt.Errorf("error while unmarshaling CollectionDetails:%w", err)
			}
		}
	}
	// Deserialize `RuleSet` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling RuleSet:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.RuleSet); err != nil {
				return fmt.Errorf("error while unmarshaling RuleSet:%w", err)
			}
		}
	}
	return nil
}

func (obj *AssetData) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AssetData: %w", err)
	}
	return nil
}

func UnmarshalAssetData(buf []byte) (*AssetData, error) {
	obj := new(AssetData)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type Collection struct {
	Verified bool
	Key      solanago.PublicKey
}

func (obj Collection) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Verified`:
	if err = encoder.Encode(obj.Verified); err != nil {
		return fmt.Errorf("error while marshaling Verified:%w", err)
	}
	// Serialize `Key`:
	if err = encoder.Encode(obj.Key); err != nil {
		return fmt.Errorf("error while marshaling Key:%w", err)
	}
	return nil
}

func (obj Collection) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Collection: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Collection) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Verified`:
	if err = decoder.Decode(&obj.Verified); err != nil {
		return fmt.Errorf("error while unmarshaling Verified:%w", err)
	}
	// Deserialize `Key`:
	if err = decoder.Decode(&obj.Key); err != nil {
		return fmt.Errorf("error while unmarshaling Key:%w", err)
	}
	return nil
}

func (obj *Collection) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Collection: %w", err)
	}
	return nil
}

func UnmarshalCollection(buf []byte) (*Collection, error) {
	obj := new(Collection)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type Creator struct {
	Address  solanago.PublicKey
	Verified bool
	Share    uint8
}

func (obj Creator) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Address`:
	if err = encoder.Encode(obj.Address); err != nil {
		return fmt.Errorf("error while marshaling Address:%w", err)
	}
	// Serialize `Verified`:
	if err = encoder.Encode(obj.Verified); err != nil {
		return fmt.Errorf("error while marshaling Verified:%w", err)
	}
	// Serialize `Share`:
	if err = encoder.Encode(obj.Share); err != nil {
		return fmt.Errorf("error while marshaling Share:%w", err)
	}
	return nil
}

func (obj Creator) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Creator: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Creator) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Address`:
	if err = decoder.Decode(&obj.Address); err != nil {
		return fmt.Errorf("error while unmarshaling Address:%w", err)
	}
	// Deserialize `Verified`:
	if err = decoder.Decode(&obj.Verified); err != nil {
		return fmt.Errorf("error while unmarshaling Verified:%w", err)
	}
	// Deserialize `Share`:
	if err = decoder.Decode(&obj.Share); err != nil {
		return fmt.Errorf("error while unmarshaling Share:%w", err)
	}
	return nil
}

func (obj *Creator) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Creator: %w", err)
	}
	return nil
}

func UnmarshalCreator(buf []byte) (*Creator, error) {
	obj := new(Creator)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type Data struct {
	Name                 string
	Symbol               string
	Uri                  string
	SellerFeeBasisPoints uint16
	Creators             *[]Creator `bin:"optional"`
}

func (obj Data) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Name`:
	if err = encoder.Encode(obj.Name); err != nil {
		return fmt.Errorf("error while marshaling Name:%w", err)
	}
	// Serialize `Symbol`:
	if err = encoder.Encode(obj.Symbol); err != nil {
		return fmt.Errorf("error while marshaling Symbol:%w", err)
	}
	// Serialize `Uri`:
	if err = encoder.Encode(obj.Uri); err != nil {
		return fmt.Errorf("error while marshaling Uri:%w", err)
	}
	// Serialize `SellerFeeBasisPoints`:
	if err = encoder.Encode(obj.SellerFeeBasisPoints); err != nil {
		return fmt.Errorf("error while marshaling SellerFeeBasisPoints:%w", err)
	}
	// Serialize `Creators` (optional):
	{
		if obj.Creators == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling Creators optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling Creators optionality: %w", err)
			}
			if err = encoder.Encode(obj.Creators); err != nil {
				return fmt.Errorf("error while marshaling Creators: %w", err)
			}
		}
	}
	return nil
}

func (obj Data) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Data: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Data) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Name`:
	if err = decoder.Decode(&obj.Name); err != nil {
		return fmt.Errorf("error while unmarshaling Name:%w", err)
	}
	// Deserialize `Symbol`:
	if err = decoder.Decode(&obj.Symbol); err != nil {
		return fmt.Errorf("error while unmarshaling Symbol:%w", err)
	}
	// Deserialize `Uri`:
	if err = decoder.Decode(&obj.Uri); err != nil {
		return fmt.Errorf("error while unmarshaling Uri:%w", err)
	}
	// Deserialize `SellerFeeBasisPoints`:
	if err = decoder.Decode(&obj.SellerFeeBasisPoints); err != nil {
		return fmt.Errorf("error while unmarshaling SellerFeeBasisPoints:%w", err)
	}
	// Deserialize `Creators` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling Creators:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.Creators); err != nil {
				return fmt.Errorf("error while unmarshaling Creators:%w", err)
			}
		}
	}
	return nil
}

func (obj *Data) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Data: %w", err)
	}
	return nil
}

func UnmarshalData(buf []byte) (*Data, error) {
	obj := new(Data)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type DataV2 struct {
	Name                 string
	Symbol               string
	Uri                  string
	SellerFeeBasisPoints uint16
	Creators             *[]Creator  `bin:"optional"`
	Collection           *Collection `bin:"optional"`
	Uses                 *Uses       `bin:"optional"`
}

func (obj DataV2) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Name`:
	if err = encoder.Encode(obj.Name); err != nil {
		return fmt.Errorf("error while marshaling Name:%w", err)
	}
	// Serialize `Symbol`:
	if err = encoder.Encode(obj.Symbol); err != nil {
		return fmt.Errorf("error while marshaling Symbol:%w", err)
	}
	// Serialize `Uri`:
	if err = encoder.Encode(obj.Uri); err != nil {
		return fmt.Errorf("error while marshaling Uri:%w", err)
	}
	// Serialize `SellerFeeBasisPoints`:
	if err = encoder.Encode(obj.SellerFeeBasisPoints); err != nil {
		return fmt.Errorf("error while marshaling SellerFeeBasisPoints:%w", err)
	}
	// Serialize `Creators` (optional):
	{
		if obj.Creators == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling Creators optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling Creators optionality: %w", err)
			}
			if err = encoder.Encode(obj.Creators); err != nil {
				return fmt.Errorf("error while marshaling Creators: %w", err)
			}
		}
	}
	// Serialize `Collection` (optional):
	{
		if obj.Collection == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling Collection optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling Collection optionality: %w", err)
			}
			if err = encoder.Encode(obj.Collection); err != nil {
				return fmt.Errorf("error while marshaling Collection: %w", err)
			}
		}
	}
	// Serialize `Uses` (optional):
	{
		if obj.Uses == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling Uses optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling Uses optionality: %w", err)
			}
			if err = encoder.Encode(obj.Uses); err != nil {
				return fmt.Errorf("error while marshaling Uses: %w", err)
			}
		}
	}
	return nil
}

func (obj DataV2) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding DataV2: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *DataV2) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Name`:
	if err = decoder.Decode(&obj.Name); err != nil {
		return fmt.Errorf("error while unmarshaling Name:%w", err)
	}
	// Deserialize `Symbol`:
	if err = decoder.Decode(&obj.Symbol); err != nil {
		return fmt.Errorf("error while unmarshaling Symbol:%w", err)
	}
	// Deserialize `Uri`:
	if err = decoder.Decode(&obj.Uri); err != nil {
		return fmt.Errorf("error while unmarshaling Uri:%w", err)
	}
	// Deserialize `SellerFeeBasisPoints`:
	if err = decoder.Decode(&obj.SellerFeeBasisPoints); err != nil {
		return fmt.Errorf("error while unmarshaling SellerFeeBasisPoints:%w", err)
	}
	// Deserialize `Creators` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling Creators:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.Creators); err != nil {
				return fmt.Errorf("error while unmarshaling Creators:%w", err)
			}
		}
	}
	// Deserialize `Collection` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling Collection:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.Collection); err != nil {
				return fmt.Errorf("error while unmarshaling Collection:%w", err)
			}
		}
	}
	// Deserialize `Uses` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling Uses:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.Uses); err != nil {
				return fmt.Errorf("error while unmarshaling Uses:%w", err)
			}
		}
	}
	return nil
}

func (obj *DataV2) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling DataV2: %w", err)
	}
	return nil
}

func UnmarshalDataV2(buf []byte) (*DataV2, error) {
	obj := new(DataV2)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type Reservation struct {
	Address        solanago.PublicKey
	SpotsRemaining uint64
	TotalSpots     uint64
}

func (obj Reservation) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Address`:
	if err = encoder.Encode(obj.Address); err != nil {
		return fmt.Errorf("error while marshaling Address:%w", err)
	}
	// Serialize `SpotsRemaining`:
	if err = encoder.Encode(obj.SpotsRemaining); err != nil {
		return fmt.Errorf("error while marshaling SpotsRemaining:%w", err)
	}
	// Serialize `TotalSpots`:
	if err = encoder.Encode(obj.TotalSpots); err != nil {
		return fmt.Errorf("error while marshaling TotalSpots:%w", err)
	}
	return nil
}

func (obj Reservation) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Reservation: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Reservation) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Address`:
	if err = decoder.Decode(&obj.Address); err != nil {
		return fmt.Errorf("error while unmarshaling Address:%w", err)
	}
	// Deserialize `SpotsRemaining`:
	if err = decoder.Decode(&obj.SpotsRemaining); err != nil {
		return fmt.Errorf("error while unmarshaling SpotsRemaining:%w", err)
	}
	// Deserialize `TotalSpots`:
	if err = decoder.Decode(&obj.TotalSpots); err != nil {
		return fmt.Errorf("error while unmarshaling TotalSpots:%w", err)
	}
	return nil
}

func (obj *Reservation) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Reservation: %w", err)
	}
	return nil
}

func UnmarshalReservation(buf []byte) (*Reservation, error) {
	obj := new(Reservation)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ReservationV1 struct {
	Address        solanago.PublicKey
	SpotsRemaining uint8
	TotalSpots     uint8
}

func (obj ReservationV1) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Address`:
	if err = encoder.Encode(obj.Address); err != nil {
		return fmt.Errorf("error while marshaling Address:%w", err)
	}
	// Serialize `SpotsRemaining`:
	if err = encoder.Encode(obj.SpotsRemaining); err != nil {
		return fmt.Errorf("error while marshaling SpotsRemaining:%w", err)
	}
	// Serialize `TotalSpots`:
	if err = encoder.Encode(obj.TotalSpots); err != nil {
		return fmt.Errorf("error while marshaling TotalSpots:%w", err)
	}
	return nil
}

func (obj ReservationV1) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding ReservationV1: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *ReservationV1) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Address`:
	if err = decoder.Decode(&obj.Address); err != nil {
		return fmt.Errorf("error while unmarshaling Address:%w", err)
	}
	// Deserialize `SpotsRemaining`:
	if err = decoder.Decode(&obj.SpotsRemaining); err != nil {
		return fmt.Errorf("error while unmarshaling SpotsRemaining:%w", err)
	}
	// Deserialize `TotalSpots`:
	if err = decoder.Decode(&obj.TotalSpots); err != nil {
		return fmt.Errorf("error while unmarshaling TotalSpots:%w", err)
	}
	return nil
}

func (obj *ReservationV1) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ReservationV1: %w", err)
	}
	return nil
}

func UnmarshalReservationV1(buf []byte) (*ReservationV1, error) {
	obj := new(ReservationV1)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type SeedsVec struct {
	Seeds [][]byte
}

func (obj SeedsVec) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Seeds`:
	if err = encoder.Encode(obj.Seeds); err != nil {
		return fmt.Errorf("error while marshaling Seeds:%w", err)
	}
	return nil
}

func (obj SeedsVec) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding SeedsVec: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *SeedsVec) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Seeds`:
	if err = decoder.Decode(&obj.Seeds); err != nil {
		return fmt.Errorf("error while unmarshaling Seeds:%w", err)
	}
	return nil
}

func (obj *SeedsVec) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling SeedsVec: %w", err)
	}
	return nil
}

func UnmarshalSeedsVec(buf []byte) (*SeedsVec, error) {
	obj := new(SeedsVec)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ProofInfo struct {
	Proof [][32]uint8
}

func (obj ProofInfo) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Proof`:
	if err = encoder.Encode(obj.Proof); err != nil {
		return fmt.Errorf("error while marshaling Proof:%w", err)
	}
	return nil
}

func (obj ProofInfo) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding ProofInfo: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *ProofInfo) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Proof`:
	if err = decoder.Decode(&obj.Proof); err != nil {
		return fmt.Errorf("error while unmarshaling Proof:%w", err)
	}
	return nil
}

func (obj *ProofInfo) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ProofInfo: %w", err)
	}
	return nil
}

func UnmarshalProofInfo(buf []byte) (*ProofInfo, error) {
	obj := new(ProofInfo)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type Uses struct {
	UseMethod UseMethod
	Remaining uint64
	Total     uint64
}

func (obj Uses) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `UseMethod`:
	if err = encoder.Encode(obj.UseMethod); err != nil {
		return fmt.Errorf("error while marshaling UseMethod:%w", err)
	}
	// Serialize `Remaining`:
	if err = encoder.Encode(obj.Remaining); err != nil {
		return fmt.Errorf("error while marshaling Remaining:%w", err)
	}
	// Serialize `Total`:
	if err = encoder.Encode(obj.Total); err != nil {
		return fmt.Errorf("error while marshaling Total:%w", err)
	}
	return nil
}

func (obj Uses) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Uses: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Uses) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `UseMethod`:
	if err = decoder.Decode(&obj.UseMethod); err != nil {
		return fmt.Errorf("error while unmarshaling UseMethod:%w", err)
	}
	// Deserialize `Remaining`:
	if err = decoder.Decode(&obj.Remaining); err != nil {
		return fmt.Errorf("error while unmarshaling Remaining:%w", err)
	}
	// Deserialize `Total`:
	if err = decoder.Decode(&obj.Total); err != nil {
		return fmt.Errorf("error while unmarshaling Total:%w", err)
	}
	return nil
}

func (obj *Uses) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Uses: %w", err)
	}
	return nil
}

func UnmarshalUses(buf []byte) (*Uses, error) {
	obj := new(Uses)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// The "isBurnArgs" interface for the "BurnArgs" complex enum.
type BurnArgs interface {
	isBurnArgs()
}

type burnArgsEnumContainer struct {
	Enum binary.BorshEnum `bin:"enum"`
	V1   BurnArgs_V1
}

func DecodeBurnArgs(decoder *binary.Decoder) (BurnArgs, error) {
	{
		tmp := new(burnArgsEnumContainer)
		err := decoder.Decode(tmp)
		if err != nil {
			return nil, fmt.Errorf("failed parsing BurnArgs: %w", err)
		}
		switch tmp.Enum {
		case 0:
			return &tmp.V1, nil
		default:
			return nil, fmt.Errorf("BurnArgs: unknown enum index: %v", tmp.Enum)
		}
	}
}

func EncodeBurnArgs(encoder *binary.Encoder, value BurnArgs) error {
	{
		tmp := burnArgsEnumContainer{}
		switch realvalue := value.(type) {
		case *BurnArgs_V1:
			tmp.Enum = 0
			tmp.V1 = *realvalue
		}
		return encoder.Encode(tmp)
	}
}

// Variant "V1" of enum "BurnArgs"
type BurnArgs_V1 struct {
	Amount uint64 `json:"amount"`
}

func (obj BurnArgs_V1) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Amount`:
	if err = encoder.Encode(obj.Amount); err != nil {
		return fmt.Errorf("error while marshaling Amount:%w", err)
	}
	return nil
}

func (obj BurnArgs_V1) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding BurnArgs_V1: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *BurnArgs_V1) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Amount`:
	if err = decoder.Decode(&obj.Amount); err != nil {
		return fmt.Errorf("error while unmarshaling Amount:%w", err)
	}
	return nil
}

func (obj *BurnArgs_V1) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling BurnArgs_V1: %w", err)
	}
	return nil
}

func UnmarshalBurnArgs_V1(buf []byte) (*BurnArgs_V1, error) {
	obj := new(BurnArgs_V1)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *BurnArgs_V1) isBurnArgs() {}

// The "isDelegateArgs" interface for the "DelegateArgs" complex enum.
type DelegateArgs interface {
	isDelegateArgs()
}

type delegateArgsEnumContainer struct {
	Enum                     binary.BorshEnum `bin:"enum"`
	CollectionV1             DelegateArgs_CollectionV1
	SaleV1                   DelegateArgs_SaleV1
	TransferV1               DelegateArgs_TransferV1
	DataV1                   DelegateArgs_DataV1
	UtilityV1                DelegateArgs_UtilityV1
	StakingV1                DelegateArgs_StakingV1
	StandardV1               DelegateArgs_StandardV1
	LockedTransferV1         DelegateArgs_LockedTransferV1
	ProgrammableConfigV1     DelegateArgs_ProgrammableConfigV1
	AuthorityItemV1          DelegateArgs_AuthorityItemV1
	DataItemV1               DelegateArgs_DataItemV1
	CollectionItemV1         DelegateArgs_CollectionItemV1
	ProgrammableConfigItemV1 DelegateArgs_ProgrammableConfigItemV1
	PrintDelegateV1          DelegateArgs_PrintDelegateV1
}

func DecodeDelegateArgs(decoder *binary.Decoder) (DelegateArgs, error) {
	{
		tmp := new(delegateArgsEnumContainer)
		err := decoder.Decode(tmp)
		if err != nil {
			return nil, fmt.Errorf("failed parsing DelegateArgs: %w", err)
		}
		switch tmp.Enum {
		case 0:
			return &tmp.CollectionV1, nil
		case 1:
			return &tmp.SaleV1, nil
		case 2:
			return &tmp.TransferV1, nil
		case 3:
			return &tmp.DataV1, nil
		case 4:
			return &tmp.UtilityV1, nil
		case 5:
			return &tmp.StakingV1, nil
		case 6:
			return &tmp.StandardV1, nil
		case 7:
			return &tmp.LockedTransferV1, nil
		case 8:
			return &tmp.ProgrammableConfigV1, nil
		case 9:
			return &tmp.AuthorityItemV1, nil
		case 10:
			return &tmp.DataItemV1, nil
		case 11:
			return &tmp.CollectionItemV1, nil
		case 12:
			return &tmp.ProgrammableConfigItemV1, nil
		case 13:
			return &tmp.PrintDelegateV1, nil
		default:
			return nil, fmt.Errorf("DelegateArgs: unknown enum index: %v", tmp.Enum)
		}
	}
}

func EncodeDelegateArgs(encoder *binary.Encoder, value DelegateArgs) error {
	{
		tmp := delegateArgsEnumContainer{}
		switch realvalue := value.(type) {
		case *DelegateArgs_CollectionV1:
			tmp.Enum = 0
			tmp.CollectionV1 = *realvalue
		case *DelegateArgs_SaleV1:
			tmp.Enum = 1
			tmp.SaleV1 = *realvalue
		case *DelegateArgs_TransferV1:
			tmp.Enum = 2
			tmp.TransferV1 = *realvalue
		case *DelegateArgs_DataV1:
			tmp.Enum = 3
			tmp.DataV1 = *realvalue
		case *DelegateArgs_UtilityV1:
			tmp.Enum = 4
			tmp.UtilityV1 = *realvalue
		case *DelegateArgs_StakingV1:
			tmp.Enum = 5
			tmp.StakingV1 = *realvalue
		case *DelegateArgs_StandardV1:
			tmp.Enum = 6
			tmp.StandardV1 = *realvalue
		case *DelegateArgs_LockedTransferV1:
			tmp.Enum = 7
			tmp.LockedTransferV1 = *realvalue
		case *DelegateArgs_ProgrammableConfigV1:
			tmp.Enum = 8
			tmp.ProgrammableConfigV1 = *realvalue
		case *DelegateArgs_AuthorityItemV1:
			tmp.Enum = 9
			tmp.AuthorityItemV1 = *realvalue
		case *DelegateArgs_DataItemV1:
			tmp.Enum = 10
			tmp.DataItemV1 = *realvalue
		case *DelegateArgs_CollectionItemV1:
			tmp.Enum = 11
			tmp.CollectionItemV1 = *realvalue
		case *DelegateArgs_ProgrammableConfigItemV1:
			tmp.Enum = 12
			tmp.ProgrammableConfigItemV1 = *realvalue
		case *DelegateArgs_PrintDelegateV1:
			tmp.Enum = 13
			tmp.PrintDelegateV1 = *realvalue
		}
		return encoder.Encode(tmp)
	}
}

// Variant "CollectionV1" of enum "DelegateArgs"
type DelegateArgs_CollectionV1 struct {
	AuthorizationData *AuthorizationData `bin:"optional" json:"authorizationData,omitempty"`
}

func (obj DelegateArgs_CollectionV1) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `AuthorizationData` (optional):
	{
		if obj.AuthorizationData == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
			if err = encoder.Encode(obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData: %w", err)
			}
		}
	}
	return nil
}

func (obj DelegateArgs_CollectionV1) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding DelegateArgs_CollectionV1: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *DelegateArgs_CollectionV1) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `AuthorizationData` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
			}
		}
	}
	return nil
}

func (obj *DelegateArgs_CollectionV1) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling DelegateArgs_CollectionV1: %w", err)
	}
	return nil
}

func UnmarshalDelegateArgs_CollectionV1(buf []byte) (*DelegateArgs_CollectionV1, error) {
	obj := new(DelegateArgs_CollectionV1)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *DelegateArgs_CollectionV1) isDelegateArgs() {}

// Variant "SaleV1" of enum "DelegateArgs"
type DelegateArgs_SaleV1 struct {
	Amount            uint64             `json:"amount"`
	AuthorizationData *AuthorizationData `bin:"optional" json:"authorizationData,omitempty"`
}

func (obj DelegateArgs_SaleV1) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Amount`:
	if err = encoder.Encode(obj.Amount); err != nil {
		return fmt.Errorf("error while marshaling Amount:%w", err)
	}
	// Serialize `AuthorizationData` (optional):
	{
		if obj.AuthorizationData == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
			if err = encoder.Encode(obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData: %w", err)
			}
		}
	}
	return nil
}

func (obj DelegateArgs_SaleV1) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding DelegateArgs_SaleV1: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *DelegateArgs_SaleV1) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Amount`:
	if err = decoder.Decode(&obj.Amount); err != nil {
		return fmt.Errorf("error while unmarshaling Amount:%w", err)
	}
	// Deserialize `AuthorizationData` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
			}
		}
	}
	return nil
}

func (obj *DelegateArgs_SaleV1) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling DelegateArgs_SaleV1: %w", err)
	}
	return nil
}

func UnmarshalDelegateArgs_SaleV1(buf []byte) (*DelegateArgs_SaleV1, error) {
	obj := new(DelegateArgs_SaleV1)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *DelegateArgs_SaleV1) isDelegateArgs() {}

// Variant "TransferV1" of enum "DelegateArgs"
type DelegateArgs_TransferV1 struct {
	Amount            uint64             `json:"amount"`
	AuthorizationData *AuthorizationData `bin:"optional" json:"authorizationData,omitempty"`
}

func (obj DelegateArgs_TransferV1) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Amount`:
	if err = encoder.Encode(obj.Amount); err != nil {
		return fmt.Errorf("error while marshaling Amount:%w", err)
	}
	// Serialize `AuthorizationData` (optional):
	{
		if obj.AuthorizationData == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
			if err = encoder.Encode(obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData: %w", err)
			}
		}
	}
	return nil
}

func (obj DelegateArgs_TransferV1) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding DelegateArgs_TransferV1: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *DelegateArgs_TransferV1) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Amount`:
	if err = decoder.Decode(&obj.Amount); err != nil {
		return fmt.Errorf("error while unmarshaling Amount:%w", err)
	}
	// Deserialize `AuthorizationData` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
			}
		}
	}
	return nil
}

func (obj *DelegateArgs_TransferV1) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling DelegateArgs_TransferV1: %w", err)
	}
	return nil
}

func UnmarshalDelegateArgs_TransferV1(buf []byte) (*DelegateArgs_TransferV1, error) {
	obj := new(DelegateArgs_TransferV1)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *DelegateArgs_TransferV1) isDelegateArgs() {}

// Variant "DataV1" of enum "DelegateArgs"
type DelegateArgs_DataV1 struct {
	AuthorizationData *AuthorizationData `bin:"optional" json:"authorizationData,omitempty"`
}

func (obj DelegateArgs_DataV1) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `AuthorizationData` (optional):
	{
		if obj.AuthorizationData == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
			if err = encoder.Encode(obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData: %w", err)
			}
		}
	}
	return nil
}

func (obj DelegateArgs_DataV1) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding DelegateArgs_DataV1: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *DelegateArgs_DataV1) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `AuthorizationData` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
			}
		}
	}
	return nil
}

func (obj *DelegateArgs_DataV1) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling DelegateArgs_DataV1: %w", err)
	}
	return nil
}

func UnmarshalDelegateArgs_DataV1(buf []byte) (*DelegateArgs_DataV1, error) {
	obj := new(DelegateArgs_DataV1)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *DelegateArgs_DataV1) isDelegateArgs() {}

// Variant "UtilityV1" of enum "DelegateArgs"
type DelegateArgs_UtilityV1 struct {
	Amount            uint64             `json:"amount"`
	AuthorizationData *AuthorizationData `bin:"optional" json:"authorizationData,omitempty"`
}

func (obj DelegateArgs_UtilityV1) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Amount`:
	if err = encoder.Encode(obj.Amount); err != nil {
		return fmt.Errorf("error while marshaling Amount:%w", err)
	}
	// Serialize `AuthorizationData` (optional):
	{
		if obj.AuthorizationData == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
			if err = encoder.Encode(obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData: %w", err)
			}
		}
	}
	return nil
}

func (obj DelegateArgs_UtilityV1) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding DelegateArgs_UtilityV1: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *DelegateArgs_UtilityV1) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Amount`:
	if err = decoder.Decode(&obj.Amount); err != nil {
		return fmt.Errorf("error while unmarshaling Amount:%w", err)
	}
	// Deserialize `AuthorizationData` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
			}
		}
	}
	return nil
}

func (obj *DelegateArgs_UtilityV1) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling DelegateArgs_UtilityV1: %w", err)
	}
	return nil
}

func UnmarshalDelegateArgs_UtilityV1(buf []byte) (*DelegateArgs_UtilityV1, error) {
	obj := new(DelegateArgs_UtilityV1)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *DelegateArgs_UtilityV1) isDelegateArgs() {}

// Variant "StakingV1" of enum "DelegateArgs"
type DelegateArgs_StakingV1 struct {
	Amount            uint64             `json:"amount"`
	AuthorizationData *AuthorizationData `bin:"optional" json:"authorizationData,omitempty"`
}

func (obj DelegateArgs_StakingV1) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Amount`:
	if err = encoder.Encode(obj.Amount); err != nil {
		return fmt.Errorf("error while marshaling Amount:%w", err)
	}
	// Serialize `AuthorizationData` (optional):
	{
		if obj.AuthorizationData == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
			if err = encoder.Encode(obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData: %w", err)
			}
		}
	}
	return nil
}

func (obj DelegateArgs_StakingV1) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding DelegateArgs_StakingV1: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *DelegateArgs_StakingV1) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Amount`:
	if err = decoder.Decode(&obj.Amount); err != nil {
		return fmt.Errorf("error while unmarshaling Amount:%w", err)
	}
	// Deserialize `AuthorizationData` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
			}
		}
	}
	return nil
}

func (obj *DelegateArgs_StakingV1) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling DelegateArgs_StakingV1: %w", err)
	}
	return nil
}

func UnmarshalDelegateArgs_StakingV1(buf []byte) (*DelegateArgs_StakingV1, error) {
	obj := new(DelegateArgs_StakingV1)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *DelegateArgs_StakingV1) isDelegateArgs() {}

// Variant "StandardV1" of enum "DelegateArgs"
type DelegateArgs_StandardV1 struct {
	Amount uint64 `json:"amount"`
}

func (obj DelegateArgs_StandardV1) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Amount`:
	if err = encoder.Encode(obj.Amount); err != nil {
		return fmt.Errorf("error while marshaling Amount:%w", err)
	}
	return nil
}

func (obj DelegateArgs_StandardV1) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding DelegateArgs_StandardV1: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *DelegateArgs_StandardV1) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Amount`:
	if err = decoder.Decode(&obj.Amount); err != nil {
		return fmt.Errorf("error while unmarshaling Amount:%w", err)
	}
	return nil
}

func (obj *DelegateArgs_StandardV1) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling DelegateArgs_StandardV1: %w", err)
	}
	return nil
}

func UnmarshalDelegateArgs_StandardV1(buf []byte) (*DelegateArgs_StandardV1, error) {
	obj := new(DelegateArgs_StandardV1)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *DelegateArgs_StandardV1) isDelegateArgs() {}

// Variant "LockedTransferV1" of enum "DelegateArgs"
type DelegateArgs_LockedTransferV1 struct {
	Amount            uint64             `json:"amount"`
	LockedAddress     solanago.PublicKey `json:"lockedAddress"`
	AuthorizationData *AuthorizationData `bin:"optional" json:"authorizationData,omitempty"`
}

func (obj DelegateArgs_LockedTransferV1) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Amount`:
	if err = encoder.Encode(obj.Amount); err != nil {
		return fmt.Errorf("error while marshaling Amount:%w", err)
	}
	// Serialize `LockedAddress`:
	if err = encoder.Encode(obj.LockedAddress); err != nil {
		return fmt.Errorf("error while marshaling LockedAddress:%w", err)
	}
	// Serialize `AuthorizationData` (optional):
	{
		if obj.AuthorizationData == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
			if err = encoder.Encode(obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData: %w", err)
			}
		}
	}
	return nil
}

func (obj DelegateArgs_LockedTransferV1) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding DelegateArgs_LockedTransferV1: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *DelegateArgs_LockedTransferV1) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Amount`:
	if err = decoder.Decode(&obj.Amount); err != nil {
		return fmt.Errorf("error while unmarshaling Amount:%w", err)
	}
	// Deserialize `LockedAddress`:
	if err = decoder.Decode(&obj.LockedAddress); err != nil {
		return fmt.Errorf("error while unmarshaling LockedAddress:%w", err)
	}
	// Deserialize `AuthorizationData` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
			}
		}
	}
	return nil
}

func (obj *DelegateArgs_LockedTransferV1) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling DelegateArgs_LockedTransferV1: %w", err)
	}
	return nil
}

func UnmarshalDelegateArgs_LockedTransferV1(buf []byte) (*DelegateArgs_LockedTransferV1, error) {
	obj := new(DelegateArgs_LockedTransferV1)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *DelegateArgs_LockedTransferV1) isDelegateArgs() {}

// Variant "ProgrammableConfigV1" of enum "DelegateArgs"
type DelegateArgs_ProgrammableConfigV1 struct {
	AuthorizationData *AuthorizationData `bin:"optional" json:"authorizationData,omitempty"`
}

func (obj DelegateArgs_ProgrammableConfigV1) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `AuthorizationData` (optional):
	{
		if obj.AuthorizationData == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
			if err = encoder.Encode(obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData: %w", err)
			}
		}
	}
	return nil
}

func (obj DelegateArgs_ProgrammableConfigV1) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding DelegateArgs_ProgrammableConfigV1: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *DelegateArgs_ProgrammableConfigV1) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `AuthorizationData` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
			}
		}
	}
	return nil
}

func (obj *DelegateArgs_ProgrammableConfigV1) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling DelegateArgs_ProgrammableConfigV1: %w", err)
	}
	return nil
}

func UnmarshalDelegateArgs_ProgrammableConfigV1(buf []byte) (*DelegateArgs_ProgrammableConfigV1, error) {
	obj := new(DelegateArgs_ProgrammableConfigV1)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *DelegateArgs_ProgrammableConfigV1) isDelegateArgs() {}

// Variant "AuthorityItemV1" of enum "DelegateArgs"
type DelegateArgs_AuthorityItemV1 struct {
	AuthorizationData *AuthorizationData `bin:"optional" json:"authorizationData,omitempty"`
}

func (obj DelegateArgs_AuthorityItemV1) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `AuthorizationData` (optional):
	{
		if obj.AuthorizationData == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
			if err = encoder.Encode(obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData: %w", err)
			}
		}
	}
	return nil
}

func (obj DelegateArgs_AuthorityItemV1) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding DelegateArgs_AuthorityItemV1: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *DelegateArgs_AuthorityItemV1) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `AuthorizationData` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
			}
		}
	}
	return nil
}

func (obj *DelegateArgs_AuthorityItemV1) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling DelegateArgs_AuthorityItemV1: %w", err)
	}
	return nil
}

func UnmarshalDelegateArgs_AuthorityItemV1(buf []byte) (*DelegateArgs_AuthorityItemV1, error) {
	obj := new(DelegateArgs_AuthorityItemV1)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *DelegateArgs_AuthorityItemV1) isDelegateArgs() {}

// Variant "DataItemV1" of enum "DelegateArgs"
type DelegateArgs_DataItemV1 struct {
	AuthorizationData *AuthorizationData `bin:"optional" json:"authorizationData,omitempty"`
}

func (obj DelegateArgs_DataItemV1) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `AuthorizationData` (optional):
	{
		if obj.AuthorizationData == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
			if err = encoder.Encode(obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData: %w", err)
			}
		}
	}
	return nil
}

func (obj DelegateArgs_DataItemV1) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding DelegateArgs_DataItemV1: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *DelegateArgs_DataItemV1) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `AuthorizationData` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
			}
		}
	}
	return nil
}

func (obj *DelegateArgs_DataItemV1) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling DelegateArgs_DataItemV1: %w", err)
	}
	return nil
}

func UnmarshalDelegateArgs_DataItemV1(buf []byte) (*DelegateArgs_DataItemV1, error) {
	obj := new(DelegateArgs_DataItemV1)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *DelegateArgs_DataItemV1) isDelegateArgs() {}

// Variant "CollectionItemV1" of enum "DelegateArgs"
type DelegateArgs_CollectionItemV1 struct {
	AuthorizationData *AuthorizationData `bin:"optional" json:"authorizationData,omitempty"`
}

func (obj DelegateArgs_CollectionItemV1) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `AuthorizationData` (optional):
	{
		if obj.AuthorizationData == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
			if err = encoder.Encode(obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData: %w", err)
			}
		}
	}
	return nil
}

func (obj DelegateArgs_CollectionItemV1) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding DelegateArgs_CollectionItemV1: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *DelegateArgs_CollectionItemV1) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `AuthorizationData` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
			}
		}
	}
	return nil
}

func (obj *DelegateArgs_CollectionItemV1) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling DelegateArgs_CollectionItemV1: %w", err)
	}
	return nil
}

func UnmarshalDelegateArgs_CollectionItemV1(buf []byte) (*DelegateArgs_CollectionItemV1, error) {
	obj := new(DelegateArgs_CollectionItemV1)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *DelegateArgs_CollectionItemV1) isDelegateArgs() {}

// Variant "ProgrammableConfigItemV1" of enum "DelegateArgs"
type DelegateArgs_ProgrammableConfigItemV1 struct {
	AuthorizationData *AuthorizationData `bin:"optional" json:"authorizationData,omitempty"`
}

func (obj DelegateArgs_ProgrammableConfigItemV1) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `AuthorizationData` (optional):
	{
		if obj.AuthorizationData == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
			if err = encoder.Encode(obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData: %w", err)
			}
		}
	}
	return nil
}

func (obj DelegateArgs_ProgrammableConfigItemV1) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding DelegateArgs_ProgrammableConfigItemV1: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *DelegateArgs_ProgrammableConfigItemV1) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `AuthorizationData` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
			}
		}
	}
	return nil
}

func (obj *DelegateArgs_ProgrammableConfigItemV1) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling DelegateArgs_ProgrammableConfigItemV1: %w", err)
	}
	return nil
}

func UnmarshalDelegateArgs_ProgrammableConfigItemV1(buf []byte) (*DelegateArgs_ProgrammableConfigItemV1, error) {
	obj := new(DelegateArgs_ProgrammableConfigItemV1)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *DelegateArgs_ProgrammableConfigItemV1) isDelegateArgs() {}

// Variant "PrintDelegateV1" of enum "DelegateArgs"
type DelegateArgs_PrintDelegateV1 struct {
	AuthorizationData *AuthorizationData `bin:"optional" json:"authorizationData,omitempty"`
}

func (obj DelegateArgs_PrintDelegateV1) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `AuthorizationData` (optional):
	{
		if obj.AuthorizationData == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
			if err = encoder.Encode(obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData: %w", err)
			}
		}
	}
	return nil
}

func (obj DelegateArgs_PrintDelegateV1) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding DelegateArgs_PrintDelegateV1: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *DelegateArgs_PrintDelegateV1) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `AuthorizationData` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
			}
		}
	}
	return nil
}

func (obj *DelegateArgs_PrintDelegateV1) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling DelegateArgs_PrintDelegateV1: %w", err)
	}
	return nil
}

func UnmarshalDelegateArgs_PrintDelegateV1(buf []byte) (*DelegateArgs_PrintDelegateV1, error) {
	obj := new(DelegateArgs_PrintDelegateV1)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *DelegateArgs_PrintDelegateV1) isDelegateArgs() {}

type RevokeArgs binary.BorshEnum

const (
	RevokeArgs_CollectionV1 RevokeArgs = iota
	RevokeArgs_SaleV1
	RevokeArgs_TransferV1
	RevokeArgs_DataV1
	RevokeArgs_UtilityV1
	RevokeArgs_StakingV1
	RevokeArgs_StandardV1
	RevokeArgs_LockedTransferV1
	RevokeArgs_ProgrammableConfigV1
	RevokeArgs_MigrationV1
	RevokeArgs_AuthorityItemV1
	RevokeArgs_DataItemV1
	RevokeArgs_CollectionItemV1
	RevokeArgs_ProgrammableConfigItemV1
	RevokeArgs_PrintDelegateV1
)

func (value RevokeArgs) String() string {
	switch value {
	case RevokeArgs_CollectionV1:
		return "CollectionV1"
	case RevokeArgs_SaleV1:
		return "SaleV1"
	case RevokeArgs_TransferV1:
		return "TransferV1"
	case RevokeArgs_DataV1:
		return "DataV1"
	case RevokeArgs_UtilityV1:
		return "UtilityV1"
	case RevokeArgs_StakingV1:
		return "StakingV1"
	case RevokeArgs_StandardV1:
		return "StandardV1"
	case RevokeArgs_LockedTransferV1:
		return "LockedTransferV1"
	case RevokeArgs_ProgrammableConfigV1:
		return "ProgrammableConfigV1"
	case RevokeArgs_MigrationV1:
		return "MigrationV1"
	case RevokeArgs_AuthorityItemV1:
		return "AuthorityItemV1"
	case RevokeArgs_DataItemV1:
		return "DataItemV1"
	case RevokeArgs_CollectionItemV1:
		return "CollectionItemV1"
	case RevokeArgs_ProgrammableConfigItemV1:
		return "ProgrammableConfigItemV1"
	case RevokeArgs_PrintDelegateV1:
		return "PrintDelegateV1"
	default:
		return ""
	}
}

type MetadataDelegateRole binary.BorshEnum

const (
	MetadataDelegateRole_AuthorityItem MetadataDelegateRole = iota
	MetadataDelegateRole_Collection
	MetadataDelegateRole_Use
	MetadataDelegateRole_Data
	MetadataDelegateRole_ProgrammableConfig
	MetadataDelegateRole_DataItem
	MetadataDelegateRole_CollectionItem
	MetadataDelegateRole_ProgrammableConfigItem
)

func (value MetadataDelegateRole) String() string {
	switch value {
	case MetadataDelegateRole_AuthorityItem:
		return "AuthorityItem"
	case MetadataDelegateRole_Collection:
		return "Collection"
	case MetadataDelegateRole_Use:
		return "Use"
	case MetadataDelegateRole_Data:
		return "Data"
	case MetadataDelegateRole_ProgrammableConfig:
		return "ProgrammableConfig"
	case MetadataDelegateRole_DataItem:
		return "DataItem"
	case MetadataDelegateRole_CollectionItem:
		return "CollectionItem"
	case MetadataDelegateRole_ProgrammableConfigItem:
		return "ProgrammableConfigItem"
	default:
		return ""
	}
}

type HolderDelegateRole binary.BorshEnum

const (
	HolderDelegateRole_PrintDelegate HolderDelegateRole = iota
)

func (value HolderDelegateRole) String() string {
	switch value {
	case HolderDelegateRole_PrintDelegate:
		return "PrintDelegate"
	default:
		return ""
	}
}

// The "isCreateArgs" interface for the "CreateArgs" complex enum.
type CreateArgs interface {
	isCreateArgs()
}

type createArgsEnumContainer struct {
	Enum binary.BorshEnum `bin:"enum"`
	V1   CreateArgs_V1
}

func DecodeCreateArgs(decoder *binary.Decoder) (CreateArgs, error) {
	{
		tmp := new(createArgsEnumContainer)
		err := decoder.Decode(tmp)
		if err != nil {
			return nil, fmt.Errorf("failed parsing CreateArgs: %w", err)
		}
		switch tmp.Enum {
		case 0:
			return &tmp.V1, nil
		default:
			return nil, fmt.Errorf("CreateArgs: unknown enum index: %v", tmp.Enum)
		}
	}
}

func EncodeCreateArgs(encoder *binary.Encoder, value CreateArgs) error {
	{
		tmp := createArgsEnumContainer{}
		switch realvalue := value.(type) {
		case *CreateArgs_V1:
			tmp.Enum = 0
			tmp.V1 = *realvalue
		}
		return encoder.Encode(tmp)
	}
}

// Variant "V1" of enum "CreateArgs"
type CreateArgs_V1 struct {
	AssetData   AssetData    `json:"assetData"`
	Decimals    *uint8       `bin:"optional" json:"decimals,omitempty"`
	PrintSupply *PrintSupply `bin:"optional" json:"printSupply,omitempty"`
}

func (obj CreateArgs_V1) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `AssetData`:
	if err = encoder.Encode(obj.AssetData); err != nil {
		return fmt.Errorf("error while marshaling AssetData:%w", err)
	}
	// Serialize `Decimals` (optional):
	{
		if obj.Decimals == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling Decimals optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling Decimals optionality: %w", err)
			}
			if err = encoder.Encode(obj.Decimals); err != nil {
				return fmt.Errorf("error while marshaling Decimals: %w", err)
			}
		}
	}
	// Serialize `PrintSupply` (optional):
	{
		if obj.PrintSupply == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling PrintSupply optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling PrintSupply optionality: %w", err)
			}
			if err = encoder.Encode(obj.PrintSupply); err != nil {
				return fmt.Errorf("error while marshaling PrintSupply: %w", err)
			}
		}
	}
	return nil
}

func (obj CreateArgs_V1) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding CreateArgs_V1: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *CreateArgs_V1) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `AssetData`:
	if err = decoder.Decode(&obj.AssetData); err != nil {
		return fmt.Errorf("error while unmarshaling AssetData:%w", err)
	}
	// Deserialize `Decimals` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling Decimals:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.Decimals); err != nil {
				return fmt.Errorf("error while unmarshaling Decimals:%w", err)
			}
		}
	}
	// Deserialize `PrintSupply` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling PrintSupply:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.PrintSupply); err != nil {
				return fmt.Errorf("error while unmarshaling PrintSupply:%w", err)
			}
		}
	}
	return nil
}

func (obj *CreateArgs_V1) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CreateArgs_V1: %w", err)
	}
	return nil
}

func UnmarshalCreateArgs_V1(buf []byte) (*CreateArgs_V1, error) {
	obj := new(CreateArgs_V1)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *CreateArgs_V1) isCreateArgs() {}

// The "isMintArgs" interface for the "MintArgs" complex enum.
type MintArgs interface {
	isMintArgs()
}

type mintArgsEnumContainer struct {
	Enum binary.BorshEnum `bin:"enum"`
	V1   MintArgs_V1
}

func DecodeMintArgs(decoder *binary.Decoder) (MintArgs, error) {
	{
		tmp := new(mintArgsEnumContainer)
		err := decoder.Decode(tmp)
		if err != nil {
			return nil, fmt.Errorf("failed parsing MintArgs: %w", err)
		}
		switch tmp.Enum {
		case 0:
			return &tmp.V1, nil
		default:
			return nil, fmt.Errorf("MintArgs: unknown enum index: %v", tmp.Enum)
		}
	}
}

func EncodeMintArgs(encoder *binary.Encoder, value MintArgs) error {
	{
		tmp := mintArgsEnumContainer{}
		switch realvalue := value.(type) {
		case *MintArgs_V1:
			tmp.Enum = 0
			tmp.V1 = *realvalue
		}
		return encoder.Encode(tmp)
	}
}

// Variant "V1" of enum "MintArgs"
type MintArgs_V1 struct {
	Amount            uint64             `json:"amount"`
	AuthorizationData *AuthorizationData `bin:"optional" json:"authorizationData,omitempty"`
}

func (obj MintArgs_V1) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Amount`:
	if err = encoder.Encode(obj.Amount); err != nil {
		return fmt.Errorf("error while marshaling Amount:%w", err)
	}
	// Serialize `AuthorizationData` (optional):
	{
		if obj.AuthorizationData == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
			if err = encoder.Encode(obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData: %w", err)
			}
		}
	}
	return nil
}

func (obj MintArgs_V1) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding MintArgs_V1: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *MintArgs_V1) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Amount`:
	if err = decoder.Decode(&obj.Amount); err != nil {
		return fmt.Errorf("error while unmarshaling Amount:%w", err)
	}
	// Deserialize `AuthorizationData` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
			}
		}
	}
	return nil
}

func (obj *MintArgs_V1) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling MintArgs_V1: %w", err)
	}
	return nil
}

func UnmarshalMintArgs_V1(buf []byte) (*MintArgs_V1, error) {
	obj := new(MintArgs_V1)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *MintArgs_V1) isMintArgs() {}

// The "isTransferArgs" interface for the "TransferArgs" complex enum.
type TransferArgs interface {
	isTransferArgs()
}

type transferArgsEnumContainer struct {
	Enum binary.BorshEnum `bin:"enum"`
	V1   TransferArgs_V1
}

func DecodeTransferArgs(decoder *binary.Decoder) (TransferArgs, error) {
	{
		tmp := new(transferArgsEnumContainer)
		err := decoder.Decode(tmp)
		if err != nil {
			return nil, fmt.Errorf("failed parsing TransferArgs: %w", err)
		}
		switch tmp.Enum {
		case 0:
			return &tmp.V1, nil
		default:
			return nil, fmt.Errorf("TransferArgs: unknown enum index: %v", tmp.Enum)
		}
	}
}

func EncodeTransferArgs(encoder *binary.Encoder, value TransferArgs) error {
	{
		tmp := transferArgsEnumContainer{}
		switch realvalue := value.(type) {
		case *TransferArgs_V1:
			tmp.Enum = 0
			tmp.V1 = *realvalue
		}
		return encoder.Encode(tmp)
	}
}

// Variant "V1" of enum "TransferArgs"
type TransferArgs_V1 struct {
	Amount            uint64             `json:"amount"`
	AuthorizationData *AuthorizationData `bin:"optional" json:"authorizationData,omitempty"`
}

func (obj TransferArgs_V1) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Amount`:
	if err = encoder.Encode(obj.Amount); err != nil {
		return fmt.Errorf("error while marshaling Amount:%w", err)
	}
	// Serialize `AuthorizationData` (optional):
	{
		if obj.AuthorizationData == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
			if err = encoder.Encode(obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData: %w", err)
			}
		}
	}
	return nil
}

func (obj TransferArgs_V1) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding TransferArgs_V1: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *TransferArgs_V1) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Amount`:
	if err = decoder.Decode(&obj.Amount); err != nil {
		return fmt.Errorf("error while unmarshaling Amount:%w", err)
	}
	// Deserialize `AuthorizationData` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
			}
		}
	}
	return nil
}

func (obj *TransferArgs_V1) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling TransferArgs_V1: %w", err)
	}
	return nil
}

func UnmarshalTransferArgs_V1(buf []byte) (*TransferArgs_V1, error) {
	obj := new(TransferArgs_V1)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *TransferArgs_V1) isTransferArgs() {}

// The "isUpdateArgs" interface for the "UpdateArgs" complex enum.
type UpdateArgs interface {
	isUpdateArgs()
}

type updateArgsEnumContainer struct {
	Enum                               binary.BorshEnum `bin:"enum"`
	V1                                 UpdateArgs_V1
	AsUpdateAuthorityV2                UpdateArgs_AsUpdateAuthorityV2
	AsAuthorityItemDelegateV2          UpdateArgs_AsAuthorityItemDelegateV2
	AsCollectionDelegateV2             UpdateArgs_AsCollectionDelegateV2
	AsDataDelegateV2                   UpdateArgs_AsDataDelegateV2
	AsProgrammableConfigDelegateV2     UpdateArgs_AsProgrammableConfigDelegateV2
	AsDataItemDelegateV2               UpdateArgs_AsDataItemDelegateV2
	AsCollectionItemDelegateV2         UpdateArgs_AsCollectionItemDelegateV2
	AsProgrammableConfigItemDelegateV2 UpdateArgs_AsProgrammableConfigItemDelegateV2
}

func DecodeUpdateArgs(decoder *binary.Decoder) (UpdateArgs, error) {
	{
		tmp := new(updateArgsEnumContainer)
		err := decoder.Decode(tmp)
		if err != nil {
			return nil, fmt.Errorf("failed parsing UpdateArgs: %w", err)
		}
		switch tmp.Enum {
		case 0:
			return &tmp.V1, nil
		case 1:
			return &tmp.AsUpdateAuthorityV2, nil
		case 2:
			return &tmp.AsAuthorityItemDelegateV2, nil
		case 3:
			return &tmp.AsCollectionDelegateV2, nil
		case 4:
			return &tmp.AsDataDelegateV2, nil
		case 5:
			return &tmp.AsProgrammableConfigDelegateV2, nil
		case 6:
			return &tmp.AsDataItemDelegateV2, nil
		case 7:
			return &tmp.AsCollectionItemDelegateV2, nil
		case 8:
			return &tmp.AsProgrammableConfigItemDelegateV2, nil
		default:
			return nil, fmt.Errorf("UpdateArgs: unknown enum index: %v", tmp.Enum)
		}
	}
}

func EncodeUpdateArgs(encoder *binary.Encoder, value UpdateArgs) error {
	{
		tmp := updateArgsEnumContainer{}
		switch realvalue := value.(type) {
		case *UpdateArgs_V1:
			tmp.Enum = 0
			tmp.V1 = *realvalue
		case *UpdateArgs_AsUpdateAuthorityV2:
			tmp.Enum = 1
			tmp.AsUpdateAuthorityV2 = *realvalue
		case *UpdateArgs_AsAuthorityItemDelegateV2:
			tmp.Enum = 2
			tmp.AsAuthorityItemDelegateV2 = *realvalue
		case *UpdateArgs_AsCollectionDelegateV2:
			tmp.Enum = 3
			tmp.AsCollectionDelegateV2 = *realvalue
		case *UpdateArgs_AsDataDelegateV2:
			tmp.Enum = 4
			tmp.AsDataDelegateV2 = *realvalue
		case *UpdateArgs_AsProgrammableConfigDelegateV2:
			tmp.Enum = 5
			tmp.AsProgrammableConfigDelegateV2 = *realvalue
		case *UpdateArgs_AsDataItemDelegateV2:
			tmp.Enum = 6
			tmp.AsDataItemDelegateV2 = *realvalue
		case *UpdateArgs_AsCollectionItemDelegateV2:
			tmp.Enum = 7
			tmp.AsCollectionItemDelegateV2 = *realvalue
		case *UpdateArgs_AsProgrammableConfigItemDelegateV2:
			tmp.Enum = 8
			tmp.AsProgrammableConfigItemDelegateV2 = *realvalue
		}
		return encoder.Encode(tmp)
	}
}

// Variant "V1" of enum "UpdateArgs"
type UpdateArgs_V1 struct {
	NewUpdateAuthority  *solanago.PublicKey     `bin:"optional" json:"newUpdateAuthority,omitempty"`
	Data                *Data                   `bin:"optional" json:"data,omitempty"`
	PrimarySaleHappened *bool                   `bin:"optional" json:"primarySaleHappened,omitempty"`
	IsMutable           *bool                   `bin:"optional" json:"isMutable,omitempty"`
	Collection          CollectionToggle        `json:"collection"`
	CollectionDetails   CollectionDetailsToggle `json:"collectionDetails"`
	Uses                UsesToggle              `json:"uses"`
	RuleSet             RuleSetToggle           `json:"ruleSet"`
	AuthorizationData   *AuthorizationData      `bin:"optional" json:"authorizationData,omitempty"`
}

func (obj UpdateArgs_V1) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `NewUpdateAuthority` (optional):
	{
		if obj.NewUpdateAuthority == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling NewUpdateAuthority optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling NewUpdateAuthority optionality: %w", err)
			}
			if err = encoder.Encode(obj.NewUpdateAuthority); err != nil {
				return fmt.Errorf("error while marshaling NewUpdateAuthority: %w", err)
			}
		}
	}
	// Serialize `Data` (optional):
	{
		if obj.Data == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling Data optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling Data optionality: %w", err)
			}
			if err = encoder.Encode(obj.Data); err != nil {
				return fmt.Errorf("error while marshaling Data: %w", err)
			}
		}
	}
	// Serialize `PrimarySaleHappened` (optional):
	{
		if obj.PrimarySaleHappened == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling PrimarySaleHappened optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling PrimarySaleHappened optionality: %w", err)
			}
			if err = encoder.Encode(obj.PrimarySaleHappened); err != nil {
				return fmt.Errorf("error while marshaling PrimarySaleHappened: %w", err)
			}
		}
	}
	// Serialize `IsMutable` (optional):
	{
		if obj.IsMutable == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling IsMutable optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling IsMutable optionality: %w", err)
			}
			if err = encoder.Encode(obj.IsMutable); err != nil {
				return fmt.Errorf("error while marshaling IsMutable: %w", err)
			}
		}
	}
	// Serialize `Collection`:
	{
		if err = EncodeCollectionToggle(encoder, obj.Collection); err != nil {
			return fmt.Errorf("error while marshalingCollection:%w", err)
		}
	}
	// Serialize `CollectionDetails`:
	{
		if err = EncodeCollectionDetailsToggle(encoder, obj.CollectionDetails); err != nil {
			return fmt.Errorf("error while marshalingCollectionDetails:%w", err)
		}
	}
	// Serialize `Uses`:
	{
		if err = EncodeUsesToggle(encoder, obj.Uses); err != nil {
			return fmt.Errorf("error while marshalingUses:%w", err)
		}
	}
	// Serialize `RuleSet`:
	{
		if err = EncodeRuleSetToggle(encoder, obj.RuleSet); err != nil {
			return fmt.Errorf("error while marshalingRuleSet:%w", err)
		}
	}
	// Serialize `AuthorizationData` (optional):
	{
		if obj.AuthorizationData == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
			if err = encoder.Encode(obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData: %w", err)
			}
		}
	}
	return nil
}

func (obj UpdateArgs_V1) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding UpdateArgs_V1: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *UpdateArgs_V1) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `NewUpdateAuthority` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling NewUpdateAuthority:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.NewUpdateAuthority); err != nil {
				return fmt.Errorf("error while unmarshaling NewUpdateAuthority:%w", err)
			}
		}
	}
	// Deserialize `Data` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling Data:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.Data); err != nil {
				return fmt.Errorf("error while unmarshaling Data:%w", err)
			}
		}
	}
	// Deserialize `PrimarySaleHappened` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling PrimarySaleHappened:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.PrimarySaleHappened); err != nil {
				return fmt.Errorf("error while unmarshaling PrimarySaleHappened:%w", err)
			}
		}
	}
	// Deserialize `IsMutable` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling IsMutable:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.IsMutable); err != nil {
				return fmt.Errorf("error while unmarshaling IsMutable:%w", err)
			}
		}
	}
	// Deserialize `Collection`:
	{
		var err error
		obj.Collection, err = DecodeCollectionToggle(decoder)
		if err != nil {
			return err
		}
	}
	// Deserialize `CollectionDetails`:
	{
		var err error
		obj.CollectionDetails, err = DecodeCollectionDetailsToggle(decoder)
		if err != nil {
			return err
		}
	}
	// Deserialize `Uses`:
	{
		var err error
		obj.Uses, err = DecodeUsesToggle(decoder)
		if err != nil {
			return err
		}
	}
	// Deserialize `RuleSet`:
	{
		var err error
		obj.RuleSet, err = DecodeRuleSetToggle(decoder)
		if err != nil {
			return err
		}
	}
	// Deserialize `AuthorizationData` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
			}
		}
	}
	return nil
}

func (obj *UpdateArgs_V1) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateArgs_V1: %w", err)
	}
	return nil
}

func UnmarshalUpdateArgs_V1(buf []byte) (*UpdateArgs_V1, error) {
	obj := new(UpdateArgs_V1)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *UpdateArgs_V1) isUpdateArgs() {}

// Variant "AsUpdateAuthorityV2" of enum "UpdateArgs"
type UpdateArgs_AsUpdateAuthorityV2 struct {
	NewUpdateAuthority  *solanago.PublicKey     `bin:"optional" json:"newUpdateAuthority,omitempty"`
	Data                *Data                   `bin:"optional" json:"data,omitempty"`
	PrimarySaleHappened *bool                   `bin:"optional" json:"primarySaleHappened,omitempty"`
	IsMutable           *bool                   `bin:"optional" json:"isMutable,omitempty"`
	Collection          CollectionToggle        `json:"collection"`
	CollectionDetails   CollectionDetailsToggle `json:"collectionDetails"`
	Uses                UsesToggle              `json:"uses"`
	RuleSet             RuleSetToggle           `json:"ruleSet"`
	TokenStandard       *TokenStandard          `bin:"optional" json:"tokenStandard,omitempty"`
	AuthorizationData   *AuthorizationData      `bin:"optional" json:"authorizationData,omitempty"`
}

func (obj UpdateArgs_AsUpdateAuthorityV2) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `NewUpdateAuthority` (optional):
	{
		if obj.NewUpdateAuthority == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling NewUpdateAuthority optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling NewUpdateAuthority optionality: %w", err)
			}
			if err = encoder.Encode(obj.NewUpdateAuthority); err != nil {
				return fmt.Errorf("error while marshaling NewUpdateAuthority: %w", err)
			}
		}
	}
	// Serialize `Data` (optional):
	{
		if obj.Data == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling Data optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling Data optionality: %w", err)
			}
			if err = encoder.Encode(obj.Data); err != nil {
				return fmt.Errorf("error while marshaling Data: %w", err)
			}
		}
	}
	// Serialize `PrimarySaleHappened` (optional):
	{
		if obj.PrimarySaleHappened == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling PrimarySaleHappened optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling PrimarySaleHappened optionality: %w", err)
			}
			if err = encoder.Encode(obj.PrimarySaleHappened); err != nil {
				return fmt.Errorf("error while marshaling PrimarySaleHappened: %w", err)
			}
		}
	}
	// Serialize `IsMutable` (optional):
	{
		if obj.IsMutable == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling IsMutable optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling IsMutable optionality: %w", err)
			}
			if err = encoder.Encode(obj.IsMutable); err != nil {
				return fmt.Errorf("error while marshaling IsMutable: %w", err)
			}
		}
	}
	// Serialize `Collection`:
	{
		if err = EncodeCollectionToggle(encoder, obj.Collection); err != nil {
			return fmt.Errorf("error while marshalingCollection:%w", err)
		}
	}
	// Serialize `CollectionDetails`:
	{
		if err = EncodeCollectionDetailsToggle(encoder, obj.CollectionDetails); err != nil {
			return fmt.Errorf("error while marshalingCollectionDetails:%w", err)
		}
	}
	// Serialize `Uses`:
	{
		if err = EncodeUsesToggle(encoder, obj.Uses); err != nil {
			return fmt.Errorf("error while marshalingUses:%w", err)
		}
	}
	// Serialize `RuleSet`:
	{
		if err = EncodeRuleSetToggle(encoder, obj.RuleSet); err != nil {
			return fmt.Errorf("error while marshalingRuleSet:%w", err)
		}
	}
	// Serialize `TokenStandard` (optional):
	{
		if obj.TokenStandard == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling TokenStandard optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling TokenStandard optionality: %w", err)
			}
			if err = encoder.Encode(obj.TokenStandard); err != nil {
				return fmt.Errorf("error while marshaling TokenStandard: %w", err)
			}
		}
	}
	// Serialize `AuthorizationData` (optional):
	{
		if obj.AuthorizationData == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
			if err = encoder.Encode(obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData: %w", err)
			}
		}
	}
	return nil
}

func (obj UpdateArgs_AsUpdateAuthorityV2) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding UpdateArgs_AsUpdateAuthorityV2: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *UpdateArgs_AsUpdateAuthorityV2) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `NewUpdateAuthority` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling NewUpdateAuthority:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.NewUpdateAuthority); err != nil {
				return fmt.Errorf("error while unmarshaling NewUpdateAuthority:%w", err)
			}
		}
	}
	// Deserialize `Data` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling Data:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.Data); err != nil {
				return fmt.Errorf("error while unmarshaling Data:%w", err)
			}
		}
	}
	// Deserialize `PrimarySaleHappened` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling PrimarySaleHappened:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.PrimarySaleHappened); err != nil {
				return fmt.Errorf("error while unmarshaling PrimarySaleHappened:%w", err)
			}
		}
	}
	// Deserialize `IsMutable` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling IsMutable:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.IsMutable); err != nil {
				return fmt.Errorf("error while unmarshaling IsMutable:%w", err)
			}
		}
	}
	// Deserialize `Collection`:
	{
		var err error
		obj.Collection, err = DecodeCollectionToggle(decoder)
		if err != nil {
			return err
		}
	}
	// Deserialize `CollectionDetails`:
	{
		var err error
		obj.CollectionDetails, err = DecodeCollectionDetailsToggle(decoder)
		if err != nil {
			return err
		}
	}
	// Deserialize `Uses`:
	{
		var err error
		obj.Uses, err = DecodeUsesToggle(decoder)
		if err != nil {
			return err
		}
	}
	// Deserialize `RuleSet`:
	{
		var err error
		obj.RuleSet, err = DecodeRuleSetToggle(decoder)
		if err != nil {
			return err
		}
	}
	// Deserialize `TokenStandard` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling TokenStandard:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.TokenStandard); err != nil {
				return fmt.Errorf("error while unmarshaling TokenStandard:%w", err)
			}
		}
	}
	// Deserialize `AuthorizationData` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
			}
		}
	}
	return nil
}

func (obj *UpdateArgs_AsUpdateAuthorityV2) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateArgs_AsUpdateAuthorityV2: %w", err)
	}
	return nil
}

func UnmarshalUpdateArgs_AsUpdateAuthorityV2(buf []byte) (*UpdateArgs_AsUpdateAuthorityV2, error) {
	obj := new(UpdateArgs_AsUpdateAuthorityV2)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *UpdateArgs_AsUpdateAuthorityV2) isUpdateArgs() {}

// Variant "AsAuthorityItemDelegateV2" of enum "UpdateArgs"
type UpdateArgs_AsAuthorityItemDelegateV2 struct {
	NewUpdateAuthority  *solanago.PublicKey `bin:"optional" json:"newUpdateAuthority,omitempty"`
	PrimarySaleHappened *bool               `bin:"optional" json:"primarySaleHappened,omitempty"`
	IsMutable           *bool               `bin:"optional" json:"isMutable,omitempty"`
	TokenStandard       *TokenStandard      `bin:"optional" json:"tokenStandard,omitempty"`
	AuthorizationData   *AuthorizationData  `bin:"optional" json:"authorizationData,omitempty"`
}

func (obj UpdateArgs_AsAuthorityItemDelegateV2) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `NewUpdateAuthority` (optional):
	{
		if obj.NewUpdateAuthority == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling NewUpdateAuthority optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling NewUpdateAuthority optionality: %w", err)
			}
			if err = encoder.Encode(obj.NewUpdateAuthority); err != nil {
				return fmt.Errorf("error while marshaling NewUpdateAuthority: %w", err)
			}
		}
	}
	// Serialize `PrimarySaleHappened` (optional):
	{
		if obj.PrimarySaleHappened == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling PrimarySaleHappened optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling PrimarySaleHappened optionality: %w", err)
			}
			if err = encoder.Encode(obj.PrimarySaleHappened); err != nil {
				return fmt.Errorf("error while marshaling PrimarySaleHappened: %w", err)
			}
		}
	}
	// Serialize `IsMutable` (optional):
	{
		if obj.IsMutable == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling IsMutable optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling IsMutable optionality: %w", err)
			}
			if err = encoder.Encode(obj.IsMutable); err != nil {
				return fmt.Errorf("error while marshaling IsMutable: %w", err)
			}
		}
	}
	// Serialize `TokenStandard` (optional):
	{
		if obj.TokenStandard == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling TokenStandard optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling TokenStandard optionality: %w", err)
			}
			if err = encoder.Encode(obj.TokenStandard); err != nil {
				return fmt.Errorf("error while marshaling TokenStandard: %w", err)
			}
		}
	}
	// Serialize `AuthorizationData` (optional):
	{
		if obj.AuthorizationData == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
			if err = encoder.Encode(obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData: %w", err)
			}
		}
	}
	return nil
}

func (obj UpdateArgs_AsAuthorityItemDelegateV2) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding UpdateArgs_AsAuthorityItemDelegateV2: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *UpdateArgs_AsAuthorityItemDelegateV2) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `NewUpdateAuthority` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling NewUpdateAuthority:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.NewUpdateAuthority); err != nil {
				return fmt.Errorf("error while unmarshaling NewUpdateAuthority:%w", err)
			}
		}
	}
	// Deserialize `PrimarySaleHappened` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling PrimarySaleHappened:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.PrimarySaleHappened); err != nil {
				return fmt.Errorf("error while unmarshaling PrimarySaleHappened:%w", err)
			}
		}
	}
	// Deserialize `IsMutable` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling IsMutable:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.IsMutable); err != nil {
				return fmt.Errorf("error while unmarshaling IsMutable:%w", err)
			}
		}
	}
	// Deserialize `TokenStandard` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling TokenStandard:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.TokenStandard); err != nil {
				return fmt.Errorf("error while unmarshaling TokenStandard:%w", err)
			}
		}
	}
	// Deserialize `AuthorizationData` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
			}
		}
	}
	return nil
}

func (obj *UpdateArgs_AsAuthorityItemDelegateV2) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateArgs_AsAuthorityItemDelegateV2: %w", err)
	}
	return nil
}

func UnmarshalUpdateArgs_AsAuthorityItemDelegateV2(buf []byte) (*UpdateArgs_AsAuthorityItemDelegateV2, error) {
	obj := new(UpdateArgs_AsAuthorityItemDelegateV2)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *UpdateArgs_AsAuthorityItemDelegateV2) isUpdateArgs() {}

// Variant "AsCollectionDelegateV2" of enum "UpdateArgs"
type UpdateArgs_AsCollectionDelegateV2 struct {
	Collection        CollectionToggle   `json:"collection"`
	AuthorizationData *AuthorizationData `bin:"optional" json:"authorizationData,omitempty"`
}

func (obj UpdateArgs_AsCollectionDelegateV2) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Collection`:
	{
		if err = EncodeCollectionToggle(encoder, obj.Collection); err != nil {
			return fmt.Errorf("error while marshalingCollection:%w", err)
		}
	}
	// Serialize `AuthorizationData` (optional):
	{
		if obj.AuthorizationData == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
			if err = encoder.Encode(obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData: %w", err)
			}
		}
	}
	return nil
}

func (obj UpdateArgs_AsCollectionDelegateV2) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding UpdateArgs_AsCollectionDelegateV2: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *UpdateArgs_AsCollectionDelegateV2) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Collection`:
	{
		var err error
		obj.Collection, err = DecodeCollectionToggle(decoder)
		if err != nil {
			return err
		}
	}
	// Deserialize `AuthorizationData` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
			}
		}
	}
	return nil
}

func (obj *UpdateArgs_AsCollectionDelegateV2) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateArgs_AsCollectionDelegateV2: %w", err)
	}
	return nil
}

func UnmarshalUpdateArgs_AsCollectionDelegateV2(buf []byte) (*UpdateArgs_AsCollectionDelegateV2, error) {
	obj := new(UpdateArgs_AsCollectionDelegateV2)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *UpdateArgs_AsCollectionDelegateV2) isUpdateArgs() {}

// Variant "AsDataDelegateV2" of enum "UpdateArgs"
type UpdateArgs_AsDataDelegateV2 struct {
	Data              *Data              `bin:"optional" json:"data,omitempty"`
	AuthorizationData *AuthorizationData `bin:"optional" json:"authorizationData,omitempty"`
}

func (obj UpdateArgs_AsDataDelegateV2) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Data` (optional):
	{
		if obj.Data == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling Data optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling Data optionality: %w", err)
			}
			if err = encoder.Encode(obj.Data); err != nil {
				return fmt.Errorf("error while marshaling Data: %w", err)
			}
		}
	}
	// Serialize `AuthorizationData` (optional):
	{
		if obj.AuthorizationData == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
			if err = encoder.Encode(obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData: %w", err)
			}
		}
	}
	return nil
}

func (obj UpdateArgs_AsDataDelegateV2) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding UpdateArgs_AsDataDelegateV2: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *UpdateArgs_AsDataDelegateV2) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Data` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling Data:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.Data); err != nil {
				return fmt.Errorf("error while unmarshaling Data:%w", err)
			}
		}
	}
	// Deserialize `AuthorizationData` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
			}
		}
	}
	return nil
}

func (obj *UpdateArgs_AsDataDelegateV2) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateArgs_AsDataDelegateV2: %w", err)
	}
	return nil
}

func UnmarshalUpdateArgs_AsDataDelegateV2(buf []byte) (*UpdateArgs_AsDataDelegateV2, error) {
	obj := new(UpdateArgs_AsDataDelegateV2)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *UpdateArgs_AsDataDelegateV2) isUpdateArgs() {}

// Variant "AsProgrammableConfigDelegateV2" of enum "UpdateArgs"
type UpdateArgs_AsProgrammableConfigDelegateV2 struct {
	RuleSet           RuleSetToggle      `json:"ruleSet"`
	AuthorizationData *AuthorizationData `bin:"optional" json:"authorizationData,omitempty"`
}

func (obj UpdateArgs_AsProgrammableConfigDelegateV2) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `RuleSet`:
	{
		if err = EncodeRuleSetToggle(encoder, obj.RuleSet); err != nil {
			return fmt.Errorf("error while marshalingRuleSet:%w", err)
		}
	}
	// Serialize `AuthorizationData` (optional):
	{
		if obj.AuthorizationData == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
			if err = encoder.Encode(obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData: %w", err)
			}
		}
	}
	return nil
}

func (obj UpdateArgs_AsProgrammableConfigDelegateV2) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding UpdateArgs_AsProgrammableConfigDelegateV2: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *UpdateArgs_AsProgrammableConfigDelegateV2) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `RuleSet`:
	{
		var err error
		obj.RuleSet, err = DecodeRuleSetToggle(decoder)
		if err != nil {
			return err
		}
	}
	// Deserialize `AuthorizationData` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
			}
		}
	}
	return nil
}

func (obj *UpdateArgs_AsProgrammableConfigDelegateV2) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateArgs_AsProgrammableConfigDelegateV2: %w", err)
	}
	return nil
}

func UnmarshalUpdateArgs_AsProgrammableConfigDelegateV2(buf []byte) (*UpdateArgs_AsProgrammableConfigDelegateV2, error) {
	obj := new(UpdateArgs_AsProgrammableConfigDelegateV2)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *UpdateArgs_AsProgrammableConfigDelegateV2) isUpdateArgs() {}

// Variant "AsDataItemDelegateV2" of enum "UpdateArgs"
type UpdateArgs_AsDataItemDelegateV2 struct {
	Data              *Data              `bin:"optional" json:"data,omitempty"`
	AuthorizationData *AuthorizationData `bin:"optional" json:"authorizationData,omitempty"`
}

func (obj UpdateArgs_AsDataItemDelegateV2) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Data` (optional):
	{
		if obj.Data == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling Data optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling Data optionality: %w", err)
			}
			if err = encoder.Encode(obj.Data); err != nil {
				return fmt.Errorf("error while marshaling Data: %w", err)
			}
		}
	}
	// Serialize `AuthorizationData` (optional):
	{
		if obj.AuthorizationData == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
			if err = encoder.Encode(obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData: %w", err)
			}
		}
	}
	return nil
}

func (obj UpdateArgs_AsDataItemDelegateV2) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding UpdateArgs_AsDataItemDelegateV2: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *UpdateArgs_AsDataItemDelegateV2) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Data` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling Data:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.Data); err != nil {
				return fmt.Errorf("error while unmarshaling Data:%w", err)
			}
		}
	}
	// Deserialize `AuthorizationData` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
			}
		}
	}
	return nil
}

func (obj *UpdateArgs_AsDataItemDelegateV2) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateArgs_AsDataItemDelegateV2: %w", err)
	}
	return nil
}

func UnmarshalUpdateArgs_AsDataItemDelegateV2(buf []byte) (*UpdateArgs_AsDataItemDelegateV2, error) {
	obj := new(UpdateArgs_AsDataItemDelegateV2)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *UpdateArgs_AsDataItemDelegateV2) isUpdateArgs() {}

// Variant "AsCollectionItemDelegateV2" of enum "UpdateArgs"
type UpdateArgs_AsCollectionItemDelegateV2 struct {
	Collection        CollectionToggle   `json:"collection"`
	AuthorizationData *AuthorizationData `bin:"optional" json:"authorizationData,omitempty"`
}

func (obj UpdateArgs_AsCollectionItemDelegateV2) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Collection`:
	{
		if err = EncodeCollectionToggle(encoder, obj.Collection); err != nil {
			return fmt.Errorf("error while marshalingCollection:%w", err)
		}
	}
	// Serialize `AuthorizationData` (optional):
	{
		if obj.AuthorizationData == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
			if err = encoder.Encode(obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData: %w", err)
			}
		}
	}
	return nil
}

func (obj UpdateArgs_AsCollectionItemDelegateV2) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding UpdateArgs_AsCollectionItemDelegateV2: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *UpdateArgs_AsCollectionItemDelegateV2) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Collection`:
	{
		var err error
		obj.Collection, err = DecodeCollectionToggle(decoder)
		if err != nil {
			return err
		}
	}
	// Deserialize `AuthorizationData` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
			}
		}
	}
	return nil
}

func (obj *UpdateArgs_AsCollectionItemDelegateV2) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateArgs_AsCollectionItemDelegateV2: %w", err)
	}
	return nil
}

func UnmarshalUpdateArgs_AsCollectionItemDelegateV2(buf []byte) (*UpdateArgs_AsCollectionItemDelegateV2, error) {
	obj := new(UpdateArgs_AsCollectionItemDelegateV2)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *UpdateArgs_AsCollectionItemDelegateV2) isUpdateArgs() {}

// Variant "AsProgrammableConfigItemDelegateV2" of enum "UpdateArgs"
type UpdateArgs_AsProgrammableConfigItemDelegateV2 struct {
	RuleSet           RuleSetToggle      `json:"ruleSet"`
	AuthorizationData *AuthorizationData `bin:"optional" json:"authorizationData,omitempty"`
}

func (obj UpdateArgs_AsProgrammableConfigItemDelegateV2) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `RuleSet`:
	{
		if err = EncodeRuleSetToggle(encoder, obj.RuleSet); err != nil {
			return fmt.Errorf("error while marshalingRuleSet:%w", err)
		}
	}
	// Serialize `AuthorizationData` (optional):
	{
		if obj.AuthorizationData == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
			if err = encoder.Encode(obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData: %w", err)
			}
		}
	}
	return nil
}

func (obj UpdateArgs_AsProgrammableConfigItemDelegateV2) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding UpdateArgs_AsProgrammableConfigItemDelegateV2: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *UpdateArgs_AsProgrammableConfigItemDelegateV2) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `RuleSet`:
	{
		var err error
		obj.RuleSet, err = DecodeRuleSetToggle(decoder)
		if err != nil {
			return err
		}
	}
	// Deserialize `AuthorizationData` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
			}
		}
	}
	return nil
}

func (obj *UpdateArgs_AsProgrammableConfigItemDelegateV2) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UpdateArgs_AsProgrammableConfigItemDelegateV2: %w", err)
	}
	return nil
}

func UnmarshalUpdateArgs_AsProgrammableConfigItemDelegateV2(buf []byte) (*UpdateArgs_AsProgrammableConfigItemDelegateV2, error) {
	obj := new(UpdateArgs_AsProgrammableConfigItemDelegateV2)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *UpdateArgs_AsProgrammableConfigItemDelegateV2) isUpdateArgs() {}

// The "isCollectionToggle" interface for the "CollectionToggle" complex enum.
type CollectionToggle interface {
	isCollectionToggle()
}

type collectionToggleEnumContainer struct {
	Enum  binary.BorshEnum `bin:"enum"`
	None  CollectionToggle_None
	Clear CollectionToggle_Clear
	Set   CollectionToggle_Set
}

func DecodeCollectionToggle(decoder *binary.Decoder) (CollectionToggle, error) {
	{
		tmp := new(collectionToggleEnumContainer)
		err := decoder.Decode(tmp)
		if err != nil {
			return nil, fmt.Errorf("failed parsing CollectionToggle: %w", err)
		}
		switch tmp.Enum {
		case 0:
			return (*CollectionToggle_None)(&tmp.Enum), nil
		case 1:
			return (*CollectionToggle_Clear)(&tmp.Enum), nil
		case 2:
			return &tmp.Set, nil
		default:
			return nil, fmt.Errorf("CollectionToggle: unknown enum index: %v", tmp.Enum)
		}
	}
}

func EncodeCollectionToggle(encoder *binary.Encoder, value CollectionToggle) error {
	{
		tmp := collectionToggleEnumContainer{}
		switch realvalue := value.(type) {
		case *CollectionToggle_None:
			tmp.Enum = 0
			tmp.None = *realvalue
		case *CollectionToggle_Clear:
			tmp.Enum = 1
			tmp.Clear = *realvalue
		case *CollectionToggle_Set:
			tmp.Enum = 2
			tmp.Set = *realvalue
		}
		return encoder.Encode(tmp)
	}
}

type CollectionToggle_None uint8

func (obj CollectionToggle_None) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *CollectionToggle_None) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (_ *CollectionToggle_None) isCollectionToggle() {}

type CollectionToggle_Clear uint8

func (obj CollectionToggle_Clear) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *CollectionToggle_Clear) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (_ *CollectionToggle_Clear) isCollectionToggle() {}

// Variant "Set" of enum "CollectionToggle"
type CollectionToggle_Set struct {
	V0 Collection `json:"v0"`
}

func (obj CollectionToggle_Set) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `V0`:
	if err = encoder.Encode(obj.V0); err != nil {
		return fmt.Errorf("error while marshaling V0:%w", err)
	}
	return nil
}

func (obj CollectionToggle_Set) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding CollectionToggle_Set: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *CollectionToggle_Set) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `V0`:
	if err = decoder.Decode(&obj.V0); err != nil {
		return fmt.Errorf("error while unmarshaling V0:%w", err)
	}
	return nil
}

func (obj *CollectionToggle_Set) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CollectionToggle_Set: %w", err)
	}
	return nil
}

func UnmarshalCollectionToggle_Set(buf []byte) (*CollectionToggle_Set, error) {
	obj := new(CollectionToggle_Set)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *CollectionToggle_Set) isCollectionToggle() {}

// The "isUsesToggle" interface for the "UsesToggle" complex enum.
type UsesToggle interface {
	isUsesToggle()
}

type usesToggleEnumContainer struct {
	Enum  binary.BorshEnum `bin:"enum"`
	None  UsesToggle_None
	Clear UsesToggle_Clear
	Set   UsesToggle_Set
}

func DecodeUsesToggle(decoder *binary.Decoder) (UsesToggle, error) {
	{
		tmp := new(usesToggleEnumContainer)
		err := decoder.Decode(tmp)
		if err != nil {
			return nil, fmt.Errorf("failed parsing UsesToggle: %w", err)
		}
		switch tmp.Enum {
		case 0:
			return (*UsesToggle_None)(&tmp.Enum), nil
		case 1:
			return (*UsesToggle_Clear)(&tmp.Enum), nil
		case 2:
			return &tmp.Set, nil
		default:
			return nil, fmt.Errorf("UsesToggle: unknown enum index: %v", tmp.Enum)
		}
	}
}

func EncodeUsesToggle(encoder *binary.Encoder, value UsesToggle) error {
	{
		tmp := usesToggleEnumContainer{}
		switch realvalue := value.(type) {
		case *UsesToggle_None:
			tmp.Enum = 0
			tmp.None = *realvalue
		case *UsesToggle_Clear:
			tmp.Enum = 1
			tmp.Clear = *realvalue
		case *UsesToggle_Set:
			tmp.Enum = 2
			tmp.Set = *realvalue
		}
		return encoder.Encode(tmp)
	}
}

type UsesToggle_None uint8

func (obj UsesToggle_None) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *UsesToggle_None) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (_ *UsesToggle_None) isUsesToggle() {}

type UsesToggle_Clear uint8

func (obj UsesToggle_Clear) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *UsesToggle_Clear) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (_ *UsesToggle_Clear) isUsesToggle() {}

// Variant "Set" of enum "UsesToggle"
type UsesToggle_Set struct {
	V0 Uses `json:"v0"`
}

func (obj UsesToggle_Set) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `V0`:
	if err = encoder.Encode(obj.V0); err != nil {
		return fmt.Errorf("error while marshaling V0:%w", err)
	}
	return nil
}

func (obj UsesToggle_Set) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding UsesToggle_Set: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *UsesToggle_Set) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `V0`:
	if err = decoder.Decode(&obj.V0); err != nil {
		return fmt.Errorf("error while unmarshaling V0:%w", err)
	}
	return nil
}

func (obj *UsesToggle_Set) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UsesToggle_Set: %w", err)
	}
	return nil
}

func UnmarshalUsesToggle_Set(buf []byte) (*UsesToggle_Set, error) {
	obj := new(UsesToggle_Set)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *UsesToggle_Set) isUsesToggle() {}

// The "isCollectionDetailsToggle" interface for the "CollectionDetailsToggle" complex enum.
type CollectionDetailsToggle interface {
	isCollectionDetailsToggle()
}

type collectionDetailsToggleEnumContainer struct {
	Enum  binary.BorshEnum `bin:"enum"`
	None  CollectionDetailsToggle_None
	Clear CollectionDetailsToggle_Clear
	Set   CollectionDetailsToggle_Set
}

func DecodeCollectionDetailsToggle(decoder *binary.Decoder) (CollectionDetailsToggle, error) {
	{
		tmp := new(collectionDetailsToggleEnumContainer)
		err := decoder.Decode(tmp)
		if err != nil {
			return nil, fmt.Errorf("failed parsing CollectionDetailsToggle: %w", err)
		}
		switch tmp.Enum {
		case 0:
			return (*CollectionDetailsToggle_None)(&tmp.Enum), nil
		case 1:
			return (*CollectionDetailsToggle_Clear)(&tmp.Enum), nil
		case 2:
			return &tmp.Set, nil
		default:
			return nil, fmt.Errorf("CollectionDetailsToggle: unknown enum index: %v", tmp.Enum)
		}
	}
}

func EncodeCollectionDetailsToggle(encoder *binary.Encoder, value CollectionDetailsToggle) error {
	{
		tmp := collectionDetailsToggleEnumContainer{}
		switch realvalue := value.(type) {
		case *CollectionDetailsToggle_None:
			tmp.Enum = 0
			tmp.None = *realvalue
		case *CollectionDetailsToggle_Clear:
			tmp.Enum = 1
			tmp.Clear = *realvalue
		case *CollectionDetailsToggle_Set:
			tmp.Enum = 2
			tmp.Set = *realvalue
		}
		return encoder.Encode(tmp)
	}
}

type CollectionDetailsToggle_None uint8

func (obj CollectionDetailsToggle_None) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *CollectionDetailsToggle_None) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (_ *CollectionDetailsToggle_None) isCollectionDetailsToggle() {}

type CollectionDetailsToggle_Clear uint8

func (obj CollectionDetailsToggle_Clear) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *CollectionDetailsToggle_Clear) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (_ *CollectionDetailsToggle_Clear) isCollectionDetailsToggle() {}

// Variant "Set" of enum "CollectionDetailsToggle"
type CollectionDetailsToggle_Set struct {
	V0 CollectionDetails `json:"v0"`
}

func (obj CollectionDetailsToggle_Set) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `V0`:
	{
		if err = EncodeCollectionDetails(encoder, obj.V0); err != nil {
			return fmt.Errorf("error while marshalingV0:%w", err)
		}
	}
	return nil
}

func (obj CollectionDetailsToggle_Set) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding CollectionDetailsToggle_Set: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *CollectionDetailsToggle_Set) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `V0`:
	{
		var err error
		obj.V0, err = DecodeCollectionDetails(decoder)
		if err != nil {
			return err
		}
	}
	return nil
}

func (obj *CollectionDetailsToggle_Set) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CollectionDetailsToggle_Set: %w", err)
	}
	return nil
}

func UnmarshalCollectionDetailsToggle_Set(buf []byte) (*CollectionDetailsToggle_Set, error) {
	obj := new(CollectionDetailsToggle_Set)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *CollectionDetailsToggle_Set) isCollectionDetailsToggle() {}

// The "isRuleSetToggle" interface for the "RuleSetToggle" complex enum.
type RuleSetToggle interface {
	isRuleSetToggle()
}

type ruleSetToggleEnumContainer struct {
	Enum  binary.BorshEnum `bin:"enum"`
	None  RuleSetToggle_None
	Clear RuleSetToggle_Clear
	Set   RuleSetToggle_Set
}

func DecodeRuleSetToggle(decoder *binary.Decoder) (RuleSetToggle, error) {
	{
		tmp := new(ruleSetToggleEnumContainer)
		err := decoder.Decode(tmp)
		if err != nil {
			return nil, fmt.Errorf("failed parsing RuleSetToggle: %w", err)
		}
		switch tmp.Enum {
		case 0:
			return (*RuleSetToggle_None)(&tmp.Enum), nil
		case 1:
			return (*RuleSetToggle_Clear)(&tmp.Enum), nil
		case 2:
			return &tmp.Set, nil
		default:
			return nil, fmt.Errorf("RuleSetToggle: unknown enum index: %v", tmp.Enum)
		}
	}
}

func EncodeRuleSetToggle(encoder *binary.Encoder, value RuleSetToggle) error {
	{
		tmp := ruleSetToggleEnumContainer{}
		switch realvalue := value.(type) {
		case *RuleSetToggle_None:
			tmp.Enum = 0
			tmp.None = *realvalue
		case *RuleSetToggle_Clear:
			tmp.Enum = 1
			tmp.Clear = *realvalue
		case *RuleSetToggle_Set:
			tmp.Enum = 2
			tmp.Set = *realvalue
		}
		return encoder.Encode(tmp)
	}
}

type RuleSetToggle_None uint8

func (obj RuleSetToggle_None) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *RuleSetToggle_None) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (_ *RuleSetToggle_None) isRuleSetToggle() {}

type RuleSetToggle_Clear uint8

func (obj RuleSetToggle_Clear) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *RuleSetToggle_Clear) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (_ *RuleSetToggle_Clear) isRuleSetToggle() {}

// Variant "Set" of enum "RuleSetToggle"
type RuleSetToggle_Set struct {
	V0 solanago.PublicKey `json:"v0"`
}

func (obj RuleSetToggle_Set) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `V0`:
	if err = encoder.Encode(obj.V0); err != nil {
		return fmt.Errorf("error while marshaling V0:%w", err)
	}
	return nil
}

func (obj RuleSetToggle_Set) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding RuleSetToggle_Set: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *RuleSetToggle_Set) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `V0`:
	if err = decoder.Decode(&obj.V0); err != nil {
		return fmt.Errorf("error while unmarshaling V0:%w", err)
	}
	return nil
}

func (obj *RuleSetToggle_Set) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling RuleSetToggle_Set: %w", err)
	}
	return nil
}

func UnmarshalRuleSetToggle_Set(buf []byte) (*RuleSetToggle_Set, error) {
	obj := new(RuleSetToggle_Set)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *RuleSetToggle_Set) isRuleSetToggle() {}

// The "isPrintArgs" interface for the "PrintArgs" complex enum.
type PrintArgs interface {
	isPrintArgs()
}

type printArgsEnumContainer struct {
	Enum binary.BorshEnum `bin:"enum"`
	V1   PrintArgs_V1
	V2   PrintArgs_V2
}

func DecodePrintArgs(decoder *binary.Decoder) (PrintArgs, error) {
	{
		tmp := new(printArgsEnumContainer)
		err := decoder.Decode(tmp)
		if err != nil {
			return nil, fmt.Errorf("failed parsing PrintArgs: %w", err)
		}
		switch tmp.Enum {
		case 0:
			return &tmp.V1, nil
		case 1:
			return &tmp.V2, nil
		default:
			return nil, fmt.Errorf("PrintArgs: unknown enum index: %v", tmp.Enum)
		}
	}
}

func EncodePrintArgs(encoder *binary.Encoder, value PrintArgs) error {
	{
		tmp := printArgsEnumContainer{}
		switch realvalue := value.(type) {
		case *PrintArgs_V1:
			tmp.Enum = 0
			tmp.V1 = *realvalue
		case *PrintArgs_V2:
			tmp.Enum = 1
			tmp.V2 = *realvalue
		}
		return encoder.Encode(tmp)
	}
}

// Variant "V1" of enum "PrintArgs"
type PrintArgs_V1 struct {
	Edition uint64 `json:"edition"`
}

func (obj PrintArgs_V1) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Edition`:
	if err = encoder.Encode(obj.Edition); err != nil {
		return fmt.Errorf("error while marshaling Edition:%w", err)
	}
	return nil
}

func (obj PrintArgs_V1) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding PrintArgs_V1: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *PrintArgs_V1) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Edition`:
	if err = decoder.Decode(&obj.Edition); err != nil {
		return fmt.Errorf("error while unmarshaling Edition:%w", err)
	}
	return nil
}

func (obj *PrintArgs_V1) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling PrintArgs_V1: %w", err)
	}
	return nil
}

func UnmarshalPrintArgs_V1(buf []byte) (*PrintArgs_V1, error) {
	obj := new(PrintArgs_V1)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *PrintArgs_V1) isPrintArgs() {}

// Variant "V2" of enum "PrintArgs"
type PrintArgs_V2 struct {
	Edition uint64 `json:"edition"`
}

func (obj PrintArgs_V2) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Edition`:
	if err = encoder.Encode(obj.Edition); err != nil {
		return fmt.Errorf("error while marshaling Edition:%w", err)
	}
	return nil
}

func (obj PrintArgs_V2) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding PrintArgs_V2: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *PrintArgs_V2) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Edition`:
	if err = decoder.Decode(&obj.Edition); err != nil {
		return fmt.Errorf("error while unmarshaling Edition:%w", err)
	}
	return nil
}

func (obj *PrintArgs_V2) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling PrintArgs_V2: %w", err)
	}
	return nil
}

func UnmarshalPrintArgs_V2(buf []byte) (*PrintArgs_V2, error) {
	obj := new(PrintArgs_V2)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *PrintArgs_V2) isPrintArgs() {}

// The "isLockArgs" interface for the "LockArgs" complex enum.
type LockArgs interface {
	isLockArgs()
}

type lockArgsEnumContainer struct {
	Enum binary.BorshEnum `bin:"enum"`
	V1   LockArgs_V1
}

func DecodeLockArgs(decoder *binary.Decoder) (LockArgs, error) {
	{
		tmp := new(lockArgsEnumContainer)
		err := decoder.Decode(tmp)
		if err != nil {
			return nil, fmt.Errorf("failed parsing LockArgs: %w", err)
		}
		switch tmp.Enum {
		case 0:
			return &tmp.V1, nil
		default:
			return nil, fmt.Errorf("LockArgs: unknown enum index: %v", tmp.Enum)
		}
	}
}

func EncodeLockArgs(encoder *binary.Encoder, value LockArgs) error {
	{
		tmp := lockArgsEnumContainer{}
		switch realvalue := value.(type) {
		case *LockArgs_V1:
			tmp.Enum = 0
			tmp.V1 = *realvalue
		}
		return encoder.Encode(tmp)
	}
}

// Variant "V1" of enum "LockArgs"
type LockArgs_V1 struct {
	AuthorizationData *AuthorizationData `bin:"optional" json:"authorizationData,omitempty"`
}

func (obj LockArgs_V1) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `AuthorizationData` (optional):
	{
		if obj.AuthorizationData == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
			if err = encoder.Encode(obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData: %w", err)
			}
		}
	}
	return nil
}

func (obj LockArgs_V1) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding LockArgs_V1: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *LockArgs_V1) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `AuthorizationData` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
			}
		}
	}
	return nil
}

func (obj *LockArgs_V1) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling LockArgs_V1: %w", err)
	}
	return nil
}

func UnmarshalLockArgs_V1(buf []byte) (*LockArgs_V1, error) {
	obj := new(LockArgs_V1)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *LockArgs_V1) isLockArgs() {}

// The "isUnlockArgs" interface for the "UnlockArgs" complex enum.
type UnlockArgs interface {
	isUnlockArgs()
}

type unlockArgsEnumContainer struct {
	Enum binary.BorshEnum `bin:"enum"`
	V1   UnlockArgs_V1
}

func DecodeUnlockArgs(decoder *binary.Decoder) (UnlockArgs, error) {
	{
		tmp := new(unlockArgsEnumContainer)
		err := decoder.Decode(tmp)
		if err != nil {
			return nil, fmt.Errorf("failed parsing UnlockArgs: %w", err)
		}
		switch tmp.Enum {
		case 0:
			return &tmp.V1, nil
		default:
			return nil, fmt.Errorf("UnlockArgs: unknown enum index: %v", tmp.Enum)
		}
	}
}

func EncodeUnlockArgs(encoder *binary.Encoder, value UnlockArgs) error {
	{
		tmp := unlockArgsEnumContainer{}
		switch realvalue := value.(type) {
		case *UnlockArgs_V1:
			tmp.Enum = 0
			tmp.V1 = *realvalue
		}
		return encoder.Encode(tmp)
	}
}

// Variant "V1" of enum "UnlockArgs"
type UnlockArgs_V1 struct {
	AuthorizationData *AuthorizationData `bin:"optional" json:"authorizationData,omitempty"`
}

func (obj UnlockArgs_V1) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `AuthorizationData` (optional):
	{
		if obj.AuthorizationData == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
			if err = encoder.Encode(obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData: %w", err)
			}
		}
	}
	return nil
}

func (obj UnlockArgs_V1) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding UnlockArgs_V1: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *UnlockArgs_V1) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `AuthorizationData` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
			}
		}
	}
	return nil
}

func (obj *UnlockArgs_V1) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UnlockArgs_V1: %w", err)
	}
	return nil
}

func UnmarshalUnlockArgs_V1(buf []byte) (*UnlockArgs_V1, error) {
	obj := new(UnlockArgs_V1)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *UnlockArgs_V1) isUnlockArgs() {}

// The "isUseArgs" interface for the "UseArgs" complex enum.
type UseArgs interface {
	isUseArgs()
}

type useArgsEnumContainer struct {
	Enum binary.BorshEnum `bin:"enum"`
	V1   UseArgs_V1
}

func DecodeUseArgs(decoder *binary.Decoder) (UseArgs, error) {
	{
		tmp := new(useArgsEnumContainer)
		err := decoder.Decode(tmp)
		if err != nil {
			return nil, fmt.Errorf("failed parsing UseArgs: %w", err)
		}
		switch tmp.Enum {
		case 0:
			return &tmp.V1, nil
		default:
			return nil, fmt.Errorf("UseArgs: unknown enum index: %v", tmp.Enum)
		}
	}
}

func EncodeUseArgs(encoder *binary.Encoder, value UseArgs) error {
	{
		tmp := useArgsEnumContainer{}
		switch realvalue := value.(type) {
		case *UseArgs_V1:
			tmp.Enum = 0
			tmp.V1 = *realvalue
		}
		return encoder.Encode(tmp)
	}
}

// Variant "V1" of enum "UseArgs"
type UseArgs_V1 struct {
	AuthorizationData *AuthorizationData `bin:"optional" json:"authorizationData,omitempty"`
}

func (obj UseArgs_V1) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `AuthorizationData` (optional):
	{
		if obj.AuthorizationData == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData optionality: %w", err)
			}
			if err = encoder.Encode(obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while marshaling AuthorizationData: %w", err)
			}
		}
	}
	return nil
}

func (obj UseArgs_V1) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding UseArgs_V1: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *UseArgs_V1) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `AuthorizationData` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.AuthorizationData); err != nil {
				return fmt.Errorf("error while unmarshaling AuthorizationData:%w", err)
			}
		}
	}
	return nil
}

func (obj *UseArgs_V1) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UseArgs_V1: %w", err)
	}
	return nil
}

func UnmarshalUseArgs_V1(buf []byte) (*UseArgs_V1, error) {
	obj := new(UseArgs_V1)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *UseArgs_V1) isUseArgs() {}

type VerificationArgs binary.BorshEnum

const (
	VerificationArgs_CreatorV1 VerificationArgs = iota
	VerificationArgs_CollectionV1
)

func (value VerificationArgs) String() string {
	switch value {
	case VerificationArgs_CreatorV1:
		return "CreatorV1"
	case VerificationArgs_CollectionV1:
		return "CollectionV1"
	default:
		return ""
	}
}

type TokenStandard binary.BorshEnum

const (
	TokenStandard_NonFungible TokenStandard = iota
	TokenStandard_FungibleAsset
	TokenStandard_Fungible
	TokenStandard_NonFungibleEdition
	TokenStandard_ProgrammableNonFungible
	TokenStandard_ProgrammableNonFungibleEdition
)

func (value TokenStandard) String() string {
	switch value {
	case TokenStandard_NonFungible:
		return "NonFungible"
	case TokenStandard_FungibleAsset:
		return "FungibleAsset"
	case TokenStandard_Fungible:
		return "Fungible"
	case TokenStandard_NonFungibleEdition:
		return "NonFungibleEdition"
	case TokenStandard_ProgrammableNonFungible:
		return "ProgrammableNonFungible"
	case TokenStandard_ProgrammableNonFungibleEdition:
		return "ProgrammableNonFungibleEdition"
	default:
		return ""
	}
}

type Key binary.BorshEnum

const (
	Key_Uninitialized Key = iota
	Key_EditionV1
	Key_MasterEditionV1
	Key_ReservationListV1
	Key_MetadataV1
	Key_ReservationListV2
	Key_MasterEditionV2
	Key_EditionMarker
	Key_UseAuthorityRecord
	Key_CollectionAuthorityRecord
	Key_TokenOwnedEscrow
	Key_TokenRecord
	Key_MetadataDelegate
	Key_EditionMarkerV2
	Key_HolderDelegate
)

func (value Key) String() string {
	switch value {
	case Key_Uninitialized:
		return "Uninitialized"
	case Key_EditionV1:
		return "EditionV1"
	case Key_MasterEditionV1:
		return "MasterEditionV1"
	case Key_ReservationListV1:
		return "ReservationListV1"
	case Key_MetadataV1:
		return "MetadataV1"
	case Key_ReservationListV2:
		return "ReservationListV2"
	case Key_MasterEditionV2:
		return "MasterEditionV2"
	case Key_EditionMarker:
		return "EditionMarker"
	case Key_UseAuthorityRecord:
		return "UseAuthorityRecord"
	case Key_CollectionAuthorityRecord:
		return "CollectionAuthorityRecord"
	case Key_TokenOwnedEscrow:
		return "TokenOwnedEscrow"
	case Key_TokenRecord:
		return "TokenRecord"
	case Key_MetadataDelegate:
		return "MetadataDelegate"
	case Key_EditionMarkerV2:
		return "EditionMarkerV2"
	case Key_HolderDelegate:
		return "HolderDelegate"
	default:
		return ""
	}
}

// The "isCollectionDetails" interface for the "CollectionDetails" complex enum.
type CollectionDetails interface {
	isCollectionDetails()
}

type collectionDetailsEnumContainer struct {
	Enum binary.BorshEnum `bin:"enum"`
	V1   CollectionDetails_V1
	V2   CollectionDetails_V2
}

func DecodeCollectionDetails(decoder *binary.Decoder) (CollectionDetails, error) {
	{
		tmp := new(collectionDetailsEnumContainer)
		err := decoder.Decode(tmp)
		if err != nil {
			return nil, fmt.Errorf("failed parsing CollectionDetails: %w", err)
		}
		switch tmp.Enum {
		case 0:
			return &tmp.V1, nil
		case 1:
			return &tmp.V2, nil
		default:
			return nil, fmt.Errorf("CollectionDetails: unknown enum index: %v", tmp.Enum)
		}
	}
}

func EncodeCollectionDetails(encoder *binary.Encoder, value CollectionDetails) error {
	{
		tmp := collectionDetailsEnumContainer{}
		switch realvalue := value.(type) {
		case *CollectionDetails_V1:
			tmp.Enum = 0
			tmp.V1 = *realvalue
		case *CollectionDetails_V2:
			tmp.Enum = 1
			tmp.V2 = *realvalue
		}
		return encoder.Encode(tmp)
	}
}

// Variant "V1" of enum "CollectionDetails"
type CollectionDetails_V1 struct {
	Size uint64 `json:"size"`
}

func (obj CollectionDetails_V1) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Size`:
	if err = encoder.Encode(obj.Size); err != nil {
		return fmt.Errorf("error while marshaling Size:%w", err)
	}
	return nil
}

func (obj CollectionDetails_V1) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding CollectionDetails_V1: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *CollectionDetails_V1) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Size`:
	if err = decoder.Decode(&obj.Size); err != nil {
		return fmt.Errorf("error while unmarshaling Size:%w", err)
	}
	return nil
}

func (obj *CollectionDetails_V1) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CollectionDetails_V1: %w", err)
	}
	return nil
}

func UnmarshalCollectionDetails_V1(buf []byte) (*CollectionDetails_V1, error) {
	obj := new(CollectionDetails_V1)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *CollectionDetails_V1) isCollectionDetails() {}

// Variant "V2" of enum "CollectionDetails"
type CollectionDetails_V2 struct {
	Padding [8]uint8 `json:"padding"`
}

func (obj CollectionDetails_V2) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Padding`:
	if err = encoder.Encode(obj.Padding); err != nil {
		return fmt.Errorf("error while marshaling Padding:%w", err)
	}
	return nil
}

func (obj CollectionDetails_V2) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding CollectionDetails_V2: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *CollectionDetails_V2) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Padding`:
	if err = decoder.Decode(&obj.Padding); err != nil {
		return fmt.Errorf("error while unmarshaling Padding:%w", err)
	}
	return nil
}

func (obj *CollectionDetails_V2) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CollectionDetails_V2: %w", err)
	}
	return nil
}

func UnmarshalCollectionDetails_V2(buf []byte) (*CollectionDetails_V2, error) {
	obj := new(CollectionDetails_V2)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *CollectionDetails_V2) isCollectionDetails() {}

// The "isEscrowAuthority" interface for the "EscrowAuthority" complex enum.
type EscrowAuthority interface {
	isEscrowAuthority()
}

type escrowAuthorityEnumContainer struct {
	Enum       binary.BorshEnum `bin:"enum"`
	TokenOwner EscrowAuthority_TokenOwner
	Creator    EscrowAuthority_Creator
}

func DecodeEscrowAuthority(decoder *binary.Decoder) (EscrowAuthority, error) {
	{
		tmp := new(escrowAuthorityEnumContainer)
		err := decoder.Decode(tmp)
		if err != nil {
			return nil, fmt.Errorf("failed parsing EscrowAuthority: %w", err)
		}
		switch tmp.Enum {
		case 0:
			return (*EscrowAuthority_TokenOwner)(&tmp.Enum), nil
		case 1:
			return &tmp.Creator, nil
		default:
			return nil, fmt.Errorf("EscrowAuthority: unknown enum index: %v", tmp.Enum)
		}
	}
}

func EncodeEscrowAuthority(encoder *binary.Encoder, value EscrowAuthority) error {
	{
		tmp := escrowAuthorityEnumContainer{}
		switch realvalue := value.(type) {
		case *EscrowAuthority_TokenOwner:
			tmp.Enum = 0
			tmp.TokenOwner = *realvalue
		case *EscrowAuthority_Creator:
			tmp.Enum = 1
			tmp.Creator = *realvalue
		}
		return encoder.Encode(tmp)
	}
}

type EscrowAuthority_TokenOwner uint8

func (obj EscrowAuthority_TokenOwner) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *EscrowAuthority_TokenOwner) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (_ *EscrowAuthority_TokenOwner) isEscrowAuthority() {}

// Variant "Creator" of enum "EscrowAuthority"
type EscrowAuthority_Creator struct {
	V0 solanago.PublicKey `json:"v0"`
}

func (obj EscrowAuthority_Creator) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `V0`:
	if err = encoder.Encode(obj.V0); err != nil {
		return fmt.Errorf("error while marshaling V0:%w", err)
	}
	return nil
}

func (obj EscrowAuthority_Creator) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding EscrowAuthority_Creator: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *EscrowAuthority_Creator) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `V0`:
	if err = decoder.Decode(&obj.V0); err != nil {
		return fmt.Errorf("error while unmarshaling V0:%w", err)
	}
	return nil
}

func (obj *EscrowAuthority_Creator) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling EscrowAuthority_Creator: %w", err)
	}
	return nil
}

func UnmarshalEscrowAuthority_Creator(buf []byte) (*EscrowAuthority_Creator, error) {
	obj := new(EscrowAuthority_Creator)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *EscrowAuthority_Creator) isEscrowAuthority() {}

// The "isPrintSupply" interface for the "PrintSupply" complex enum.
type PrintSupply interface {
	isPrintSupply()
}

type printSupplyEnumContainer struct {
	Enum      binary.BorshEnum `bin:"enum"`
	Zero      PrintSupply_Zero
	Limited   PrintSupply_Limited
	Unlimited PrintSupply_Unlimited
}

func DecodePrintSupply(decoder *binary.Decoder) (PrintSupply, error) {
	{
		tmp := new(printSupplyEnumContainer)
		err := decoder.Decode(tmp)
		if err != nil {
			return nil, fmt.Errorf("failed parsing PrintSupply: %w", err)
		}
		switch tmp.Enum {
		case 0:
			return (*PrintSupply_Zero)(&tmp.Enum), nil
		case 1:
			return &tmp.Limited, nil
		case 2:
			return (*PrintSupply_Unlimited)(&tmp.Enum), nil
		default:
			return nil, fmt.Errorf("PrintSupply: unknown enum index: %v", tmp.Enum)
		}
	}
}

func EncodePrintSupply(encoder *binary.Encoder, value PrintSupply) error {
	{
		tmp := printSupplyEnumContainer{}
		switch realvalue := value.(type) {
		case *PrintSupply_Zero:
			tmp.Enum = 0
			tmp.Zero = *realvalue
		case *PrintSupply_Limited:
			tmp.Enum = 1
			tmp.Limited = *realvalue
		case *PrintSupply_Unlimited:
			tmp.Enum = 2
			tmp.Unlimited = *realvalue
		}
		return encoder.Encode(tmp)
	}
}

type PrintSupply_Zero uint8

func (obj PrintSupply_Zero) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *PrintSupply_Zero) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (_ *PrintSupply_Zero) isPrintSupply() {}

// Variant "Limited" of enum "PrintSupply"
type PrintSupply_Limited struct {
	V0 uint64 `json:"v0"`
}

func (obj PrintSupply_Limited) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `V0`:
	if err = encoder.Encode(obj.V0); err != nil {
		return fmt.Errorf("error while marshaling V0:%w", err)
	}
	return nil
}

func (obj PrintSupply_Limited) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding PrintSupply_Limited: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *PrintSupply_Limited) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `V0`:
	if err = decoder.Decode(&obj.V0); err != nil {
		return fmt.Errorf("error while unmarshaling V0:%w", err)
	}
	return nil
}

func (obj *PrintSupply_Limited) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling PrintSupply_Limited: %w", err)
	}
	return nil
}

func UnmarshalPrintSupply_Limited(buf []byte) (*PrintSupply_Limited, error) {
	obj := new(PrintSupply_Limited)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *PrintSupply_Limited) isPrintSupply() {}

type PrintSupply_Unlimited uint8

func (obj PrintSupply_Unlimited) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *PrintSupply_Unlimited) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (_ *PrintSupply_Unlimited) isPrintSupply() {}

// The "isProgrammableConfig" interface for the "ProgrammableConfig" complex enum.
type ProgrammableConfig interface {
	isProgrammableConfig()
}

type programmableConfigEnumContainer struct {
	Enum binary.BorshEnum `bin:"enum"`
	V1   ProgrammableConfig_V1
}

func DecodeProgrammableConfig(decoder *binary.Decoder) (ProgrammableConfig, error) {
	{
		tmp := new(programmableConfigEnumContainer)
		err := decoder.Decode(tmp)
		if err != nil {
			return nil, fmt.Errorf("failed parsing ProgrammableConfig: %w", err)
		}
		switch tmp.Enum {
		case 0:
			return &tmp.V1, nil
		default:
			return nil, fmt.Errorf("ProgrammableConfig: unknown enum index: %v", tmp.Enum)
		}
	}
}

func EncodeProgrammableConfig(encoder *binary.Encoder, value ProgrammableConfig) error {
	{
		tmp := programmableConfigEnumContainer{}
		switch realvalue := value.(type) {
		case *ProgrammableConfig_V1:
			tmp.Enum = 0
			tmp.V1 = *realvalue
		}
		return encoder.Encode(tmp)
	}
}

// Variant "V1" of enum "ProgrammableConfig"
type ProgrammableConfig_V1 struct {
	RuleSet *solanago.PublicKey `bin:"optional" json:"ruleSet,omitempty"`
}

func (obj ProgrammableConfig_V1) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `RuleSet` (optional):
	{
		if obj.RuleSet == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling RuleSet optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling RuleSet optionality: %w", err)
			}
			if err = encoder.Encode(obj.RuleSet); err != nil {
				return fmt.Errorf("error while marshaling RuleSet: %w", err)
			}
		}
	}
	return nil
}

func (obj ProgrammableConfig_V1) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding ProgrammableConfig_V1: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *ProgrammableConfig_V1) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `RuleSet` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling RuleSet:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.RuleSet); err != nil {
				return fmt.Errorf("error while unmarshaling RuleSet:%w", err)
			}
		}
	}
	return nil
}

func (obj *ProgrammableConfig_V1) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ProgrammableConfig_V1: %w", err)
	}
	return nil
}

func UnmarshalProgrammableConfig_V1(buf []byte) (*ProgrammableConfig_V1, error) {
	obj := new(ProgrammableConfig_V1)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *ProgrammableConfig_V1) isProgrammableConfig() {}

type MigrationType binary.BorshEnum

const (
	MigrationType_CollectionV1 MigrationType = iota
	MigrationType_ProgrammableV1
)

func (value MigrationType) String() string {
	switch value {
	case MigrationType_CollectionV1:
		return "CollectionV1"
	case MigrationType_ProgrammableV1:
		return "ProgrammableV1"
	default:
		return ""
	}
}

type TokenState binary.BorshEnum

const (
	TokenState_Unlocked TokenState = iota
	TokenState_Locked
	TokenState_Listed
)

func (value TokenState) String() string {
	switch value {
	case TokenState_Unlocked:
		return "Unlocked"
	case TokenState_Locked:
		return "Locked"
	case TokenState_Listed:
		return "Listed"
	default:
		return ""
	}
}

type TokenDelegateRole binary.BorshEnum

const (
	TokenDelegateRole_Sale TokenDelegateRole = iota
	TokenDelegateRole_Transfer
	TokenDelegateRole_Utility
	TokenDelegateRole_Staking
	TokenDelegateRole_Standard
	TokenDelegateRole_LockedTransfer
	TokenDelegateRole_Migration
)

func (value TokenDelegateRole) String() string {
	switch value {
	case TokenDelegateRole_Sale:
		return "Sale"
	case TokenDelegateRole_Transfer:
		return "Transfer"
	case TokenDelegateRole_Utility:
		return "Utility"
	case TokenDelegateRole_Staking:
		return "Staking"
	case TokenDelegateRole_Standard:
		return "Standard"
	case TokenDelegateRole_LockedTransfer:
		return "LockedTransfer"
	case TokenDelegateRole_Migration:
		return "Migration"
	default:
		return ""
	}
}

type AuthorityType binary.BorshEnum

const (
	AuthorityType_None AuthorityType = iota
	AuthorityType_Metadata
	AuthorityType_Holder
	AuthorityType_MetadataDelegate
	AuthorityType_TokenDelegate
)

func (value AuthorityType) String() string {
	switch value {
	case AuthorityType_None:
		return "None"
	case AuthorityType_Metadata:
		return "Metadata"
	case AuthorityType_Holder:
		return "Holder"
	case AuthorityType_MetadataDelegate:
		return "MetadataDelegate"
	case AuthorityType_TokenDelegate:
		return "TokenDelegate"
	default:
		return ""
	}
}

type PayloadKey binary.BorshEnum

const (
	PayloadKey_Amount PayloadKey = iota
	PayloadKey_Authority
	PayloadKey_AuthoritySeeds
	PayloadKey_Delegate
	PayloadKey_DelegateSeeds
	PayloadKey_Destination
	PayloadKey_DestinationSeeds
	PayloadKey_Holder
	PayloadKey_Source
	PayloadKey_SourceSeeds
)

func (value PayloadKey) String() string {
	switch value {
	case PayloadKey_Amount:
		return "Amount"
	case PayloadKey_Authority:
		return "Authority"
	case PayloadKey_AuthoritySeeds:
		return "AuthoritySeeds"
	case PayloadKey_Delegate:
		return "Delegate"
	case PayloadKey_DelegateSeeds:
		return "DelegateSeeds"
	case PayloadKey_Destination:
		return "Destination"
	case PayloadKey_DestinationSeeds:
		return "DestinationSeeds"
	case PayloadKey_Holder:
		return "Holder"
	case PayloadKey_Source:
		return "Source"
	case PayloadKey_SourceSeeds:
		return "SourceSeeds"
	default:
		return ""
	}
}

// The "isPayloadType" interface for the "PayloadType" complex enum.
type PayloadType interface {
	isPayloadType()
}

type payloadTypeEnumContainer struct {
	Enum        binary.BorshEnum `bin:"enum"`
	Pubkey      PayloadType_Pubkey
	Seeds       PayloadType_Seeds
	MerkleProof PayloadType_MerkleProof
	Number      PayloadType_Number
}

func DecodePayloadType(decoder *binary.Decoder) (PayloadType, error) {
	{
		tmp := new(payloadTypeEnumContainer)
		err := decoder.Decode(tmp)
		if err != nil {
			return nil, fmt.Errorf("failed parsing PayloadType: %w", err)
		}
		switch tmp.Enum {
		case 0:
			return &tmp.Pubkey, nil
		case 1:
			return &tmp.Seeds, nil
		case 2:
			return &tmp.MerkleProof, nil
		case 3:
			return &tmp.Number, nil
		default:
			return nil, fmt.Errorf("PayloadType: unknown enum index: %v", tmp.Enum)
		}
	}
}

func EncodePayloadType(encoder *binary.Encoder, value PayloadType) error {
	{
		tmp := payloadTypeEnumContainer{}
		switch realvalue := value.(type) {
		case *PayloadType_Pubkey:
			tmp.Enum = 0
			tmp.Pubkey = *realvalue
		case *PayloadType_Seeds:
			tmp.Enum = 1
			tmp.Seeds = *realvalue
		case *PayloadType_MerkleProof:
			tmp.Enum = 2
			tmp.MerkleProof = *realvalue
		case *PayloadType_Number:
			tmp.Enum = 3
			tmp.Number = *realvalue
		}
		return encoder.Encode(tmp)
	}
}

// Variant "Pubkey" of enum "PayloadType"
type PayloadType_Pubkey struct {
	V0 solanago.PublicKey `json:"v0"`
}

func (obj PayloadType_Pubkey) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `V0`:
	if err = encoder.Encode(obj.V0); err != nil {
		return fmt.Errorf("error while marshaling V0:%w", err)
	}
	return nil
}

func (obj PayloadType_Pubkey) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding PayloadType_Pubkey: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *PayloadType_Pubkey) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `V0`:
	if err = decoder.Decode(&obj.V0); err != nil {
		return fmt.Errorf("error while unmarshaling V0:%w", err)
	}
	return nil
}

func (obj *PayloadType_Pubkey) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling PayloadType_Pubkey: %w", err)
	}
	return nil
}

func UnmarshalPayloadType_Pubkey(buf []byte) (*PayloadType_Pubkey, error) {
	obj := new(PayloadType_Pubkey)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *PayloadType_Pubkey) isPayloadType() {}

// Variant "Seeds" of enum "PayloadType"
type PayloadType_Seeds struct {
	V0 SeedsVec `json:"v0"`
}

func (obj PayloadType_Seeds) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `V0`:
	if err = encoder.Encode(obj.V0); err != nil {
		return fmt.Errorf("error while marshaling V0:%w", err)
	}
	return nil
}

func (obj PayloadType_Seeds) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding PayloadType_Seeds: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *PayloadType_Seeds) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `V0`:
	if err = decoder.Decode(&obj.V0); err != nil {
		return fmt.Errorf("error while unmarshaling V0:%w", err)
	}
	return nil
}

func (obj *PayloadType_Seeds) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling PayloadType_Seeds: %w", err)
	}
	return nil
}

func UnmarshalPayloadType_Seeds(buf []byte) (*PayloadType_Seeds, error) {
	obj := new(PayloadType_Seeds)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *PayloadType_Seeds) isPayloadType() {}

// Variant "MerkleProof" of enum "PayloadType"
type PayloadType_MerkleProof struct {
	V0 ProofInfo `json:"v0"`
}

func (obj PayloadType_MerkleProof) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `V0`:
	if err = encoder.Encode(obj.V0); err != nil {
		return fmt.Errorf("error while marshaling V0:%w", err)
	}
	return nil
}

func (obj PayloadType_MerkleProof) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding PayloadType_MerkleProof: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *PayloadType_MerkleProof) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `V0`:
	if err = decoder.Decode(&obj.V0); err != nil {
		return fmt.Errorf("error while unmarshaling V0:%w", err)
	}
	return nil
}

func (obj *PayloadType_MerkleProof) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling PayloadType_MerkleProof: %w", err)
	}
	return nil
}

func UnmarshalPayloadType_MerkleProof(buf []byte) (*PayloadType_MerkleProof, error) {
	obj := new(PayloadType_MerkleProof)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *PayloadType_MerkleProof) isPayloadType() {}

// Variant "Number" of enum "PayloadType"
type PayloadType_Number struct {
	V0 uint64 `json:"v0"`
}

func (obj PayloadType_Number) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `V0`:
	if err = encoder.Encode(obj.V0); err != nil {
		return fmt.Errorf("error while marshaling V0:%w", err)
	}
	return nil
}

func (obj PayloadType_Number) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding PayloadType_Number: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *PayloadType_Number) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `V0`:
	if err = decoder.Decode(&obj.V0); err != nil {
		return fmt.Errorf("error while unmarshaling V0:%w", err)
	}
	return nil
}

func (obj *PayloadType_Number) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling PayloadType_Number: %w", err)
	}
	return nil
}

func UnmarshalPayloadType_Number(buf []byte) (*PayloadType_Number, error) {
	obj := new(PayloadType_Number)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *PayloadType_Number) isPayloadType() {}

type UseMethod binary.BorshEnum

const (
	UseMethod_Burn UseMethod = iota
	UseMethod_Multiple
	UseMethod_Single
)

func (value UseMethod) String() string {
	switch value {
	case UseMethod_Burn:
		return "Burn"
	case UseMethod_Multiple:
		return "Multiple"
	case UseMethod_Single:
		return "Single"
	default:
		return ""
	}
}
