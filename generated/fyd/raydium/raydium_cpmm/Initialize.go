// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package raydium_cpmm

import (
	"bytes"
	"fmt"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
	programparser "github.com/yydsqu/solana-sdk/program_parser"
)

// Builds a "initialize" instruction.

// Creates a pool for the given token pair and the initial price
//
// # Arguments
//
// * `ctx`- The context of accounts
// * `init_amount_0` - the initial amount_0 to deposit
// * `init_amount_1` - the initial amount_1 to deposit
// * `open_time` - the timestamp allowed for swap
type Initialize struct {
	// Params:
	InitAmount0 uint64
	InitAmount1 uint64
	OpenTime    uint64
	// Accounts:
	// [0] = [writable,signer] creator
	Creator solanago.PublicKey `bin:"-"`
	// [1] = [] amm_config
	AmmConfig solanago.PublicKey `bin:"-"`
	// [2] = [] authority
	Authority solanago.PublicKey `bin:"-"`
	// [3] = [writable] pool_state
	PoolState solanago.PublicKey `bin:"-"`
	// [4] = [] token_0_mint
	Token0Mint solanago.PublicKey `bin:"-"`
	// [5] = [] token_1_mint
	Token1Mint solanago.PublicKey `bin:"-"`
	// [6] = [writable] lp_mint
	LpMint solanago.PublicKey `bin:"-"`
	// [7] = [writable] creator_token_0
	CreatorToken0 solanago.PublicKey `bin:"-"`
	// [8] = [writable] creator_token_1
	CreatorToken1 solanago.PublicKey `bin:"-"`
	// [9] = [writable] creator_lp_token
	CreatorLpToken solanago.PublicKey `bin:"-"`
	// [10] = [writable] token_0_vault
	Token0Vault solanago.PublicKey `bin:"-"`
	// [11] = [writable] token_1_vault
	Token1Vault solanago.PublicKey `bin:"-"`
	// [12] = [writable] create_pool_fee[DNXgeM9EiiaAbaWvwjHj9fQQLAX5ZsfHyvmYUNRAdNC8]
	CreatePoolFee solanago.PublicKey `bin:"-"`
	// [13] = [writable] observation_state
	ObservationState solanago.PublicKey `bin:"-"`
	// [14] = [] token_program[TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA]
	TokenProgram solanago.PublicKey `bin:"-"`
	// [15] = [] token_0_program
	Token0Program solanago.PublicKey `bin:"-"`
	// [16] = [] token_1_program
	Token1Program solanago.PublicKey `bin:"-"`
	// [17] = [] associated_token_program[ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL]
	AssociatedTokenProgram solanago.PublicKey `bin:"-"`
	// [18] = [] system_program
	SystemProgram solanago.PublicKey `bin:"-"`
	// [19] = [] rent[SysvarRent111111111111111111111111111111111]
	Rent solanago.PublicKey `bin:"-"`
	// PublicKeySlice
	solanago.PublicKeySlice `bin:"-"`
}

func (obj Initialize) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `initAmount0param`:
	if err = encoder.Encode(obj.InitAmount0); err != nil {
		return fmt.Errorf("error while marshaling initAmount0param:%w", err)
	}
	// Serialize `initAmount1param`:
	if err = encoder.Encode(obj.InitAmount1); err != nil {
		return fmt.Errorf("error while marshaling initAmount1param:%w", err)
	}
	// Serialize `openTimeParam`:
	if err = encoder.Encode(obj.OpenTime); err != nil {
		return fmt.Errorf("error while marshaling openTimeParam:%w", err)
	}
	return nil
}

func (obj *Initialize) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `InitAmount0`:
	if err = decoder.Decode(&obj.InitAmount0); err != nil {
		return fmt.Errorf("error while unmarshaling InitAmount0:%w", err)
	}
	// Deserialize `InitAmount1`:
	if err = decoder.Decode(&obj.InitAmount1); err != nil {
		return fmt.Errorf("error while unmarshaling InitAmount1:%w", err)
	}
	// Deserialize `OpenTime`:
	if err = decoder.Decode(&obj.OpenTime); err != nil {
		return fmt.Errorf("error while unmarshaling OpenTime:%w", err)
	}
	return nil
}

func (obj *Initialize) SetAccounts(accounts solanago.PublicKeySlice) (err error) {
	if len(accounts) < 20 {
		return fmt.Errorf("too few accounts, expect %d actual %d", 20, len(accounts))
	}
	obj.Creator = accounts[0]
	obj.AmmConfig = accounts[1]
	obj.Authority = accounts[2]
	obj.PoolState = accounts[3]
	obj.Token0Mint = accounts[4]
	obj.Token1Mint = accounts[5]
	obj.LpMint = accounts[6]
	obj.CreatorToken0 = accounts[7]
	obj.CreatorToken1 = accounts[8]
	obj.CreatorLpToken = accounts[9]
	obj.Token0Vault = accounts[10]
	obj.Token1Vault = accounts[11]
	obj.CreatePoolFee = accounts[12]
	obj.ObservationState = accounts[13]
	obj.TokenProgram = accounts[14]
	obj.Token0Program = accounts[15]
	obj.Token1Program = accounts[16]
	obj.AssociatedTokenProgram = accounts[17]
	obj.SystemProgram = accounts[18]
	obj.Rent = accounts[19]
	obj.PublicKeySlice = accounts
	return nil
}
func (obj *Initialize) PublicKeys() solanago.PublicKeySlice {
	return obj.PublicKeySlice
}

func (*Initialize) TypeID() binary.TypeID {
	return binary.TypeIDFromBytes(Instruction_Initialize)
}

func (*Initialize) NewInstance() programparser.Instruction {
	return new(Initialize)
}

// Builds a "initialize" instruction.
// Creates a pool for the given token pair and the initial price //  // # Arguments //  // * `ctx`- The context of accounts // * `init_amount_0` - the initial amount_0 to deposit // * `init_amount_1` - the initial amount_1 to deposit // * `open_time` - the timestamp allowed for swap //
func NewInitializeInstruction(
	// Params:
	initAmount0param uint64,
	initAmount1param uint64,
	openTimeParam uint64,

	// Accounts:
	creator solanago.PublicKey,
	ammConfig solanago.PublicKey,
	authority solanago.PublicKey,
	poolState solanago.PublicKey,
	token0Mint solanago.PublicKey,
	token1Mint solanago.PublicKey,
	lpMint solanago.PublicKey,
	creatorToken0 solanago.PublicKey,
	creatorToken1 solanago.PublicKey,
	creatorLpToken solanago.PublicKey,
	token0Vault solanago.PublicKey,
	token1Vault solanago.PublicKey,
	observationState solanago.PublicKey,
	token0Program solanago.PublicKey,
	token1Program solanago.PublicKey,
	remaining__ ...*solanago.AccountMeta,
) (*solanago.GenericInstruction, error) {
	var (
		err    error
		buf__  = new(bytes.Buffer)
		enc__  = binary.NewBorshEncoder(buf__)
		metas_ = make(solanago.AccountMetaSlice, 20, 20+len(remaining__))
	)

	// Encode the instruction discriminator.
	if err = enc__.WriteBytes(Instruction_Initialize[:], false); err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}

	{
		// Serialize `initAmount0param`:
		if err = enc__.Encode(initAmount0param); err != nil {
			return nil, fmt.Errorf("error while marshaling initAmount0param:%w", err)
		}
		// Serialize `initAmount1param`:
		if err = enc__.Encode(initAmount1param); err != nil {
			return nil, fmt.Errorf("error while marshaling initAmount1param:%w", err)
		}
		// Serialize `openTimeParam`:
		if err = enc__.Encode(openTimeParam); err != nil {
			return nil, fmt.Errorf("error while marshaling openTimeParam:%w", err)
		}
	}

	// Add the accounts to the instruction.
	{
		// [0] = [writable,signer] creator
		// Address paying to create the pool. Can be anyone
		metas_[0] = solanago.NewAccountMeta(creator, true, true)
		// [1] = [] amm_config
		// Which config the pool belongs to.
		metas_[1] = solanago.NewAccountMeta(ammConfig, false, false)
		// [2] = [] authority
		// pool vault and lp mint authority
		metas_[2] = solanago.NewAccountMeta(authority, false, false)
		// [3] = [writable] pool_state
		// PDA account:
		// seeds = [
		// POOL_SEED.as_bytes(),
		// amm_config.key().as_ref(),
		// token_0_mint.key().as_ref(),
		// token_1_mint.key().as_ref(),
		// ],
		//
		// Or random account: must be signed by cli
		metas_[3] = solanago.NewAccountMeta(poolState, true, false)
		// [4] = [] token_0_mint
		// Token_0 mint, the key must smaller than token_1 mint.
		metas_[4] = solanago.NewAccountMeta(token0Mint, false, false)
		// [5] = [] token_1_mint
		// Token_1 mint, the key must grater then token_0 mint.
		metas_[5] = solanago.NewAccountMeta(token1Mint, false, false)
		// [6] = [writable] lp_mint
		// pool lp mint
		metas_[6] = solanago.NewAccountMeta(lpMint, true, false)
		// [7] = [writable] creator_token_0
		// payer token0 account
		metas_[7] = solanago.NewAccountMeta(creatorToken0, true, false)
		// [8] = [writable] creator_token_1
		// creator token1 account
		metas_[8] = solanago.NewAccountMeta(creatorToken1, true, false)
		// [9] = [writable] creator_lp_token
		// creator lp token account
		metas_[9] = solanago.NewAccountMeta(creatorLpToken, true, false)
		// [10] = [writable] token_0_vault
		metas_[10] = solanago.NewAccountMeta(token0Vault, true, false)
		// [11] = [writable] token_1_vault
		metas_[11] = solanago.NewAccountMeta(token1Vault, true, false)
		// [12] = [writable] create_pool_fee[DNXgeM9EiiaAbaWvwjHj9fQQLAX5ZsfHyvmYUNRAdNC8]
		// create pool fee account
		metas_[12] = solanago.NewAccountMeta(CreatePoolFee, true, false)
		// [13] = [writable] observation_state
		// an account to store oracle observations
		metas_[13] = solanago.NewAccountMeta(observationState, true, false)
		// [14] = [] token_program[TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA]
		// Program to create mint account and mint tokens
		metas_[14] = solanago.NewAccountMeta(TokenProgram, false, false)
		// [15] = [] token_0_program
		// Spl token program or token program 2022
		metas_[15] = solanago.NewAccountMeta(token0Program, false, false)
		// [16] = [] token_1_program
		// Spl token program or token program 2022
		metas_[16] = solanago.NewAccountMeta(token1Program, false, false)
		// [17] = [] associated_token_program[ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL]
		// Program to create an ATA for receiving position NFT
		metas_[17] = solanago.NewAccountMeta(AssociatedTokenProgram, false, false)
		// [18] = [] system_program
		// To create a new program account
		metas_[18] = solanago.NewAccountMeta(SystemProgram, false, false)
		// [19] = [] rent[SysvarRent111111111111111111111111111111111]
		// Sysvar for program account
		metas_[19] = solanago.NewAccountMeta(Rent, false, false)
		// append remaining metas
		metas_ = append(metas_, remaining__...)
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		metas_,
		buf__.Bytes(),
	), nil
}

// Builds a "BuildInitialize" instruction.
// Creates a pool for the given token pair and the initial price //  // # Arguments //  // * `ctx`- The context of accounts // * `init_amount_0` - the initial amount_0 to deposit // * `init_amount_1` - the initial amount_1 to deposit // * `open_time` - the timestamp allowed for swap //
func BuildInitialize(
	// Params:
	initAmount0param uint64,
	initAmount1param uint64,
	openTimeParam uint64,

	// Accounts:
	creator solanago.PublicKey,
	ammConfig solanago.PublicKey,
	authority solanago.PublicKey,
	poolState solanago.PublicKey,
	token0Mint solanago.PublicKey,
	token1Mint solanago.PublicKey,
	lpMint solanago.PublicKey,
	creatorToken0 solanago.PublicKey,
	creatorToken1 solanago.PublicKey,
	creatorLpToken solanago.PublicKey,
	token0Vault solanago.PublicKey,
	token1Vault solanago.PublicKey,
	observationState solanago.PublicKey,
	token0Program solanago.PublicKey,
	token1Program solanago.PublicKey,
	remaining__ ...*solanago.AccountMeta,
) *solanago.GenericInstruction {
	instruction_, _ := NewInitializeInstruction(
		initAmount0param,
		initAmount1param,
		openTimeParam,
		creator,
		ammConfig,
		authority,
		poolState,
		token0Mint,
		token1Mint,
		lpMint,
		creatorToken0,
		creatorToken1,
		creatorLpToken,
		token0Vault,
		token1Vault,
		observationState,
		token0Program,
		token1Program,
		remaining__...,
	)
	return instruction_
}
