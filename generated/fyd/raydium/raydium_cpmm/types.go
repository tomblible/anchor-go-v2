// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains parsers for the types defined in the IDL.

package raydium_cpmm

import (
	"bytes"
	"fmt"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

type Instruction interface {
	TypeID() binary.TypeID
	SetAccounts(accounts solanago.PublicKeySlice) error
	Copy() Instruction
}

// The element of observations in ObservationState
type Observation struct {
	// The block timestamp of the observation
	BlockTimestamp uint64

	// the cumulative of token0 price during the duration time, Q32.32, the remaining 64 bit for overflow
	CumulativeToken0PriceX32 binary.Uint128

	// the cumulative of token1 price during the duration time, Q32.32, the remaining 64 bit for overflow
	CumulativeToken1PriceX32 binary.Uint128
}

func (obj Observation) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `BlockTimestamp`:
	if err = encoder.Encode(obj.BlockTimestamp); err != nil {
		return fmt.Errorf("error while marshaling BlockTimestamp:%w", err)
	}
	// Serialize `CumulativeToken0PriceX32`:
	if err = encoder.Encode(obj.CumulativeToken0PriceX32); err != nil {
		return fmt.Errorf("error while marshaling CumulativeToken0PriceX32:%w", err)
	}
	// Serialize `CumulativeToken1PriceX32`:
	if err = encoder.Encode(obj.CumulativeToken1PriceX32); err != nil {
		return fmt.Errorf("error while marshaling CumulativeToken1PriceX32:%w", err)
	}
	return nil
}

func (obj Observation) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Observation: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Observation) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `BlockTimestamp`:
	if err = decoder.Decode(&obj.BlockTimestamp); err != nil {
		return fmt.Errorf("error while unmarshaling BlockTimestamp:%w", err)
	}
	// Deserialize `CumulativeToken0PriceX32`:
	if err = decoder.Decode(&obj.CumulativeToken0PriceX32); err != nil {
		return fmt.Errorf("error while unmarshaling CumulativeToken0PriceX32:%w", err)
	}
	// Deserialize `CumulativeToken1PriceX32`:
	if err = decoder.Decode(&obj.CumulativeToken1PriceX32); err != nil {
		return fmt.Errorf("error while unmarshaling CumulativeToken1PriceX32:%w", err)
	}
	return nil
}

func (obj *Observation) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Observation: %w", err)
	}
	return nil
}

func UnmarshalObservation(buf []byte) (*Observation, error) {
	obj := new(Observation)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}
