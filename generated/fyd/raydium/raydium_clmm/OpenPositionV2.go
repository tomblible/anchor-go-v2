// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package raydium_clmm

import (
	"bytes"
	"fmt"

	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
	programparser "github.com/yydsqu/solana-sdk/program_parser"
)

// Builds a "open_position_v2" instruction.

// #[deprecated(note = "Use `open_position_with_token22_nft` instead.")]
// Creates a new position wrapped in a NFT, support Token2022
//
// # Arguments
//
// * `ctx` - The context of accounts
// * `tick_lower_index` - The low boundary of market
// * `tick_upper_index` - The upper boundary of market
// * `tick_array_lower_start_index` - The start index of tick array which include tick low
// * `tick_array_upper_start_index` - The start index of tick array which include tick upper
// * `liquidity` - The liquidity to be added, if zero, and the base_flag is specified, calculate liquidity base amount_0_max or amount_1_max according base_flag, otherwise open position with zero liquidity
// * `amount_0_max` - The max amount of token_0 to spend, which serves as a slippage check
// * `amount_1_max` - The max amount of token_1 to spend, which serves as a slippage check
// * `with_metadata` - The flag indicating whether to create NFT mint metadata
// * `base_flag` - if the liquidity specified as zero, true: calculate liquidity base amount_0_max otherwise base amount_1_max
type OpenPositionV2 struct {
	// Params:
	TickLowerIndex           int32
	TickUpperIndex           int32
	TickArrayLowerStartIndex int32
	TickArrayUpperStartIndex int32
	Liquidity                binary.Uint128
	Amount0Max               uint64
	Amount1Max               uint64
	WithMetadata             bool
	BaseFlag                 *bool `bin:"optional"`
	// Accounts:
	// [0] = [writable,signer] payer
	Payer solanago.PublicKey `bin:"-"`
	// [1] = [] position_nft_owner
	PositionNftOwner solanago.PublicKey `bin:"-"`
	// [2] = [writable,signer] position_nft_mint
	PositionNftMint solanago.PublicKey `bin:"-"`
	// [3] = [writable] position_nft_account
	PositionNftAccount solanago.PublicKey `bin:"-"`
	// [4] = [writable] metadata_account
	MetadataAccount solanago.PublicKey `bin:"-"`
	// [5] = [writable] pool_state
	PoolState solanago.PublicKey `bin:"-"`
	// [6] = [writable] protocol_position
	ProtocolPosition solanago.PublicKey `bin:"-"`
	// [7] = [writable] tick_array_lower
	TickArrayLower solanago.PublicKey `bin:"-"`
	// [8] = [writable] tick_array_upper
	TickArrayUpper solanago.PublicKey `bin:"-"`
	// [9] = [writable] personal_position
	PersonalPosition solanago.PublicKey `bin:"-"`
	// [10] = [writable] token_account_0
	TokenAccount0 solanago.PublicKey `bin:"-"`
	// [11] = [writable] token_account_1
	TokenAccount1 solanago.PublicKey `bin:"-"`
	// [12] = [writable] token_vault_0
	TokenVault0 solanago.PublicKey `bin:"-"`
	// [13] = [writable] token_vault_1
	TokenVault1 solanago.PublicKey `bin:"-"`
	// [14] = [] rent[SysvarRent111111111111111111111111111111111]
	Rent solanago.PublicKey `bin:"-"`
	// [15] = [] system_program
	SystemProgram solanago.PublicKey `bin:"-"`
	// [16] = [] token_program[TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA]
	TokenProgram solanago.PublicKey `bin:"-"`
	// [17] = [] associated_token_program[ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL]
	AssociatedTokenProgram solanago.PublicKey `bin:"-"`
	// [18] = [] metadata_program[metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s]
	MetadataProgram solanago.PublicKey `bin:"-"`
	// [19] = [] token_program_2022[TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb]
	TokenProgram2022 solanago.PublicKey `bin:"-"`
	// [20] = [] vault_0_mint
	Vault0Mint solanago.PublicKey `bin:"-"`
	// [21] = [] vault_1_mint
	Vault1Mint solanago.PublicKey `bin:"-"`
	// PublicKeySlice
	solanago.PublicKeySlice `bin:"-"`
}

func (obj OpenPositionV2) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `tickLowerIndexParam`:
	if err = encoder.Encode(obj.TickLowerIndex); err != nil {
		return fmt.Errorf("error while marshaling tickLowerIndexParam:%w", err)
	}
	// Serialize `tickUpperIndexParam`:
	if err = encoder.Encode(obj.TickUpperIndex); err != nil {
		return fmt.Errorf("error while marshaling tickUpperIndexParam:%w", err)
	}
	// Serialize `tickArrayLowerStartIndexParam`:
	if err = encoder.Encode(obj.TickArrayLowerStartIndex); err != nil {
		return fmt.Errorf("error while marshaling tickArrayLowerStartIndexParam:%w", err)
	}
	// Serialize `tickArrayUpperStartIndexParam`:
	if err = encoder.Encode(obj.TickArrayUpperStartIndex); err != nil {
		return fmt.Errorf("error while marshaling tickArrayUpperStartIndexParam:%w", err)
	}
	// Serialize `liquidityParam`:
	if err = encoder.Encode(obj.Liquidity); err != nil {
		return fmt.Errorf("error while marshaling liquidityParam:%w", err)
	}
	// Serialize `amount0MaxParam`:
	if err = encoder.Encode(obj.Amount0Max); err != nil {
		return fmt.Errorf("error while marshaling amount0MaxParam:%w", err)
	}
	// Serialize `amount1MaxParam`:
	if err = encoder.Encode(obj.Amount1Max); err != nil {
		return fmt.Errorf("error while marshaling amount1MaxParam:%w", err)
	}
	// Serialize `withMetadataParam`:
	if err = encoder.Encode(obj.WithMetadata); err != nil {
		return fmt.Errorf("error while marshaling withMetadataParam:%w", err)
	}
	// Serialize `baseFlagParam` (optional):
	{
		if obj.BaseFlag == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling baseFlagParam optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling baseFlagParam optionality: %w", err)
			}
			if err = encoder.Encode(obj.BaseFlag); err != nil {
				return fmt.Errorf("error while marshaling baseFlagParam: %w", err)
			}
		}
	}
	return nil
}

func (obj *OpenPositionV2) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `TickLowerIndex`:
	if err = decoder.Decode(&obj.TickLowerIndex); err != nil {
		return fmt.Errorf("error while unmarshaling TickLowerIndex:%w", err)
	}
	// Deserialize `TickUpperIndex`:
	if err = decoder.Decode(&obj.TickUpperIndex); err != nil {
		return fmt.Errorf("error while unmarshaling TickUpperIndex:%w", err)
	}
	// Deserialize `TickArrayLowerStartIndex`:
	if err = decoder.Decode(&obj.TickArrayLowerStartIndex); err != nil {
		return fmt.Errorf("error while unmarshaling TickArrayLowerStartIndex:%w", err)
	}
	// Deserialize `TickArrayUpperStartIndex`:
	if err = decoder.Decode(&obj.TickArrayUpperStartIndex); err != nil {
		return fmt.Errorf("error while unmarshaling TickArrayUpperStartIndex:%w", err)
	}
	// Deserialize `Liquidity`:
	if err = decoder.Decode(&obj.Liquidity); err != nil {
		return fmt.Errorf("error while unmarshaling Liquidity:%w", err)
	}
	// Deserialize `Amount0Max`:
	if err = decoder.Decode(&obj.Amount0Max); err != nil {
		return fmt.Errorf("error while unmarshaling Amount0Max:%w", err)
	}
	// Deserialize `Amount1Max`:
	if err = decoder.Decode(&obj.Amount1Max); err != nil {
		return fmt.Errorf("error while unmarshaling Amount1Max:%w", err)
	}
	// Deserialize `WithMetadata`:
	if err = decoder.Decode(&obj.WithMetadata); err != nil {
		return fmt.Errorf("error while unmarshaling WithMetadata:%w", err)
	}
	// Deserialize `BaseFlag` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling BaseFlag:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.BaseFlag); err != nil {
				return fmt.Errorf("error while unmarshaling BaseFlag:%w", err)
			}
		}
	}
	return nil
}

func (obj *OpenPositionV2) SetAccounts(accounts solanago.PublicKeySlice) (err error) {
	if len(accounts) < 22 {
		return fmt.Errorf("too few accounts, expect %d actual %d", 22, len(accounts))
	}
	obj.Payer = accounts[0]
	obj.PositionNftOwner = accounts[1]
	obj.PositionNftMint = accounts[2]
	obj.PositionNftAccount = accounts[3]
	obj.MetadataAccount = accounts[4]
	obj.PoolState = accounts[5]
	obj.ProtocolPosition = accounts[6]
	obj.TickArrayLower = accounts[7]
	obj.TickArrayUpper = accounts[8]
	obj.PersonalPosition = accounts[9]
	obj.TokenAccount0 = accounts[10]
	obj.TokenAccount1 = accounts[11]
	obj.TokenVault0 = accounts[12]
	obj.TokenVault1 = accounts[13]
	obj.Rent = accounts[14]
	obj.SystemProgram = accounts[15]
	obj.TokenProgram = accounts[16]
	obj.AssociatedTokenProgram = accounts[17]
	obj.MetadataProgram = accounts[18]
	obj.TokenProgram2022 = accounts[19]
	obj.Vault0Mint = accounts[20]
	obj.Vault1Mint = accounts[21]
	obj.PublicKeySlice = accounts
	return nil
}
func (obj *OpenPositionV2) PublicKeys() solanago.PublicKeySlice {
	return obj.PublicKeySlice
}

func (*OpenPositionV2) TypeID() binary.TypeID {
	return binary.TypeIDFromBytes(Instruction_OpenPositionV2)
}

func (*OpenPositionV2) NewInstance() programparser.Instruction {
	return new(OpenPositionV2)
}

func (obj *OpenPositionV2) GetRemainingAccounts() solanago.PublicKeySlice {
	if len(obj.PublicKeySlice) <= 22 {
		return nil
	}
	return obj.PublicKeySlice[22:]
}

// Builds a "open_position_v2" instruction.
// #[deprecated(note = "Use `open_position_with_token22_nft` instead.")] // Creates a new position wrapped in a NFT, support Token2022 //  // # Arguments //  // * `ctx` - The context of accounts // * `tick_lower_index` - The low boundary of market // * `tick_upper_index` - The upper boundary of market // * `tick_array_lower_start_index` - The start index of tick array which include tick low // * `tick_array_upper_start_index` - The start index of tick array which include tick upper // * `liquidity` - The liquidity to be added, if zero, and the base_flag is specified, calculate liquidity base amount_0_max or amount_1_max according base_flag, otherwise open position with zero liquidity // * `amount_0_max` - The max amount of token_0 to spend, which serves as a slippage check // * `amount_1_max` - The max amount of token_1 to spend, which serves as a slippage check // * `with_metadata` - The flag indicating whether to create NFT mint metadata // * `base_flag` - if the liquidity specified as zero, true: calculate liquidity base amount_0_max otherwise base amount_1_max //
func NewOpenPositionV2Instruction(
	// Params:
	tickLowerIndexParam int32,
	tickUpperIndexParam int32,
	tickArrayLowerStartIndexParam int32,
	tickArrayUpperStartIndexParam int32,
	liquidityParam binary.Uint128,
	amount0MaxParam uint64,
	amount1MaxParam uint64,
	withMetadataParam bool,
	baseFlagParam *bool,

	// Accounts:
	payer solanago.PublicKey,
	positionNftOwner solanago.PublicKey,
	positionNftMint solanago.PublicKey,
	positionNftAccount solanago.PublicKey,
	metadataAccount solanago.PublicKey,
	poolState solanago.PublicKey,
	protocolPosition solanago.PublicKey,
	tickArrayLower solanago.PublicKey,
	tickArrayUpper solanago.PublicKey,
	personalPosition solanago.PublicKey,
	tokenAccount0 solanago.PublicKey,
	tokenAccount1 solanago.PublicKey,
	tokenVault0 solanago.PublicKey,
	tokenVault1 solanago.PublicKey,
	vault0Mint solanago.PublicKey,
	vault1Mint solanago.PublicKey,
	remaining__ ...*solanago.AccountMeta,
) (*solanago.GenericInstruction, error) {
	var (
		err    error
		buf__  = new(bytes.Buffer)
		enc__  = binary.NewBorshEncoder(buf__)
		metas_ = make(solanago.AccountMetaSlice, 22, 22+len(remaining__))
	)

	// Encode the instruction discriminator.
	if err = enc__.WriteBytes(Instruction_OpenPositionV2[:], false); err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}

	{
		// Serialize `tickLowerIndexParam`:
		if err = enc__.Encode(tickLowerIndexParam); err != nil {
			return nil, fmt.Errorf("error while marshaling tickLowerIndexParam:%w", err)
		}
		// Serialize `tickUpperIndexParam`:
		if err = enc__.Encode(tickUpperIndexParam); err != nil {
			return nil, fmt.Errorf("error while marshaling tickUpperIndexParam:%w", err)
		}
		// Serialize `tickArrayLowerStartIndexParam`:
		if err = enc__.Encode(tickArrayLowerStartIndexParam); err != nil {
			return nil, fmt.Errorf("error while marshaling tickArrayLowerStartIndexParam:%w", err)
		}
		// Serialize `tickArrayUpperStartIndexParam`:
		if err = enc__.Encode(tickArrayUpperStartIndexParam); err != nil {
			return nil, fmt.Errorf("error while marshaling tickArrayUpperStartIndexParam:%w", err)
		}
		// Serialize `liquidityParam`:
		if err = enc__.Encode(liquidityParam); err != nil {
			return nil, fmt.Errorf("error while marshaling liquidityParam:%w", err)
		}
		// Serialize `amount0MaxParam`:
		if err = enc__.Encode(amount0MaxParam); err != nil {
			return nil, fmt.Errorf("error while marshaling amount0MaxParam:%w", err)
		}
		// Serialize `amount1MaxParam`:
		if err = enc__.Encode(amount1MaxParam); err != nil {
			return nil, fmt.Errorf("error while marshaling amount1MaxParam:%w", err)
		}
		// Serialize `withMetadataParam`:
		if err = enc__.Encode(withMetadataParam); err != nil {
			return nil, fmt.Errorf("error while marshaling withMetadataParam:%w", err)
		}
		// Serialize `baseFlagParam` (optional):
		{
			if baseFlagParam == nil {
				if err = enc__.WriteOption(false); err != nil {
					return nil, fmt.Errorf("error while marshaling baseFlagParam optionality: %w", err)
				}
			} else {
				if err = enc__.WriteOption(true); err != nil {
					return nil, fmt.Errorf("error while marshaling baseFlagParam optionality: %w", err)
				}
				if err = enc__.Encode(baseFlagParam); err != nil {
					return nil, fmt.Errorf("error while marshaling baseFlagParam: %w", err)
				}
			}
		}
	}

	// Add the accounts to the instruction.
	{
		// [0] = [writable,signer] payer
		// Pays to mint the position
		metas_[0] = solanago.NewAccountMeta(payer, true, true)
		// [1] = [] position_nft_owner
		metas_[1] = solanago.NewAccountMeta(positionNftOwner, false, false)
		// [2] = [writable,signer] position_nft_mint
		// Unique token mint address
		metas_[2] = solanago.NewAccountMeta(positionNftMint, true, true)
		// [3] = [writable] position_nft_account
		// Token account where position NFT will be minted
		metas_[3] = solanago.NewAccountMeta(positionNftAccount, true, false)
		// [4] = [writable] metadata_account
		// To store metaplex metadata
		metas_[4] = solanago.NewAccountMeta(metadataAccount, true, false)
		// [5] = [writable] pool_state
		// Add liquidity for this pool
		metas_[5] = solanago.NewAccountMeta(poolState, true, false)
		// [6] = [writable] protocol_position
		// Store the information of market marking in range
		metas_[6] = solanago.NewAccountMeta(protocolPosition, true, false)
		// [7] = [writable] tick_array_lower
		metas_[7] = solanago.NewAccountMeta(tickArrayLower, true, false)
		// [8] = [writable] tick_array_upper
		metas_[8] = solanago.NewAccountMeta(tickArrayUpper, true, false)
		// [9] = [writable] personal_position
		// personal position state
		metas_[9] = solanago.NewAccountMeta(personalPosition, true, false)
		// [10] = [writable] token_account_0
		// The token_0 account deposit token to the pool
		metas_[10] = solanago.NewAccountMeta(tokenAccount0, true, false)
		// [11] = [writable] token_account_1
		// The token_1 account deposit token to the pool
		metas_[11] = solanago.NewAccountMeta(tokenAccount1, true, false)
		// [12] = [writable] token_vault_0
		// The address that holds pool tokens for token_0
		metas_[12] = solanago.NewAccountMeta(tokenVault0, true, false)
		// [13] = [writable] token_vault_1
		// The address that holds pool tokens for token_1
		metas_[13] = solanago.NewAccountMeta(tokenVault1, true, false)
		// [14] = [] rent[SysvarRent111111111111111111111111111111111]
		// Sysvar for token mint and ATA creation
		metas_[14] = solanago.NewAccountMeta(Rent, false, false)
		// [15] = [] system_program
		// Program to create the position manager state account
		metas_[15] = solanago.NewAccountMeta(SystemProgram, false, false)
		// [16] = [] token_program[TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA]
		// Program to create mint account and mint tokens
		metas_[16] = solanago.NewAccountMeta(TokenProgram, false, false)
		// [17] = [] associated_token_program[ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL]
		// Program to create an ATA for receiving position NFT
		metas_[17] = solanago.NewAccountMeta(AssociatedTokenProgram, false, false)
		// [18] = [] metadata_program[metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s]
		// Program to create NFT metadata
		metas_[18] = solanago.NewAccountMeta(MetadataProgram, false, false)
		// [19] = [] token_program_2022[TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb]
		// Program to create mint account and mint tokens
		metas_[19] = solanago.NewAccountMeta(TokenProgram2022, false, false)
		// [20] = [] vault_0_mint
		// The mint of token vault 0
		metas_[20] = solanago.NewAccountMeta(vault0Mint, false, false)
		// [21] = [] vault_1_mint
		// The mint of token vault 1
		metas_[21] = solanago.NewAccountMeta(vault1Mint, false, false)
		// append remaining metas
		metas_ = append(metas_, remaining__...)
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		metas_,
		buf__.Bytes(),
	), nil
}

// Builds a "BuildOpenPositionV2" instruction.
// #[deprecated(note = "Use `open_position_with_token22_nft` instead.")] // Creates a new position wrapped in a NFT, support Token2022 //  // # Arguments //  // * `ctx` - The context of accounts // * `tick_lower_index` - The low boundary of market // * `tick_upper_index` - The upper boundary of market // * `tick_array_lower_start_index` - The start index of tick array which include tick low // * `tick_array_upper_start_index` - The start index of tick array which include tick upper // * `liquidity` - The liquidity to be added, if zero, and the base_flag is specified, calculate liquidity base amount_0_max or amount_1_max according base_flag, otherwise open position with zero liquidity // * `amount_0_max` - The max amount of token_0 to spend, which serves as a slippage check // * `amount_1_max` - The max amount of token_1 to spend, which serves as a slippage check // * `with_metadata` - The flag indicating whether to create NFT mint metadata // * `base_flag` - if the liquidity specified as zero, true: calculate liquidity base amount_0_max otherwise base amount_1_max //
func BuildOpenPositionV2(
	// Params:
	tickLowerIndexParam int32,
	tickUpperIndexParam int32,
	tickArrayLowerStartIndexParam int32,
	tickArrayUpperStartIndexParam int32,
	liquidityParam binary.Uint128,
	amount0MaxParam uint64,
	amount1MaxParam uint64,
	withMetadataParam bool,
	baseFlagParam *bool,

	// Accounts:
	payer solanago.PublicKey,
	positionNftOwner solanago.PublicKey,
	positionNftMint solanago.PublicKey,
	positionNftAccount solanago.PublicKey,
	metadataAccount solanago.PublicKey,
	poolState solanago.PublicKey,
	protocolPosition solanago.PublicKey,
	tickArrayLower solanago.PublicKey,
	tickArrayUpper solanago.PublicKey,
	personalPosition solanago.PublicKey,
	tokenAccount0 solanago.PublicKey,
	tokenAccount1 solanago.PublicKey,
	tokenVault0 solanago.PublicKey,
	tokenVault1 solanago.PublicKey,
	vault0Mint solanago.PublicKey,
	vault1Mint solanago.PublicKey,
	remaining__ ...*solanago.AccountMeta,
) *solanago.GenericInstruction {
	instruction_, _ := NewOpenPositionV2Instruction(
		tickLowerIndexParam,
		tickUpperIndexParam,
		tickArrayLowerStartIndexParam,
		tickArrayUpperStartIndexParam,
		liquidityParam,
		amount0MaxParam,
		amount1MaxParam,
		withMetadataParam,
		baseFlagParam,
		payer,
		positionNftOwner,
		positionNftMint,
		positionNftAccount,
		metadataAccount,
		poolState,
		protocolPosition,
		tickArrayLower,
		tickArrayUpper,
		personalPosition,
		tokenAccount0,
		tokenAccount1,
		tokenVault0,
		tokenVault1,
		vault0Mint,
		vault1Mint,
		remaining__...,
	)
	return instruction_
}
