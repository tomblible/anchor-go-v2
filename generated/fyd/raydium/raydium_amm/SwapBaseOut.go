// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package raydium_amm

import (
	"bytes"
	"fmt"

	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
	programparser "github.com/yydsqu/solana-sdk/program_parser"
)

// Builds a "swap_base_out" instruction.
type SwapBaseOut struct {
	// Params:
	MaxAmountIn uint64
	AmountOut   uint64
	// Accounts:
	// [0] = [] token_program
	TokenProgram solanago.PublicKey `bin:"-"`
	// [1] = [writable] amm
	Amm solanago.PublicKey `bin:"-"`
	// [2] = [] amm_authority
	AmmAuthority solanago.PublicKey `bin:"-"`
	// [3] = [writable] amm_open_orders
	AmmOpenOrders solanago.PublicKey `bin:"-"`
	// [4] = [writable] amm_target_orders
	AmmTargetOrders solanago.PublicKey `bin:"-"`
	// [5] = [writable] pool_coin_token_account
	PoolCoinTokenAccount solanago.PublicKey `bin:"-"`
	// [6] = [writable] pool_pc_token_account
	PoolPcTokenAccount solanago.PublicKey `bin:"-"`
	// [7] = [] serum_program
	SerumProgram solanago.PublicKey `bin:"-"`
	// [8] = [writable] serum_market
	SerumMarket solanago.PublicKey `bin:"-"`
	// [9] = [writable] serum_bids
	SerumBids solanago.PublicKey `bin:"-"`
	// [10] = [writable] serum_asks
	SerumAsks solanago.PublicKey `bin:"-"`
	// [11] = [writable] serum_event_queue
	SerumEventQueue solanago.PublicKey `bin:"-"`
	// [12] = [writable] serum_coin_vault_account
	SerumCoinVaultAccount solanago.PublicKey `bin:"-"`
	// [13] = [writable] serum_pc_vault_account
	SerumPcVaultAccount solanago.PublicKey `bin:"-"`
	// [14] = [] serum_vault_signer
	SerumVaultSigner solanago.PublicKey `bin:"-"`
	// [15] = [writable] uer_source_token_account
	UerSourceTokenAccount solanago.PublicKey `bin:"-"`
	// [16] = [writable] uer_destination_token_account
	UerDestinationTokenAccount solanago.PublicKey `bin:"-"`
	// [17] = [,signer] user_source_owner
	UserSourceOwner solanago.PublicKey `bin:"-"`
	// PublicKeySlice
	solanago.PublicKeySlice `bin:"-"`
}

func (obj SwapBaseOut) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `maxAmountInParam`:
	if err = encoder.Encode(obj.MaxAmountIn); err != nil {
		return fmt.Errorf("error while marshaling maxAmountInParam:%w", err)
	}
	// Serialize `amountOutParam`:
	if err = encoder.Encode(obj.AmountOut); err != nil {
		return fmt.Errorf("error while marshaling amountOutParam:%w", err)
	}
	return nil
}

func (obj *SwapBaseOut) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `MaxAmountIn`:
	if err = decoder.Decode(&obj.MaxAmountIn); err != nil {
		return fmt.Errorf("error while unmarshaling MaxAmountIn:%w", err)
	}
	// Deserialize `AmountOut`:
	if err = decoder.Decode(&obj.AmountOut); err != nil {
		return fmt.Errorf("error while unmarshaling AmountOut:%w", err)
	}
	return nil
}

func (obj *SwapBaseOut) SetAccounts(accounts solanago.PublicKeySlice) error {
	n := len(accounts)
	if n != 17 && n != 18 {
		return fmt.Errorf("invalid accounts length, expect 17 or 18, got %d", n)
	}

	// 通用字段（17 和 18 都需要）
	obj.TokenProgram = accounts[0]
	obj.Amm = accounts[1]
	obj.AmmAuthority = accounts[2]
	obj.AmmOpenOrders = accounts[3]

	if n == 18 {
		// 18 个账户时
		obj.AmmTargetOrders = accounts[4]
		obj.PoolCoinTokenAccount = accounts[5]
		obj.PoolPcTokenAccount = accounts[6]
		obj.SerumProgram = accounts[7]
		obj.SerumMarket = accounts[8]
		obj.SerumBids = accounts[9]
		obj.SerumAsks = accounts[10]
		obj.SerumEventQueue = accounts[11]
		obj.SerumCoinVaultAccount = accounts[12]
		obj.SerumPcVaultAccount = accounts[13]
		obj.SerumVaultSigner = accounts[14]
		obj.UerSourceTokenAccount = accounts[15]
		obj.UerDestinationTokenAccount = accounts[16]
		obj.UserSourceOwner = accounts[17]
	} else {
		// 17 个账户时
		obj.AmmTargetOrders = accounts[2] // 注意和 18 个账户时不一样
		obj.PoolCoinTokenAccount = accounts[4]
		obj.PoolPcTokenAccount = accounts[5]
		obj.SerumProgram = accounts[6]
		obj.SerumMarket = accounts[7]
		obj.SerumBids = accounts[8]
		obj.SerumAsks = accounts[9]
		obj.SerumEventQueue = accounts[10]
		obj.SerumCoinVaultAccount = accounts[11]
		obj.SerumPcVaultAccount = accounts[12]
		obj.SerumVaultSigner = accounts[13]
		obj.UerSourceTokenAccount = accounts[14]
		obj.UerDestinationTokenAccount = accounts[15]
		obj.UserSourceOwner = accounts[16]
	}

	obj.PublicKeySlice = accounts
	return nil
}

func (obj *SwapBaseOut) PublicKeys() solanago.PublicKeySlice {
	return obj.PublicKeySlice
}

func (*SwapBaseOut) TypeID() binary.TypeID {
	return binary.TypeIDFromBytes(Instruction_SwapBaseOut)
}

func (*SwapBaseOut) NewInstance() programparser.Instruction {
	return new(SwapBaseOut)
}

func (obj *SwapBaseOut) GetRemainingAccounts() solanago.PublicKeySlice {
	if len(obj.PublicKeySlice) <= 18 {
		return nil
	}
	return obj.PublicKeySlice[18:]
}

// Builds a "swap_base_out" instruction.
func NewSwapBaseOutInstruction(
	// Params:
	maxAmountInParam uint64,
	amountOutParam uint64,

	// Accounts:
	tokenProgram solanago.PublicKey,
	amm solanago.PublicKey,
	ammAuthority solanago.PublicKey,
	ammOpenOrders solanago.PublicKey,
	ammTargetOrders solanago.PublicKey,
	poolCoinTokenAccount solanago.PublicKey,
	poolPcTokenAccount solanago.PublicKey,
	serumProgram solanago.PublicKey,
	serumMarket solanago.PublicKey,
	serumBids solanago.PublicKey,
	serumAsks solanago.PublicKey,
	serumEventQueue solanago.PublicKey,
	serumCoinVaultAccount solanago.PublicKey,
	serumPcVaultAccount solanago.PublicKey,
	serumVaultSigner solanago.PublicKey,
	uerSourceTokenAccount solanago.PublicKey,
	uerDestinationTokenAccount solanago.PublicKey,
	userSourceOwner solanago.PublicKey,
	remaining__ ...*solanago.AccountMeta,
) (*solanago.GenericInstruction, error) {
	var (
		err    error
		buf__  = new(bytes.Buffer)
		enc__  = binary.NewBorshEncoder(buf__)
		metas_ = make(solanago.AccountMetaSlice, 18, 18+len(remaining__))
	)

	// Encode the instruction discriminator.
	if err = enc__.WriteBytes(Instruction_SwapBaseOut[:], false); err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}

	{
		// Serialize `maxAmountInParam`:
		if err = enc__.Encode(maxAmountInParam); err != nil {
			return nil, fmt.Errorf("error while marshaling maxAmountInParam:%w", err)
		}
		// Serialize `amountOutParam`:
		if err = enc__.Encode(amountOutParam); err != nil {
			return nil, fmt.Errorf("error while marshaling amountOutParam:%w", err)
		}
	}

	// Add the accounts to the instruction.
	{
		// [0] = [] token_program
		metas_[0] = solanago.NewAccountMeta(tokenProgram, false, false)
		// [1] = [writable] amm
		metas_[1] = solanago.NewAccountMeta(amm, true, false)
		// [2] = [] amm_authority
		metas_[2] = solanago.NewAccountMeta(ammAuthority, false, false)
		// [3] = [writable] amm_open_orders
		metas_[3] = solanago.NewAccountMeta(ammOpenOrders, true, false)
		// [4] = [writable] amm_target_orders
		metas_[4] = solanago.NewAccountMeta(ammTargetOrders, true, false)
		// [5] = [writable] pool_coin_token_account
		metas_[5] = solanago.NewAccountMeta(poolCoinTokenAccount, true, false)
		// [6] = [writable] pool_pc_token_account
		metas_[6] = solanago.NewAccountMeta(poolPcTokenAccount, true, false)
		// [7] = [] serum_program
		metas_[7] = solanago.NewAccountMeta(serumProgram, false, false)
		// [8] = [writable] serum_market
		metas_[8] = solanago.NewAccountMeta(serumMarket, true, false)
		// [9] = [writable] serum_bids
		metas_[9] = solanago.NewAccountMeta(serumBids, true, false)
		// [10] = [writable] serum_asks
		metas_[10] = solanago.NewAccountMeta(serumAsks, true, false)
		// [11] = [writable] serum_event_queue
		metas_[11] = solanago.NewAccountMeta(serumEventQueue, true, false)
		// [12] = [writable] serum_coin_vault_account
		metas_[12] = solanago.NewAccountMeta(serumCoinVaultAccount, true, false)
		// [13] = [writable] serum_pc_vault_account
		metas_[13] = solanago.NewAccountMeta(serumPcVaultAccount, true, false)
		// [14] = [] serum_vault_signer
		metas_[14] = solanago.NewAccountMeta(serumVaultSigner, false, false)
		// [15] = [writable] uer_source_token_account
		metas_[15] = solanago.NewAccountMeta(uerSourceTokenAccount, true, false)
		// [16] = [writable] uer_destination_token_account
		metas_[16] = solanago.NewAccountMeta(uerDestinationTokenAccount, true, false)
		// [17] = [,signer] user_source_owner
		metas_[17] = solanago.NewAccountMeta(userSourceOwner, false, true)
		// append remaining metas
		metas_ = append(metas_, remaining__...)
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		metas_,
		buf__.Bytes(),
	), nil
}

// Builds a "BuildSwapBaseOut" instruction.
func BuildSwapBaseOut(
	// Params:
	maxAmountInParam uint64,
	amountOutParam uint64,

	// Accounts:
	tokenProgram solanago.PublicKey,
	amm solanago.PublicKey,
	ammAuthority solanago.PublicKey,
	ammOpenOrders solanago.PublicKey,
	ammTargetOrders solanago.PublicKey,
	poolCoinTokenAccount solanago.PublicKey,
	poolPcTokenAccount solanago.PublicKey,
	serumProgram solanago.PublicKey,
	serumMarket solanago.PublicKey,
	serumBids solanago.PublicKey,
	serumAsks solanago.PublicKey,
	serumEventQueue solanago.PublicKey,
	serumCoinVaultAccount solanago.PublicKey,
	serumPcVaultAccount solanago.PublicKey,
	serumVaultSigner solanago.PublicKey,
	uerSourceTokenAccount solanago.PublicKey,
	uerDestinationTokenAccount solanago.PublicKey,
	userSourceOwner solanago.PublicKey,
	remaining__ ...*solanago.AccountMeta,
) *solanago.GenericInstruction {
	instruction_, _ := NewSwapBaseOutInstruction(
		maxAmountInParam,
		amountOutParam,
		tokenProgram,
		amm,
		ammAuthority,
		ammOpenOrders,
		ammTargetOrders,
		poolCoinTokenAccount,
		poolPcTokenAccount,
		serumProgram,
		serumMarket,
		serumBids,
		serumAsks,
		serumEventQueue,
		serumCoinVaultAccount,
		serumPcVaultAccount,
		serumVaultSigner,
		uerSourceTokenAccount,
		uerDestinationTokenAccount,
		userSourceOwner,
		remaining__...,
	)
	return instruction_
}
