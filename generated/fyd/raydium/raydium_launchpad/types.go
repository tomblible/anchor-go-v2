// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains parsers for the types defined in the IDL.

package raydium_launchpad

import (
	"bytes"
	"fmt"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

type Instruction interface {
	TypeID() binary.TypeID
	SetAccounts(accounts solanago.PublicKeySlice) error
	Copy() Instruction
}

type AmmFeeOn binary.BorshEnum

const (
	AmmFeeOn_QuoteToken AmmFeeOn = iota
	AmmFeeOn_BothToken
)

func (value AmmFeeOn) String() string {
	switch value {
	case AmmFeeOn_QuoteToken:
		return "QuoteToken"
	case AmmFeeOn_BothToken:
		return "BothToken"
	default:
		return ""
	}
}

type BondingCurveParam struct {
	// Migrate to AMM or CpSwap, 0: ammï¼Œ 1: cpswap
	MigrateType *uint8 `bin:"optional"`

	// The migrate fee on, 1 means fee on the quote token, 2 means fee on both token
	MigrateCpmmFeeOn *AmmFeeOn `bin:"optional"`

	// The supply of the token
	Supply *uint64 `bin:"optional"`

	// The total base sell of the token
	TotalBaseSell *uint64 `bin:"optional"`

	// The total quote fund raising of the token
	TotalQuoteFundRaising *uint64 `bin:"optional"`

	// total amount of tokens to be unlocked
	TotalLockedAmount *uint64 `bin:"optional"`

	// Waiting time in seconds before unlocking after fundraising ends
	CliffPeriod *uint64 `bin:"optional"`

	// Unlocking period in seconds
	UnlockPeriod *uint64 `bin:"optional"`
}

func (obj BondingCurveParam) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `MigrateType` (optional):
	{
		if obj.MigrateType == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling MigrateType optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling MigrateType optionality: %w", err)
			}
			if err = encoder.Encode(obj.MigrateType); err != nil {
				return fmt.Errorf("error while marshaling MigrateType: %w", err)
			}
		}
	}
	// Serialize `MigrateCpmmFeeOn` (optional):
	{
		if obj.MigrateCpmmFeeOn == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling MigrateCpmmFeeOn optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling MigrateCpmmFeeOn optionality: %w", err)
			}
			if err = encoder.Encode(obj.MigrateCpmmFeeOn); err != nil {
				return fmt.Errorf("error while marshaling MigrateCpmmFeeOn: %w", err)
			}
		}
	}
	// Serialize `Supply` (optional):
	{
		if obj.Supply == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling Supply optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling Supply optionality: %w", err)
			}
			if err = encoder.Encode(obj.Supply); err != nil {
				return fmt.Errorf("error while marshaling Supply: %w", err)
			}
		}
	}
	// Serialize `TotalBaseSell` (optional):
	{
		if obj.TotalBaseSell == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling TotalBaseSell optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling TotalBaseSell optionality: %w", err)
			}
			if err = encoder.Encode(obj.TotalBaseSell); err != nil {
				return fmt.Errorf("error while marshaling TotalBaseSell: %w", err)
			}
		}
	}
	// Serialize `TotalQuoteFundRaising` (optional):
	{
		if obj.TotalQuoteFundRaising == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling TotalQuoteFundRaising optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling TotalQuoteFundRaising optionality: %w", err)
			}
			if err = encoder.Encode(obj.TotalQuoteFundRaising); err != nil {
				return fmt.Errorf("error while marshaling TotalQuoteFundRaising: %w", err)
			}
		}
	}
	// Serialize `TotalLockedAmount` (optional):
	{
		if obj.TotalLockedAmount == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling TotalLockedAmount optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling TotalLockedAmount optionality: %w", err)
			}
			if err = encoder.Encode(obj.TotalLockedAmount); err != nil {
				return fmt.Errorf("error while marshaling TotalLockedAmount: %w", err)
			}
		}
	}
	// Serialize `CliffPeriod` (optional):
	{
		if obj.CliffPeriod == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling CliffPeriod optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling CliffPeriod optionality: %w", err)
			}
			if err = encoder.Encode(obj.CliffPeriod); err != nil {
				return fmt.Errorf("error while marshaling CliffPeriod: %w", err)
			}
		}
	}
	// Serialize `UnlockPeriod` (optional):
	{
		if obj.UnlockPeriod == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling UnlockPeriod optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling UnlockPeriod optionality: %w", err)
			}
			if err = encoder.Encode(obj.UnlockPeriod); err != nil {
				return fmt.Errorf("error while marshaling UnlockPeriod: %w", err)
			}
		}
	}
	return nil
}

func (obj BondingCurveParam) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding BondingCurveParam: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *BondingCurveParam) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `MigrateType` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling MigrateType:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.MigrateType); err != nil {
				return fmt.Errorf("error while unmarshaling MigrateType:%w", err)
			}
		}
	}
	// Deserialize `MigrateCpmmFeeOn` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling MigrateCpmmFeeOn:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.MigrateCpmmFeeOn); err != nil {
				return fmt.Errorf("error while unmarshaling MigrateCpmmFeeOn:%w", err)
			}
		}
	}
	// Deserialize `Supply` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling Supply:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.Supply); err != nil {
				return fmt.Errorf("error while unmarshaling Supply:%w", err)
			}
		}
	}
	// Deserialize `TotalBaseSell` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling TotalBaseSell:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.TotalBaseSell); err != nil {
				return fmt.Errorf("error while unmarshaling TotalBaseSell:%w", err)
			}
		}
	}
	// Deserialize `TotalQuoteFundRaising` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling TotalQuoteFundRaising:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.TotalQuoteFundRaising); err != nil {
				return fmt.Errorf("error while unmarshaling TotalQuoteFundRaising:%w", err)
			}
		}
	}
	// Deserialize `TotalLockedAmount` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling TotalLockedAmount:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.TotalLockedAmount); err != nil {
				return fmt.Errorf("error while unmarshaling TotalLockedAmount:%w", err)
			}
		}
	}
	// Deserialize `CliffPeriod` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling CliffPeriod:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.CliffPeriod); err != nil {
				return fmt.Errorf("error while unmarshaling CliffPeriod:%w", err)
			}
		}
	}
	// Deserialize `UnlockPeriod` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling UnlockPeriod:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.UnlockPeriod); err != nil {
				return fmt.Errorf("error while unmarshaling UnlockPeriod:%w", err)
			}
		}
	}
	return nil
}

func (obj *BondingCurveParam) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling BondingCurveParam: %w", err)
	}
	return nil
}

func UnmarshalBondingCurveParam(buf []byte) (*BondingCurveParam, error) {
	obj := new(BondingCurveParam)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ConstantCurve struct {
	Supply                uint64
	TotalBaseSell         uint64
	TotalQuoteFundRaising uint64
	MigrateType           uint8
}

func (obj ConstantCurve) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Supply`:
	if err = encoder.Encode(obj.Supply); err != nil {
		return fmt.Errorf("error while marshaling Supply:%w", err)
	}
	// Serialize `TotalBaseSell`:
	if err = encoder.Encode(obj.TotalBaseSell); err != nil {
		return fmt.Errorf("error while marshaling TotalBaseSell:%w", err)
	}
	// Serialize `TotalQuoteFundRaising`:
	if err = encoder.Encode(obj.TotalQuoteFundRaising); err != nil {
		return fmt.Errorf("error while marshaling TotalQuoteFundRaising:%w", err)
	}
	// Serialize `MigrateType`:
	if err = encoder.Encode(obj.MigrateType); err != nil {
		return fmt.Errorf("error while marshaling MigrateType:%w", err)
	}
	return nil
}

func (obj ConstantCurve) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding ConstantCurve: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *ConstantCurve) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Supply`:
	if err = decoder.Decode(&obj.Supply); err != nil {
		return fmt.Errorf("error while unmarshaling Supply:%w", err)
	}
	// Deserialize `TotalBaseSell`:
	if err = decoder.Decode(&obj.TotalBaseSell); err != nil {
		return fmt.Errorf("error while unmarshaling TotalBaseSell:%w", err)
	}
	// Deserialize `TotalQuoteFundRaising`:
	if err = decoder.Decode(&obj.TotalQuoteFundRaising); err != nil {
		return fmt.Errorf("error while unmarshaling TotalQuoteFundRaising:%w", err)
	}
	// Deserialize `MigrateType`:
	if err = decoder.Decode(&obj.MigrateType); err != nil {
		return fmt.Errorf("error while unmarshaling MigrateType:%w", err)
	}
	return nil
}

func (obj *ConstantCurve) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ConstantCurve: %w", err)
	}
	return nil
}

func UnmarshalConstantCurve(buf []byte) (*ConstantCurve, error) {
	obj := new(ConstantCurve)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// The "isCurveParams" interface for the "CurveParams" complex enum.
type CurveParams interface {
	isCurveParams()
}

type curveParamsEnumContainer struct {
	Enum     binary.BorshEnum `bin:"enum"`
	Constant CurveParams_Constant
	Fixed    CurveParams_Fixed
	Linear   CurveParams_Linear
}

func DecodeCurveParams(decoder *binary.Decoder) (CurveParams, error) {
	{
		tmp := new(curveParamsEnumContainer)
		err := decoder.Decode(tmp)
		if err != nil {
			return nil, fmt.Errorf("failed parsing CurveParams: %w", err)
		}
		switch tmp.Enum {
		case 0:
			return &tmp.Constant, nil
		case 1:
			return &tmp.Fixed, nil
		case 2:
			return &tmp.Linear, nil
		default:
			return nil, fmt.Errorf("CurveParams: unknown enum index: %v", tmp.Enum)
		}
	}
}

func EncodeCurveParams(encoder *binary.Encoder, value CurveParams) error {
	{
		tmp := curveParamsEnumContainer{}
		switch realvalue := value.(type) {
		case *CurveParams_Constant:
			tmp.Enum = 0
			tmp.Constant = *realvalue
		case *CurveParams_Fixed:
			tmp.Enum = 1
			tmp.Fixed = *realvalue
		case *CurveParams_Linear:
			tmp.Enum = 2
			tmp.Linear = *realvalue
		}
		return encoder.Encode(tmp)
	}
}

// Variant "Constant" of enum "CurveParams"
type CurveParams_Constant struct {
	Data ConstantCurve `json:"data"`
}

func (obj CurveParams_Constant) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Data`:
	if err = encoder.Encode(obj.Data); err != nil {
		return fmt.Errorf("error while marshaling Data:%w", err)
	}
	return nil
}

func (obj CurveParams_Constant) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding CurveParams_Constant: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *CurveParams_Constant) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Data`:
	if err = decoder.Decode(&obj.Data); err != nil {
		return fmt.Errorf("error while unmarshaling Data:%w", err)
	}
	return nil
}

func (obj *CurveParams_Constant) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CurveParams_Constant: %w", err)
	}
	return nil
}

func UnmarshalCurveParams_Constant(buf []byte) (*CurveParams_Constant, error) {
	obj := new(CurveParams_Constant)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *CurveParams_Constant) isCurveParams() {}

// Variant "Fixed" of enum "CurveParams"
type CurveParams_Fixed struct {
	Data FixedCurve `json:"data"`
}

func (obj CurveParams_Fixed) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Data`:
	if err = encoder.Encode(obj.Data); err != nil {
		return fmt.Errorf("error while marshaling Data:%w", err)
	}
	return nil
}

func (obj CurveParams_Fixed) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding CurveParams_Fixed: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *CurveParams_Fixed) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Data`:
	if err = decoder.Decode(&obj.Data); err != nil {
		return fmt.Errorf("error while unmarshaling Data:%w", err)
	}
	return nil
}

func (obj *CurveParams_Fixed) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CurveParams_Fixed: %w", err)
	}
	return nil
}

func UnmarshalCurveParams_Fixed(buf []byte) (*CurveParams_Fixed, error) {
	obj := new(CurveParams_Fixed)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *CurveParams_Fixed) isCurveParams() {}

// Variant "Linear" of enum "CurveParams"
type CurveParams_Linear struct {
	Data LinearCurve `json:"data"`
}

func (obj CurveParams_Linear) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Data`:
	if err = encoder.Encode(obj.Data); err != nil {
		return fmt.Errorf("error while marshaling Data:%w", err)
	}
	return nil
}

func (obj CurveParams_Linear) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding CurveParams_Linear: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *CurveParams_Linear) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Data`:
	if err = decoder.Decode(&obj.Data); err != nil {
		return fmt.Errorf("error while unmarshaling Data:%w", err)
	}
	return nil
}

func (obj *CurveParams_Linear) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CurveParams_Linear: %w", err)
	}
	return nil
}

func UnmarshalCurveParams_Linear(buf []byte) (*CurveParams_Linear, error) {
	obj := new(CurveParams_Linear)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *CurveParams_Linear) isCurveParams() {}

type FixedCurve struct {
	Supply                uint64
	TotalQuoteFundRaising uint64
	MigrateType           uint8
}

func (obj FixedCurve) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Supply`:
	if err = encoder.Encode(obj.Supply); err != nil {
		return fmt.Errorf("error while marshaling Supply:%w", err)
	}
	// Serialize `TotalQuoteFundRaising`:
	if err = encoder.Encode(obj.TotalQuoteFundRaising); err != nil {
		return fmt.Errorf("error while marshaling TotalQuoteFundRaising:%w", err)
	}
	// Serialize `MigrateType`:
	if err = encoder.Encode(obj.MigrateType); err != nil {
		return fmt.Errorf("error while marshaling MigrateType:%w", err)
	}
	return nil
}

func (obj FixedCurve) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding FixedCurve: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *FixedCurve) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Supply`:
	if err = decoder.Decode(&obj.Supply); err != nil {
		return fmt.Errorf("error while unmarshaling Supply:%w", err)
	}
	// Deserialize `TotalQuoteFundRaising`:
	if err = decoder.Decode(&obj.TotalQuoteFundRaising); err != nil {
		return fmt.Errorf("error while unmarshaling TotalQuoteFundRaising:%w", err)
	}
	// Deserialize `MigrateType`:
	if err = decoder.Decode(&obj.MigrateType); err != nil {
		return fmt.Errorf("error while unmarshaling MigrateType:%w", err)
	}
	return nil
}

func (obj *FixedCurve) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling FixedCurve: %w", err)
	}
	return nil
}

func UnmarshalFixedCurve(buf []byte) (*FixedCurve, error) {
	obj := new(FixedCurve)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type LinearCurve struct {
	Supply                uint64
	TotalQuoteFundRaising uint64
	MigrateType           uint8
}

func (obj LinearCurve) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Supply`:
	if err = encoder.Encode(obj.Supply); err != nil {
		return fmt.Errorf("error while marshaling Supply:%w", err)
	}
	// Serialize `TotalQuoteFundRaising`:
	if err = encoder.Encode(obj.TotalQuoteFundRaising); err != nil {
		return fmt.Errorf("error while marshaling TotalQuoteFundRaising:%w", err)
	}
	// Serialize `MigrateType`:
	if err = encoder.Encode(obj.MigrateType); err != nil {
		return fmt.Errorf("error while marshaling MigrateType:%w", err)
	}
	return nil
}

func (obj LinearCurve) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding LinearCurve: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *LinearCurve) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Supply`:
	if err = decoder.Decode(&obj.Supply); err != nil {
		return fmt.Errorf("error while unmarshaling Supply:%w", err)
	}
	// Deserialize `TotalQuoteFundRaising`:
	if err = decoder.Decode(&obj.TotalQuoteFundRaising); err != nil {
		return fmt.Errorf("error while unmarshaling TotalQuoteFundRaising:%w", err)
	}
	// Deserialize `MigrateType`:
	if err = decoder.Decode(&obj.MigrateType); err != nil {
		return fmt.Errorf("error while unmarshaling MigrateType:%w", err)
	}
	return nil
}

func (obj *LinearCurve) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling LinearCurve: %w", err)
	}
	return nil
}

func UnmarshalLinearCurve(buf []byte) (*LinearCurve, error) {
	obj := new(LinearCurve)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Represents the parameters for initializing a platform config account(Only support MigrateType::CPSWAP)
// # Fields
// * `platform_scale` - Scale of the platform liquidity quantity rights will be converted into NFT
// * `creator_scale` - Scale of the token creator liquidity quantity rights will be converted into NFT
// * `burn_scale` - Scale of liquidity directly to burn
//
// * platform_scale + creator_scale + burn_scale = RATE_DENOMINATOR_VALUE
type MigrateNftInfo struct {
	PlatformScale uint64
	CreatorScale  uint64
	BurnScale     uint64
}

func (obj MigrateNftInfo) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `PlatformScale`:
	if err = encoder.Encode(obj.PlatformScale); err != nil {
		return fmt.Errorf("error while marshaling PlatformScale:%w", err)
	}
	// Serialize `CreatorScale`:
	if err = encoder.Encode(obj.CreatorScale); err != nil {
		return fmt.Errorf("error while marshaling CreatorScale:%w", err)
	}
	// Serialize `BurnScale`:
	if err = encoder.Encode(obj.BurnScale); err != nil {
		return fmt.Errorf("error while marshaling BurnScale:%w", err)
	}
	return nil
}

func (obj MigrateNftInfo) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding MigrateNftInfo: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *MigrateNftInfo) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `PlatformScale`:
	if err = decoder.Decode(&obj.PlatformScale); err != nil {
		return fmt.Errorf("error while unmarshaling PlatformScale:%w", err)
	}
	// Deserialize `CreatorScale`:
	if err = decoder.Decode(&obj.CreatorScale); err != nil {
		return fmt.Errorf("error while unmarshaling CreatorScale:%w", err)
	}
	// Deserialize `BurnScale`:
	if err = decoder.Decode(&obj.BurnScale); err != nil {
		return fmt.Errorf("error while unmarshaling BurnScale:%w", err)
	}
	return nil
}

func (obj *MigrateNftInfo) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling MigrateNftInfo: %w", err)
	}
	return nil
}

func UnmarshalMigrateNftInfo(buf []byte) (*MigrateNftInfo, error) {
	obj := new(MigrateNftInfo)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Represents the parameters for initializing a new token mint
// # Fields
// * `decimals` - Number of decimal places for the token
// * `name` - Name of the token
// * `symbol` - Symbol/ticker of the token
// * `uri` - URI pointing to token metadata
type MintParams struct {
	Decimals uint8
	Name     string
	Symbol   string
	Uri      string
}

func (obj MintParams) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Decimals`:
	if err = encoder.Encode(obj.Decimals); err != nil {
		return fmt.Errorf("error while marshaling Decimals:%w", err)
	}
	// Serialize `Name`:
	if err = encoder.Encode(obj.Name); err != nil {
		return fmt.Errorf("error while marshaling Name:%w", err)
	}
	// Serialize `Symbol`:
	if err = encoder.Encode(obj.Symbol); err != nil {
		return fmt.Errorf("error while marshaling Symbol:%w", err)
	}
	// Serialize `Uri`:
	if err = encoder.Encode(obj.Uri); err != nil {
		return fmt.Errorf("error while marshaling Uri:%w", err)
	}
	return nil
}

func (obj MintParams) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding MintParams: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *MintParams) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Decimals`:
	if err = decoder.Decode(&obj.Decimals); err != nil {
		return fmt.Errorf("error while unmarshaling Decimals:%w", err)
	}
	// Deserialize `Name`:
	if err = decoder.Decode(&obj.Name); err != nil {
		return fmt.Errorf("error while unmarshaling Name:%w", err)
	}
	// Deserialize `Symbol`:
	if err = decoder.Decode(&obj.Symbol); err != nil {
		return fmt.Errorf("error while unmarshaling Symbol:%w", err)
	}
	// Deserialize `Uri`:
	if err = decoder.Decode(&obj.Uri); err != nil {
		return fmt.Errorf("error while unmarshaling Uri:%w", err)
	}
	return nil
}

func (obj *MintParams) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling MintParams: %w", err)
	}
	return nil
}

func UnmarshalMintParams(buf []byte) (*MintParams, error) {
	obj := new(MintParams)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type PlatformConfigInfo struct {
	FeeWallet                solanago.PublicKey
	NftWallet                solanago.PublicKey
	MigrateNftInfo           MigrateNftInfo
	FeeRate                  uint64
	Name                     string
	Web                      string
	Img                      string
	TransferFeeExtensionAuth solanago.PublicKey
	CreatorFeeRate           uint64
}

func (obj PlatformConfigInfo) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `FeeWallet`:
	if err = encoder.Encode(obj.FeeWallet); err != nil {
		return fmt.Errorf("error while marshaling FeeWallet:%w", err)
	}
	// Serialize `NftWallet`:
	if err = encoder.Encode(obj.NftWallet); err != nil {
		return fmt.Errorf("error while marshaling NftWallet:%w", err)
	}
	// Serialize `MigrateNftInfo`:
	if err = encoder.Encode(obj.MigrateNftInfo); err != nil {
		return fmt.Errorf("error while marshaling MigrateNftInfo:%w", err)
	}
	// Serialize `FeeRate`:
	if err = encoder.Encode(obj.FeeRate); err != nil {
		return fmt.Errorf("error while marshaling FeeRate:%w", err)
	}
	// Serialize `Name`:
	if err = encoder.Encode(obj.Name); err != nil {
		return fmt.Errorf("error while marshaling Name:%w", err)
	}
	// Serialize `Web`:
	if err = encoder.Encode(obj.Web); err != nil {
		return fmt.Errorf("error while marshaling Web:%w", err)
	}
	// Serialize `Img`:
	if err = encoder.Encode(obj.Img); err != nil {
		return fmt.Errorf("error while marshaling Img:%w", err)
	}
	// Serialize `TransferFeeExtensionAuth`:
	if err = encoder.Encode(obj.TransferFeeExtensionAuth); err != nil {
		return fmt.Errorf("error while marshaling TransferFeeExtensionAuth:%w", err)
	}
	// Serialize `CreatorFeeRate`:
	if err = encoder.Encode(obj.CreatorFeeRate); err != nil {
		return fmt.Errorf("error while marshaling CreatorFeeRate:%w", err)
	}
	return nil
}

func (obj PlatformConfigInfo) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding PlatformConfigInfo: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *PlatformConfigInfo) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `FeeWallet`:
	if err = decoder.Decode(&obj.FeeWallet); err != nil {
		return fmt.Errorf("error while unmarshaling FeeWallet:%w", err)
	}
	// Deserialize `NftWallet`:
	if err = decoder.Decode(&obj.NftWallet); err != nil {
		return fmt.Errorf("error while unmarshaling NftWallet:%w", err)
	}
	// Deserialize `MigrateNftInfo`:
	if err = decoder.Decode(&obj.MigrateNftInfo); err != nil {
		return fmt.Errorf("error while unmarshaling MigrateNftInfo:%w", err)
	}
	// Deserialize `FeeRate`:
	if err = decoder.Decode(&obj.FeeRate); err != nil {
		return fmt.Errorf("error while unmarshaling FeeRate:%w", err)
	}
	// Deserialize `Name`:
	if err = decoder.Decode(&obj.Name); err != nil {
		return fmt.Errorf("error while unmarshaling Name:%w", err)
	}
	// Deserialize `Web`:
	if err = decoder.Decode(&obj.Web); err != nil {
		return fmt.Errorf("error while unmarshaling Web:%w", err)
	}
	// Deserialize `Img`:
	if err = decoder.Decode(&obj.Img); err != nil {
		return fmt.Errorf("error while unmarshaling Img:%w", err)
	}
	// Deserialize `TransferFeeExtensionAuth`:
	if err = decoder.Decode(&obj.TransferFeeExtensionAuth); err != nil {
		return fmt.Errorf("error while unmarshaling TransferFeeExtensionAuth:%w", err)
	}
	// Deserialize `CreatorFeeRate`:
	if err = decoder.Decode(&obj.CreatorFeeRate); err != nil {
		return fmt.Errorf("error while unmarshaling CreatorFeeRate:%w", err)
	}
	return nil
}

func (obj *PlatformConfigInfo) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling PlatformConfigInfo: %w", err)
	}
	return nil
}

func UnmarshalPlatformConfigInfo(buf []byte) (*PlatformConfigInfo, error) {
	obj := new(PlatformConfigInfo)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// The "isPlatformConfigParam" interface for the "PlatformConfigParam" complex enum.
type PlatformConfigParam interface {
	isPlatformConfigParam()
}

type platformConfigParamEnumContainer struct {
	Enum           binary.BorshEnum `bin:"enum"`
	FeeWallet      PlatformConfigParam_FeeWallet
	NftWallet      PlatformConfigParam_NftWallet
	MigrateNftInfo PlatformConfigParam_MigrateNftInfo
	FeeRate        PlatformConfigParam_FeeRate
	Name           PlatformConfigParam_Name
	Web            PlatformConfigParam_Web
	Img            PlatformConfigParam_Img
	CpSwapConfig   PlatformConfigParam_CpSwapConfig
	AllInfo        PlatformConfigParam_AllInfo
}

func DecodePlatformConfigParam(decoder *binary.Decoder) (PlatformConfigParam, error) {
	{
		tmp := new(platformConfigParamEnumContainer)
		err := decoder.Decode(tmp)
		if err != nil {
			return nil, fmt.Errorf("failed parsing PlatformConfigParam: %w", err)
		}
		switch tmp.Enum {
		case 0:
			return &tmp.FeeWallet, nil
		case 1:
			return &tmp.NftWallet, nil
		case 2:
			return &tmp.MigrateNftInfo, nil
		case 3:
			return &tmp.FeeRate, nil
		case 4:
			return &tmp.Name, nil
		case 5:
			return &tmp.Web, nil
		case 6:
			return &tmp.Img, nil
		case 7:
			return (*PlatformConfigParam_CpSwapConfig)(&tmp.Enum), nil
		case 8:
			return &tmp.AllInfo, nil
		default:
			return nil, fmt.Errorf("PlatformConfigParam: unknown enum index: %v", tmp.Enum)
		}
	}
}

func EncodePlatformConfigParam(encoder *binary.Encoder, value PlatformConfigParam) error {
	{
		tmp := platformConfigParamEnumContainer{}
		switch realvalue := value.(type) {
		case *PlatformConfigParam_FeeWallet:
			tmp.Enum = 0
			tmp.FeeWallet = *realvalue
		case *PlatformConfigParam_NftWallet:
			tmp.Enum = 1
			tmp.NftWallet = *realvalue
		case *PlatformConfigParam_MigrateNftInfo:
			tmp.Enum = 2
			tmp.MigrateNftInfo = *realvalue
		case *PlatformConfigParam_FeeRate:
			tmp.Enum = 3
			tmp.FeeRate = *realvalue
		case *PlatformConfigParam_Name:
			tmp.Enum = 4
			tmp.Name = *realvalue
		case *PlatformConfigParam_Web:
			tmp.Enum = 5
			tmp.Web = *realvalue
		case *PlatformConfigParam_Img:
			tmp.Enum = 6
			tmp.Img = *realvalue
		case *PlatformConfigParam_CpSwapConfig:
			tmp.Enum = 7
			tmp.CpSwapConfig = *realvalue
		case *PlatformConfigParam_AllInfo:
			tmp.Enum = 8
			tmp.AllInfo = *realvalue
		}
		return encoder.Encode(tmp)
	}
}

// Variant "FeeWallet" of enum "PlatformConfigParam"
type PlatformConfigParam_FeeWallet struct {
	V0 solanago.PublicKey `json:"v0"`
}

func (obj PlatformConfigParam_FeeWallet) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `V0`:
	if err = encoder.Encode(obj.V0); err != nil {
		return fmt.Errorf("error while marshaling V0:%w", err)
	}
	return nil
}

func (obj PlatformConfigParam_FeeWallet) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding PlatformConfigParam_FeeWallet: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *PlatformConfigParam_FeeWallet) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `V0`:
	if err = decoder.Decode(&obj.V0); err != nil {
		return fmt.Errorf("error while unmarshaling V0:%w", err)
	}
	return nil
}

func (obj *PlatformConfigParam_FeeWallet) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling PlatformConfigParam_FeeWallet: %w", err)
	}
	return nil
}

func UnmarshalPlatformConfigParam_FeeWallet(buf []byte) (*PlatformConfigParam_FeeWallet, error) {
	obj := new(PlatformConfigParam_FeeWallet)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *PlatformConfigParam_FeeWallet) isPlatformConfigParam() {}

// Variant "NFTWallet" of enum "PlatformConfigParam"
type PlatformConfigParam_NftWallet struct {
	V0 solanago.PublicKey `json:"v0"`
}

func (obj PlatformConfigParam_NftWallet) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `V0`:
	if err = encoder.Encode(obj.V0); err != nil {
		return fmt.Errorf("error while marshaling V0:%w", err)
	}
	return nil
}

func (obj PlatformConfigParam_NftWallet) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding PlatformConfigParam_NftWallet: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *PlatformConfigParam_NftWallet) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `V0`:
	if err = decoder.Decode(&obj.V0); err != nil {
		return fmt.Errorf("error while unmarshaling V0:%w", err)
	}
	return nil
}

func (obj *PlatformConfigParam_NftWallet) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling PlatformConfigParam_NftWallet: %w", err)
	}
	return nil
}

func UnmarshalPlatformConfigParam_NftWallet(buf []byte) (*PlatformConfigParam_NftWallet, error) {
	obj := new(PlatformConfigParam_NftWallet)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *PlatformConfigParam_NftWallet) isPlatformConfigParam() {}

// Variant "MigrateNftInfo" of enum "PlatformConfigParam"
type PlatformConfigParam_MigrateNftInfo struct {
	V0 MigrateNftInfo `json:"v0"`
}

func (obj PlatformConfigParam_MigrateNftInfo) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `V0`:
	if err = encoder.Encode(obj.V0); err != nil {
		return fmt.Errorf("error while marshaling V0:%w", err)
	}
	return nil
}

func (obj PlatformConfigParam_MigrateNftInfo) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding PlatformConfigParam_MigrateNftInfo: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *PlatformConfigParam_MigrateNftInfo) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `V0`:
	if err = decoder.Decode(&obj.V0); err != nil {
		return fmt.Errorf("error while unmarshaling V0:%w", err)
	}
	return nil
}

func (obj *PlatformConfigParam_MigrateNftInfo) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling PlatformConfigParam_MigrateNftInfo: %w", err)
	}
	return nil
}

func UnmarshalPlatformConfigParam_MigrateNftInfo(buf []byte) (*PlatformConfigParam_MigrateNftInfo, error) {
	obj := new(PlatformConfigParam_MigrateNftInfo)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *PlatformConfigParam_MigrateNftInfo) isPlatformConfigParam() {}

// Variant "FeeRate" of enum "PlatformConfigParam"
type PlatformConfigParam_FeeRate struct {
	V0 uint64 `json:"v0"`
}

func (obj PlatformConfigParam_FeeRate) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `V0`:
	if err = encoder.Encode(obj.V0); err != nil {
		return fmt.Errorf("error while marshaling V0:%w", err)
	}
	return nil
}

func (obj PlatformConfigParam_FeeRate) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding PlatformConfigParam_FeeRate: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *PlatformConfigParam_FeeRate) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `V0`:
	if err = decoder.Decode(&obj.V0); err != nil {
		return fmt.Errorf("error while unmarshaling V0:%w", err)
	}
	return nil
}

func (obj *PlatformConfigParam_FeeRate) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling PlatformConfigParam_FeeRate: %w", err)
	}
	return nil
}

func UnmarshalPlatformConfigParam_FeeRate(buf []byte) (*PlatformConfigParam_FeeRate, error) {
	obj := new(PlatformConfigParam_FeeRate)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *PlatformConfigParam_FeeRate) isPlatformConfigParam() {}

// Variant "Name" of enum "PlatformConfigParam"
type PlatformConfigParam_Name struct {
	V0 string `json:"v0"`
}

func (obj PlatformConfigParam_Name) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `V0`:
	if err = encoder.Encode(obj.V0); err != nil {
		return fmt.Errorf("error while marshaling V0:%w", err)
	}
	return nil
}

func (obj PlatformConfigParam_Name) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding PlatformConfigParam_Name: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *PlatformConfigParam_Name) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `V0`:
	if err = decoder.Decode(&obj.V0); err != nil {
		return fmt.Errorf("error while unmarshaling V0:%w", err)
	}
	return nil
}

func (obj *PlatformConfigParam_Name) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling PlatformConfigParam_Name: %w", err)
	}
	return nil
}

func UnmarshalPlatformConfigParam_Name(buf []byte) (*PlatformConfigParam_Name, error) {
	obj := new(PlatformConfigParam_Name)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *PlatformConfigParam_Name) isPlatformConfigParam() {}

// Variant "Web" of enum "PlatformConfigParam"
type PlatformConfigParam_Web struct {
	V0 string `json:"v0"`
}

func (obj PlatformConfigParam_Web) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `V0`:
	if err = encoder.Encode(obj.V0); err != nil {
		return fmt.Errorf("error while marshaling V0:%w", err)
	}
	return nil
}

func (obj PlatformConfigParam_Web) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding PlatformConfigParam_Web: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *PlatformConfigParam_Web) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `V0`:
	if err = decoder.Decode(&obj.V0); err != nil {
		return fmt.Errorf("error while unmarshaling V0:%w", err)
	}
	return nil
}

func (obj *PlatformConfigParam_Web) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling PlatformConfigParam_Web: %w", err)
	}
	return nil
}

func UnmarshalPlatformConfigParam_Web(buf []byte) (*PlatformConfigParam_Web, error) {
	obj := new(PlatformConfigParam_Web)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *PlatformConfigParam_Web) isPlatformConfigParam() {}

// Variant "Img" of enum "PlatformConfigParam"
type PlatformConfigParam_Img struct {
	V0 string `json:"v0"`
}

func (obj PlatformConfigParam_Img) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `V0`:
	if err = encoder.Encode(obj.V0); err != nil {
		return fmt.Errorf("error while marshaling V0:%w", err)
	}
	return nil
}

func (obj PlatformConfigParam_Img) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding PlatformConfigParam_Img: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *PlatformConfigParam_Img) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `V0`:
	if err = decoder.Decode(&obj.V0); err != nil {
		return fmt.Errorf("error while unmarshaling V0:%w", err)
	}
	return nil
}

func (obj *PlatformConfigParam_Img) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling PlatformConfigParam_Img: %w", err)
	}
	return nil
}

func UnmarshalPlatformConfigParam_Img(buf []byte) (*PlatformConfigParam_Img, error) {
	obj := new(PlatformConfigParam_Img)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *PlatformConfigParam_Img) isPlatformConfigParam() {}

type PlatformConfigParam_CpSwapConfig uint8

func (obj PlatformConfigParam_CpSwapConfig) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *PlatformConfigParam_CpSwapConfig) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (_ *PlatformConfigParam_CpSwapConfig) isPlatformConfigParam() {}

// Variant "AllInfo" of enum "PlatformConfigParam"
type PlatformConfigParam_AllInfo struct {
	V0 PlatformConfigInfo `json:"v0"`
}

func (obj PlatformConfigParam_AllInfo) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `V0`:
	if err = encoder.Encode(obj.V0); err != nil {
		return fmt.Errorf("error while marshaling V0:%w", err)
	}
	return nil
}

func (obj PlatformConfigParam_AllInfo) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding PlatformConfigParam_AllInfo: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *PlatformConfigParam_AllInfo) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `V0`:
	if err = decoder.Decode(&obj.V0); err != nil {
		return fmt.Errorf("error while unmarshaling V0:%w", err)
	}
	return nil
}

func (obj *PlatformConfigParam_AllInfo) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling PlatformConfigParam_AllInfo: %w", err)
	}
	return nil
}

func UnmarshalPlatformConfigParam_AllInfo(buf []byte) (*PlatformConfigParam_AllInfo, error) {
	obj := new(PlatformConfigParam_AllInfo)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *PlatformConfigParam_AllInfo) isPlatformConfigParam() {}

type PlatformCurveParam struct {
	// The epoch for update interval, 0 means not update
	Epoch uint64

	// The curve params index
	Index uint8

	// The global config address
	GlobalConfig solanago.PublicKey

	// bonding curve param
	BondingCurveParam BondingCurveParam

	// padding for future updates
	Padding [50]uint64
}

func (obj PlatformCurveParam) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Epoch`:
	if err = encoder.Encode(obj.Epoch); err != nil {
		return fmt.Errorf("error while marshaling Epoch:%w", err)
	}
	// Serialize `Index`:
	if err = encoder.Encode(obj.Index); err != nil {
		return fmt.Errorf("error while marshaling Index:%w", err)
	}
	// Serialize `GlobalConfig`:
	if err = encoder.Encode(obj.GlobalConfig); err != nil {
		return fmt.Errorf("error while marshaling GlobalConfig:%w", err)
	}
	// Serialize `BondingCurveParam`:
	if err = encoder.Encode(obj.BondingCurveParam); err != nil {
		return fmt.Errorf("error while marshaling BondingCurveParam:%w", err)
	}
	// Serialize `Padding`:
	if err = encoder.Encode(obj.Padding); err != nil {
		return fmt.Errorf("error while marshaling Padding:%w", err)
	}
	return nil
}

func (obj PlatformCurveParam) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding PlatformCurveParam: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *PlatformCurveParam) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Epoch`:
	if err = decoder.Decode(&obj.Epoch); err != nil {
		return fmt.Errorf("error while unmarshaling Epoch:%w", err)
	}
	// Deserialize `Index`:
	if err = decoder.Decode(&obj.Index); err != nil {
		return fmt.Errorf("error while unmarshaling Index:%w", err)
	}
	// Deserialize `GlobalConfig`:
	if err = decoder.Decode(&obj.GlobalConfig); err != nil {
		return fmt.Errorf("error while unmarshaling GlobalConfig:%w", err)
	}
	// Deserialize `BondingCurveParam`:
	if err = decoder.Decode(&obj.BondingCurveParam); err != nil {
		return fmt.Errorf("error while unmarshaling BondingCurveParam:%w", err)
	}
	// Deserialize `Padding`:
	if err = decoder.Decode(&obj.Padding); err != nil {
		return fmt.Errorf("error while unmarshaling Padding:%w", err)
	}
	return nil
}

func (obj *PlatformCurveParam) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling PlatformCurveParam: %w", err)
	}
	return nil
}

func UnmarshalPlatformCurveParam(buf []byte) (*PlatformCurveParam, error) {
	obj := new(PlatformCurveParam)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Represents the parameters for initializing a platform config account
// # Fields
// * `migrate_nft_info` - The platform configures liquidity info during migration(Only support MigrateType::CPSWAP)
// * `fee_rate` - Fee rate of the platform
// * `name` - Name of the platform
// * `web` - Website of the platform
// * `img` - Image link of the platform
// / * `creator_fee_rate` - The fee rate charged by the creator for each transaction.
type PlatformParams struct {
	MigrateNftInfo MigrateNftInfo
	FeeRate        uint64
	Name           string
	Web            string
	Img            string
	CreatorFeeRate uint64
}

func (obj PlatformParams) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `MigrateNftInfo`:
	if err = encoder.Encode(obj.MigrateNftInfo); err != nil {
		return fmt.Errorf("error while marshaling MigrateNftInfo:%w", err)
	}
	// Serialize `FeeRate`:
	if err = encoder.Encode(obj.FeeRate); err != nil {
		return fmt.Errorf("error while marshaling FeeRate:%w", err)
	}
	// Serialize `Name`:
	if err = encoder.Encode(obj.Name); err != nil {
		return fmt.Errorf("error while marshaling Name:%w", err)
	}
	// Serialize `Web`:
	if err = encoder.Encode(obj.Web); err != nil {
		return fmt.Errorf("error while marshaling Web:%w", err)
	}
	// Serialize `Img`:
	if err = encoder.Encode(obj.Img); err != nil {
		return fmt.Errorf("error while marshaling Img:%w", err)
	}
	// Serialize `CreatorFeeRate`:
	if err = encoder.Encode(obj.CreatorFeeRate); err != nil {
		return fmt.Errorf("error while marshaling CreatorFeeRate:%w", err)
	}
	return nil
}

func (obj PlatformParams) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding PlatformParams: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *PlatformParams) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `MigrateNftInfo`:
	if err = decoder.Decode(&obj.MigrateNftInfo); err != nil {
		return fmt.Errorf("error while unmarshaling MigrateNftInfo:%w", err)
	}
	// Deserialize `FeeRate`:
	if err = decoder.Decode(&obj.FeeRate); err != nil {
		return fmt.Errorf("error while unmarshaling FeeRate:%w", err)
	}
	// Deserialize `Name`:
	if err = decoder.Decode(&obj.Name); err != nil {
		return fmt.Errorf("error while unmarshaling Name:%w", err)
	}
	// Deserialize `Web`:
	if err = decoder.Decode(&obj.Web); err != nil {
		return fmt.Errorf("error while unmarshaling Web:%w", err)
	}
	// Deserialize `Img`:
	if err = decoder.Decode(&obj.Img); err != nil {
		return fmt.Errorf("error while unmarshaling Img:%w", err)
	}
	// Deserialize `CreatorFeeRate`:
	if err = decoder.Decode(&obj.CreatorFeeRate); err != nil {
		return fmt.Errorf("error while unmarshaling CreatorFeeRate:%w", err)
	}
	return nil
}

func (obj *PlatformParams) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling PlatformParams: %w", err)
	}
	return nil
}

func UnmarshalPlatformParams(buf []byte) (*PlatformParams, error) {
	obj := new(PlatformParams)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Represents the different states a pool can be in
// * Fund - Initial state where pool is accepting funds
// * Migrate - Pool funding has ended and waiting for migration
// * Trade - Pool migration is complete and amm trading is enabled
type PoolStatus binary.BorshEnum

const (
	PoolStatus_Fund PoolStatus = iota
	PoolStatus_Migrate
	PoolStatus_Trade
)

func (value PoolStatus) String() string {
	switch value {
	case PoolStatus_Fund:
		return "Fund"
	case PoolStatus_Migrate:
		return "Migrate"
	case PoolStatus_Trade:
		return "Trade"
	default:
		return ""
	}
}

// Specifies the direction of a trade in the bonding curve
// This is important because curves can treat tokens differently through weights or offsets
type TradeDirection binary.BorshEnum

const (
	TradeDirection_Buy TradeDirection = iota
	TradeDirection_Sell
)

func (value TradeDirection) String() string {
	switch value {
	case TradeDirection_Buy:
		return "Buy"
	case TradeDirection_Sell:
		return "Sell"
	default:
		return ""
	}
}

type TransferFeeExtensionParams struct {
	// denominator is 10000, currently, this value cannot exceed 5%, which is 500.
	TransferFeeBasisPoints uint16

	// Maximum fee on each transfers, the value must exceed supply * transfer_fee_basis_points / 10000
	MaximumFee uint64
}

func (obj TransferFeeExtensionParams) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `TransferFeeBasisPoints`:
	if err = encoder.Encode(obj.TransferFeeBasisPoints); err != nil {
		return fmt.Errorf("error while marshaling TransferFeeBasisPoints:%w", err)
	}
	// Serialize `MaximumFee`:
	if err = encoder.Encode(obj.MaximumFee); err != nil {
		return fmt.Errorf("error while marshaling MaximumFee:%w", err)
	}
	return nil
}

func (obj TransferFeeExtensionParams) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding TransferFeeExtensionParams: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *TransferFeeExtensionParams) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `TransferFeeBasisPoints`:
	if err = decoder.Decode(&obj.TransferFeeBasisPoints); err != nil {
		return fmt.Errorf("error while unmarshaling TransferFeeBasisPoints:%w", err)
	}
	// Deserialize `MaximumFee`:
	if err = decoder.Decode(&obj.MaximumFee); err != nil {
		return fmt.Errorf("error while unmarshaling MaximumFee:%w", err)
	}
	return nil
}

func (obj *TransferFeeExtensionParams) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling TransferFeeExtensionParams: %w", err)
	}
	return nil
}

func UnmarshalTransferFeeExtensionParams(buf []byte) (*TransferFeeExtensionParams, error) {
	obj := new(TransferFeeExtensionParams)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type VestingParams struct {
	TotalLockedAmount uint64
	CliffPeriod       uint64
	UnlockPeriod      uint64
}

func (obj VestingParams) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `TotalLockedAmount`:
	if err = encoder.Encode(obj.TotalLockedAmount); err != nil {
		return fmt.Errorf("error while marshaling TotalLockedAmount:%w", err)
	}
	// Serialize `CliffPeriod`:
	if err = encoder.Encode(obj.CliffPeriod); err != nil {
		return fmt.Errorf("error while marshaling CliffPeriod:%w", err)
	}
	// Serialize `UnlockPeriod`:
	if err = encoder.Encode(obj.UnlockPeriod); err != nil {
		return fmt.Errorf("error while marshaling UnlockPeriod:%w", err)
	}
	return nil
}

func (obj VestingParams) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding VestingParams: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *VestingParams) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `TotalLockedAmount`:
	if err = decoder.Decode(&obj.TotalLockedAmount); err != nil {
		return fmt.Errorf("error while unmarshaling TotalLockedAmount:%w", err)
	}
	// Deserialize `CliffPeriod`:
	if err = decoder.Decode(&obj.CliffPeriod); err != nil {
		return fmt.Errorf("error while unmarshaling CliffPeriod:%w", err)
	}
	// Deserialize `UnlockPeriod`:
	if err = decoder.Decode(&obj.UnlockPeriod); err != nil {
		return fmt.Errorf("error while unmarshaling UnlockPeriod:%w", err)
	}
	return nil
}

func (obj *VestingParams) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling VestingParams: %w", err)
	}
	return nil
}

func UnmarshalVestingParams(buf []byte) (*VestingParams, error) {
	obj := new(VestingParams)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type VestingSchedule struct {
	TotalLockedAmount uint64
	CliffPeriod       uint64
	UnlockPeriod      uint64
	StartTime         uint64

	// Total allocated share amount of the base token, not greater than total_locked_amount
	AllocatedShareAmount uint64
}

func (obj VestingSchedule) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `TotalLockedAmount`:
	if err = encoder.Encode(obj.TotalLockedAmount); err != nil {
		return fmt.Errorf("error while marshaling TotalLockedAmount:%w", err)
	}
	// Serialize `CliffPeriod`:
	if err = encoder.Encode(obj.CliffPeriod); err != nil {
		return fmt.Errorf("error while marshaling CliffPeriod:%w", err)
	}
	// Serialize `UnlockPeriod`:
	if err = encoder.Encode(obj.UnlockPeriod); err != nil {
		return fmt.Errorf("error while marshaling UnlockPeriod:%w", err)
	}
	// Serialize `StartTime`:
	if err = encoder.Encode(obj.StartTime); err != nil {
		return fmt.Errorf("error while marshaling StartTime:%w", err)
	}
	// Serialize `AllocatedShareAmount`:
	if err = encoder.Encode(obj.AllocatedShareAmount); err != nil {
		return fmt.Errorf("error while marshaling AllocatedShareAmount:%w", err)
	}
	return nil
}

func (obj VestingSchedule) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding VestingSchedule: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *VestingSchedule) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `TotalLockedAmount`:
	if err = decoder.Decode(&obj.TotalLockedAmount); err != nil {
		return fmt.Errorf("error while unmarshaling TotalLockedAmount:%w", err)
	}
	// Deserialize `CliffPeriod`:
	if err = decoder.Decode(&obj.CliffPeriod); err != nil {
		return fmt.Errorf("error while unmarshaling CliffPeriod:%w", err)
	}
	// Deserialize `UnlockPeriod`:
	if err = decoder.Decode(&obj.UnlockPeriod); err != nil {
		return fmt.Errorf("error while unmarshaling UnlockPeriod:%w", err)
	}
	// Deserialize `StartTime`:
	if err = decoder.Decode(&obj.StartTime); err != nil {
		return fmt.Errorf("error while unmarshaling StartTime:%w", err)
	}
	// Deserialize `AllocatedShareAmount`:
	if err = decoder.Decode(&obj.AllocatedShareAmount); err != nil {
		return fmt.Errorf("error while unmarshaling AllocatedShareAmount:%w", err)
	}
	return nil
}

func (obj *VestingSchedule) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling VestingSchedule: %w", err)
	}
	return nil
}

func UnmarshalVestingSchedule(buf []byte) (*VestingSchedule, error) {
	obj := new(VestingSchedule)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}
