// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains parsers for the types defined in the IDL.

package moonit

import (
	"bytes"
	"fmt"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

type Instruction interface {
	TypeID() binary.TypeID
	SetAccounts(accounts solanago.PublicKeySlice) error
	Copy() Instruction
}

type TokenMintParams struct {
	Name               string
	Symbol             string
	Uri                string
	Decimals           uint8
	CollateralCurrency uint8
	Amount             uint64
	CurveType          uint8
	MigrationTarget    uint8
}

func (obj TokenMintParams) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Name`:
	if err = encoder.Encode(obj.Name); err != nil {
		return fmt.Errorf("error while marshaling Name:%w", err)
	}
	// Serialize `Symbol`:
	if err = encoder.Encode(obj.Symbol); err != nil {
		return fmt.Errorf("error while marshaling Symbol:%w", err)
	}
	// Serialize `Uri`:
	if err = encoder.Encode(obj.Uri); err != nil {
		return fmt.Errorf("error while marshaling Uri:%w", err)
	}
	// Serialize `Decimals`:
	if err = encoder.Encode(obj.Decimals); err != nil {
		return fmt.Errorf("error while marshaling Decimals:%w", err)
	}
	// Serialize `CollateralCurrency`:
	if err = encoder.Encode(obj.CollateralCurrency); err != nil {
		return fmt.Errorf("error while marshaling CollateralCurrency:%w", err)
	}
	// Serialize `Amount`:
	if err = encoder.Encode(obj.Amount); err != nil {
		return fmt.Errorf("error while marshaling Amount:%w", err)
	}
	// Serialize `CurveType`:
	if err = encoder.Encode(obj.CurveType); err != nil {
		return fmt.Errorf("error while marshaling CurveType:%w", err)
	}
	// Serialize `MigrationTarget`:
	if err = encoder.Encode(obj.MigrationTarget); err != nil {
		return fmt.Errorf("error while marshaling MigrationTarget:%w", err)
	}
	return nil
}

func (obj TokenMintParams) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding TokenMintParams: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *TokenMintParams) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Name`:
	if err = decoder.Decode(&obj.Name); err != nil {
		return fmt.Errorf("error while unmarshaling Name:%w", err)
	}
	// Deserialize `Symbol`:
	if err = decoder.Decode(&obj.Symbol); err != nil {
		return fmt.Errorf("error while unmarshaling Symbol:%w", err)
	}
	// Deserialize `Uri`:
	if err = decoder.Decode(&obj.Uri); err != nil {
		return fmt.Errorf("error while unmarshaling Uri:%w", err)
	}
	// Deserialize `Decimals`:
	if err = decoder.Decode(&obj.Decimals); err != nil {
		return fmt.Errorf("error while unmarshaling Decimals:%w", err)
	}
	// Deserialize `CollateralCurrency`:
	if err = decoder.Decode(&obj.CollateralCurrency); err != nil {
		return fmt.Errorf("error while unmarshaling CollateralCurrency:%w", err)
	}
	// Deserialize `Amount`:
	if err = decoder.Decode(&obj.Amount); err != nil {
		return fmt.Errorf("error while unmarshaling Amount:%w", err)
	}
	// Deserialize `CurveType`:
	if err = decoder.Decode(&obj.CurveType); err != nil {
		return fmt.Errorf("error while unmarshaling CurveType:%w", err)
	}
	// Deserialize `MigrationTarget`:
	if err = decoder.Decode(&obj.MigrationTarget); err != nil {
		return fmt.Errorf("error while unmarshaling MigrationTarget:%w", err)
	}
	return nil
}

func (obj *TokenMintParams) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling TokenMintParams: %w", err)
	}
	return nil
}

func UnmarshalTokenMintParams(buf []byte) (*TokenMintParams, error) {
	obj := new(TokenMintParams)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type TradeParams struct {
	TokenAmount      uint64
	CollateralAmount uint64
	FixedSide        uint8
	SlippageBps      uint64
}

func (obj TradeParams) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `TokenAmount`:
	if err = encoder.Encode(obj.TokenAmount); err != nil {
		return fmt.Errorf("error while marshaling TokenAmount:%w", err)
	}
	// Serialize `CollateralAmount`:
	if err = encoder.Encode(obj.CollateralAmount); err != nil {
		return fmt.Errorf("error while marshaling CollateralAmount:%w", err)
	}
	// Serialize `FixedSide`:
	if err = encoder.Encode(obj.FixedSide); err != nil {
		return fmt.Errorf("error while marshaling FixedSide:%w", err)
	}
	// Serialize `SlippageBps`:
	if err = encoder.Encode(obj.SlippageBps); err != nil {
		return fmt.Errorf("error while marshaling SlippageBps:%w", err)
	}
	return nil
}

func (obj TradeParams) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding TradeParams: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *TradeParams) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `TokenAmount`:
	if err = decoder.Decode(&obj.TokenAmount); err != nil {
		return fmt.Errorf("error while unmarshaling TokenAmount:%w", err)
	}
	// Deserialize `CollateralAmount`:
	if err = decoder.Decode(&obj.CollateralAmount); err != nil {
		return fmt.Errorf("error while unmarshaling CollateralAmount:%w", err)
	}
	// Deserialize `FixedSide`:
	if err = decoder.Decode(&obj.FixedSide); err != nil {
		return fmt.Errorf("error while unmarshaling FixedSide:%w", err)
	}
	// Deserialize `SlippageBps`:
	if err = decoder.Decode(&obj.SlippageBps); err != nil {
		return fmt.Errorf("error while unmarshaling SlippageBps:%w", err)
	}
	return nil
}

func (obj *TradeParams) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling TradeParams: %w", err)
	}
	return nil
}

func UnmarshalTradeParams(buf []byte) (*TradeParams, error) {
	obj := new(TradeParams)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ConfigParams struct {
	MigrationAuthority        *solanago.PublicKey `bin:"optional"`
	BackendAuthority          *solanago.PublicKey `bin:"optional"`
	ConfigAuthority           *solanago.PublicKey `bin:"optional"`
	HelioFee                  *solanago.PublicKey `bin:"optional"`
	DexFee                    *solanago.PublicKey `bin:"optional"`
	FeeBps                    *uint16             `bin:"optional"`
	DexFeeShare               *uint8              `bin:"optional"`
	MigrationFee              *uint64             `bin:"optional"`
	MarketcapThreshold        *uint64             `bin:"optional"`
	MarketcapCurrency         *uint8              `bin:"optional"`
	MinSupportedDecimalPlaces *uint8              `bin:"optional"`
	MaxSupportedDecimalPlaces *uint8              `bin:"optional"`
	MinSupportedTokenSupply   *uint64             `bin:"optional"`
	MaxSupportedTokenSupply   *uint64             `bin:"optional"`
	CoefB                     *uint32             `bin:"optional"`
}

func (obj ConfigParams) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `MigrationAuthority` (optional):
	{
		if obj.MigrationAuthority == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling MigrationAuthority optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling MigrationAuthority optionality: %w", err)
			}
			if err = encoder.Encode(obj.MigrationAuthority); err != nil {
				return fmt.Errorf("error while marshaling MigrationAuthority: %w", err)
			}
		}
	}
	// Serialize `BackendAuthority` (optional):
	{
		if obj.BackendAuthority == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling BackendAuthority optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling BackendAuthority optionality: %w", err)
			}
			if err = encoder.Encode(obj.BackendAuthority); err != nil {
				return fmt.Errorf("error while marshaling BackendAuthority: %w", err)
			}
		}
	}
	// Serialize `ConfigAuthority` (optional):
	{
		if obj.ConfigAuthority == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling ConfigAuthority optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling ConfigAuthority optionality: %w", err)
			}
			if err = encoder.Encode(obj.ConfigAuthority); err != nil {
				return fmt.Errorf("error while marshaling ConfigAuthority: %w", err)
			}
		}
	}
	// Serialize `HelioFee` (optional):
	{
		if obj.HelioFee == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling HelioFee optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling HelioFee optionality: %w", err)
			}
			if err = encoder.Encode(obj.HelioFee); err != nil {
				return fmt.Errorf("error while marshaling HelioFee: %w", err)
			}
		}
	}
	// Serialize `DexFee` (optional):
	{
		if obj.DexFee == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling DexFee optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling DexFee optionality: %w", err)
			}
			if err = encoder.Encode(obj.DexFee); err != nil {
				return fmt.Errorf("error while marshaling DexFee: %w", err)
			}
		}
	}
	// Serialize `FeeBps` (optional):
	{
		if obj.FeeBps == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling FeeBps optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling FeeBps optionality: %w", err)
			}
			if err = encoder.Encode(obj.FeeBps); err != nil {
				return fmt.Errorf("error while marshaling FeeBps: %w", err)
			}
		}
	}
	// Serialize `DexFeeShare` (optional):
	{
		if obj.DexFeeShare == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling DexFeeShare optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling DexFeeShare optionality: %w", err)
			}
			if err = encoder.Encode(obj.DexFeeShare); err != nil {
				return fmt.Errorf("error while marshaling DexFeeShare: %w", err)
			}
		}
	}
	// Serialize `MigrationFee` (optional):
	{
		if obj.MigrationFee == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling MigrationFee optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling MigrationFee optionality: %w", err)
			}
			if err = encoder.Encode(obj.MigrationFee); err != nil {
				return fmt.Errorf("error while marshaling MigrationFee: %w", err)
			}
		}
	}
	// Serialize `MarketcapThreshold` (optional):
	{
		if obj.MarketcapThreshold == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling MarketcapThreshold optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling MarketcapThreshold optionality: %w", err)
			}
			if err = encoder.Encode(obj.MarketcapThreshold); err != nil {
				return fmt.Errorf("error while marshaling MarketcapThreshold: %w", err)
			}
		}
	}
	// Serialize `MarketcapCurrency` (optional):
	{
		if obj.MarketcapCurrency == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling MarketcapCurrency optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling MarketcapCurrency optionality: %w", err)
			}
			if err = encoder.Encode(obj.MarketcapCurrency); err != nil {
				return fmt.Errorf("error while marshaling MarketcapCurrency: %w", err)
			}
		}
	}
	// Serialize `MinSupportedDecimalPlaces` (optional):
	{
		if obj.MinSupportedDecimalPlaces == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling MinSupportedDecimalPlaces optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling MinSupportedDecimalPlaces optionality: %w", err)
			}
			if err = encoder.Encode(obj.MinSupportedDecimalPlaces); err != nil {
				return fmt.Errorf("error while marshaling MinSupportedDecimalPlaces: %w", err)
			}
		}
	}
	// Serialize `MaxSupportedDecimalPlaces` (optional):
	{
		if obj.MaxSupportedDecimalPlaces == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling MaxSupportedDecimalPlaces optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling MaxSupportedDecimalPlaces optionality: %w", err)
			}
			if err = encoder.Encode(obj.MaxSupportedDecimalPlaces); err != nil {
				return fmt.Errorf("error while marshaling MaxSupportedDecimalPlaces: %w", err)
			}
		}
	}
	// Serialize `MinSupportedTokenSupply` (optional):
	{
		if obj.MinSupportedTokenSupply == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling MinSupportedTokenSupply optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling MinSupportedTokenSupply optionality: %w", err)
			}
			if err = encoder.Encode(obj.MinSupportedTokenSupply); err != nil {
				return fmt.Errorf("error while marshaling MinSupportedTokenSupply: %w", err)
			}
		}
	}
	// Serialize `MaxSupportedTokenSupply` (optional):
	{
		if obj.MaxSupportedTokenSupply == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling MaxSupportedTokenSupply optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling MaxSupportedTokenSupply optionality: %w", err)
			}
			if err = encoder.Encode(obj.MaxSupportedTokenSupply); err != nil {
				return fmt.Errorf("error while marshaling MaxSupportedTokenSupply: %w", err)
			}
		}
	}
	// Serialize `CoefB` (optional):
	{
		if obj.CoefB == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling CoefB optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling CoefB optionality: %w", err)
			}
			if err = encoder.Encode(obj.CoefB); err != nil {
				return fmt.Errorf("error while marshaling CoefB: %w", err)
			}
		}
	}
	return nil
}

func (obj ConfigParams) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding ConfigParams: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *ConfigParams) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `MigrationAuthority` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling MigrationAuthority:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.MigrationAuthority); err != nil {
				return fmt.Errorf("error while unmarshaling MigrationAuthority:%w", err)
			}
		}
	}
	// Deserialize `BackendAuthority` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling BackendAuthority:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.BackendAuthority); err != nil {
				return fmt.Errorf("error while unmarshaling BackendAuthority:%w", err)
			}
		}
	}
	// Deserialize `ConfigAuthority` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling ConfigAuthority:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.ConfigAuthority); err != nil {
				return fmt.Errorf("error while unmarshaling ConfigAuthority:%w", err)
			}
		}
	}
	// Deserialize `HelioFee` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling HelioFee:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.HelioFee); err != nil {
				return fmt.Errorf("error while unmarshaling HelioFee:%w", err)
			}
		}
	}
	// Deserialize `DexFee` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling DexFee:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.DexFee); err != nil {
				return fmt.Errorf("error while unmarshaling DexFee:%w", err)
			}
		}
	}
	// Deserialize `FeeBps` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling FeeBps:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.FeeBps); err != nil {
				return fmt.Errorf("error while unmarshaling FeeBps:%w", err)
			}
		}
	}
	// Deserialize `DexFeeShare` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling DexFeeShare:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.DexFeeShare); err != nil {
				return fmt.Errorf("error while unmarshaling DexFeeShare:%w", err)
			}
		}
	}
	// Deserialize `MigrationFee` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling MigrationFee:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.MigrationFee); err != nil {
				return fmt.Errorf("error while unmarshaling MigrationFee:%w", err)
			}
		}
	}
	// Deserialize `MarketcapThreshold` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling MarketcapThreshold:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.MarketcapThreshold); err != nil {
				return fmt.Errorf("error while unmarshaling MarketcapThreshold:%w", err)
			}
		}
	}
	// Deserialize `MarketcapCurrency` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling MarketcapCurrency:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.MarketcapCurrency); err != nil {
				return fmt.Errorf("error while unmarshaling MarketcapCurrency:%w", err)
			}
		}
	}
	// Deserialize `MinSupportedDecimalPlaces` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling MinSupportedDecimalPlaces:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.MinSupportedDecimalPlaces); err != nil {
				return fmt.Errorf("error while unmarshaling MinSupportedDecimalPlaces:%w", err)
			}
		}
	}
	// Deserialize `MaxSupportedDecimalPlaces` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling MaxSupportedDecimalPlaces:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.MaxSupportedDecimalPlaces); err != nil {
				return fmt.Errorf("error while unmarshaling MaxSupportedDecimalPlaces:%w", err)
			}
		}
	}
	// Deserialize `MinSupportedTokenSupply` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling MinSupportedTokenSupply:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.MinSupportedTokenSupply); err != nil {
				return fmt.Errorf("error while unmarshaling MinSupportedTokenSupply:%w", err)
			}
		}
	}
	// Deserialize `MaxSupportedTokenSupply` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling MaxSupportedTokenSupply:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.MaxSupportedTokenSupply); err != nil {
				return fmt.Errorf("error while unmarshaling MaxSupportedTokenSupply:%w", err)
			}
		}
	}
	// Deserialize `CoefB` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling CoefB:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.CoefB); err != nil {
				return fmt.Errorf("error while unmarshaling CoefB:%w", err)
			}
		}
	}
	return nil
}

func (obj *ConfigParams) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ConfigParams: %w", err)
	}
	return nil
}

func UnmarshalConfigParams(buf []byte) (*ConfigParams, error) {
	obj := new(ConfigParams)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type Currency binary.BorshEnum

const (
	Currency_Sol Currency = iota
)

func (value Currency) String() string {
	switch value {
	case Currency_Sol:
		return "Sol"
	default:
		return ""
	}
}

type CurveType binary.BorshEnum

const (
	CurveTypeLinearV1 CurveType = iota
	CurveTypeConstantProductV1
	CurveTypeConstantProductV2
	CurveTypeFlatCurveV1
	CurveTypeFlatCurveV1AntiSnipe
)

func (value CurveType) String() string {
	switch value {
	case CurveTypeLinearV1:
		return "LinearV1"
	case CurveTypeConstantProductV1:
		return "ConstantProductV1"
	case CurveTypeConstantProductV2:
		return "ConstantProductV2"
	case CurveTypeFlatCurveV1:
		return "FlatCurveV1"
	case CurveTypeFlatCurveV1AntiSnipe:
		return "FlatCurveV1AntiSnipe"
	default:
		return ""
	}
}

type MigrationTarget binary.BorshEnum

const (
	MigrationTarget_Raydium MigrationTarget = iota
	MigrationTarget_Meteora
)

func (value MigrationTarget) String() string {
	switch value {
	case MigrationTarget_Raydium:
		return "Raydium"
	case MigrationTarget_Meteora:
		return "Meteora"
	default:
		return ""
	}
}

type TradeType binary.BorshEnum

const (
	TradeType_Buy TradeType = iota
	TradeType_Sell
)

func (value TradeType) String() string {
	switch value {
	case TradeType_Buy:
		return "Buy"
	case TradeType_Sell:
		return "Sell"
	default:
		return ""
	}
}

type FixedSide binary.BorshEnum

const (
	FixedSide_ExactIn FixedSide = iota
	FixedSide_ExactOut
)

func (value FixedSide) String() string {
	switch value {
	case FixedSide_ExactIn:
		return "ExactIn"
	case FixedSide_ExactOut:
		return "ExactOut"
	default:
		return ""
	}
}
