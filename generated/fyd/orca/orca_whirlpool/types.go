// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains parsers for the types defined in the IDL.

package orca_whirlpool

import (
	"bytes"
	"fmt"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

type Instruction interface {
	TypeID() binary.TypeID
	SetAccounts(accounts solanago.PublicKeySlice) error
	Copy() Instruction
}

// The "isDynamicTick" interface for the "DynamicTick" complex enum.
type DynamicTick interface {
	isDynamicTick()
}

type dynamicTickEnumContainer struct {
	Enum          binary.BorshEnum `bin:"enum"`
	Uninitialized DynamicTick_Uninitialized
	Initialized   DynamicTick_Initialized
}

func DecodeDynamicTick(decoder *binary.Decoder) (DynamicTick, error) {
	{
		tmp := new(dynamicTickEnumContainer)
		err := decoder.Decode(tmp)
		if err != nil {
			return nil, fmt.Errorf("failed parsing DynamicTick: %w", err)
		}
		switch tmp.Enum {
		case 0:
			return (*DynamicTick_Uninitialized)(&tmp.Enum), nil
		case 1:
			return &tmp.Initialized, nil
		default:
			return nil, fmt.Errorf("DynamicTick: unknown enum index: %v", tmp.Enum)
		}
	}
}

func EncodeDynamicTick(encoder *binary.Encoder, value DynamicTick) error {
	{
		tmp := dynamicTickEnumContainer{}
		switch realvalue := value.(type) {
		case *DynamicTick_Uninitialized:
			tmp.Enum = 0
			tmp.Uninitialized = *realvalue
		case *DynamicTick_Initialized:
			tmp.Enum = 1
			tmp.Initialized = *realvalue
		}
		return encoder.Encode(tmp)
	}
}

type DynamicTick_Uninitialized uint8

func (obj DynamicTick_Uninitialized) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *DynamicTick_Uninitialized) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (_ *DynamicTick_Uninitialized) isDynamicTick() {}

// Variant "Initialized" of enum "DynamicTick"
type DynamicTick_Initialized struct {
	V0 DynamicTickData `json:"v0"`
}

func (obj DynamicTick_Initialized) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `V0`:
	if err = encoder.Encode(obj.V0); err != nil {
		return fmt.Errorf("error while marshaling V0:%w", err)
	}
	return nil
}

func (obj DynamicTick_Initialized) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding DynamicTick_Initialized: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *DynamicTick_Initialized) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `V0`:
	if err = decoder.Decode(&obj.V0); err != nil {
		return fmt.Errorf("error while unmarshaling V0:%w", err)
	}
	return nil
}

func (obj *DynamicTick_Initialized) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling DynamicTick_Initialized: %w", err)
	}
	return nil
}

func UnmarshalDynamicTick_Initialized(buf []byte) (*DynamicTick_Initialized, error) {
	obj := new(DynamicTick_Initialized)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *DynamicTick_Initialized) isDynamicTick() {}

type DynamicTickData struct {
	LiquidityNet         binary.Int128
	LiquidityGross       binary.Uint128
	FeeGrowthOutsideA    binary.Uint128
	FeeGrowthOutsideB    binary.Uint128
	RewardGrowthsOutside [3]binary.Uint128
}

func (obj DynamicTickData) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `LiquidityNet`:
	if err = encoder.Encode(obj.LiquidityNet); err != nil {
		return fmt.Errorf("error while marshaling LiquidityNet:%w", err)
	}
	// Serialize `LiquidityGross`:
	if err = encoder.Encode(obj.LiquidityGross); err != nil {
		return fmt.Errorf("error while marshaling LiquidityGross:%w", err)
	}
	// Serialize `FeeGrowthOutsideA`:
	if err = encoder.Encode(obj.FeeGrowthOutsideA); err != nil {
		return fmt.Errorf("error while marshaling FeeGrowthOutsideA:%w", err)
	}
	// Serialize `FeeGrowthOutsideB`:
	if err = encoder.Encode(obj.FeeGrowthOutsideB); err != nil {
		return fmt.Errorf("error while marshaling FeeGrowthOutsideB:%w", err)
	}
	// Serialize `RewardGrowthsOutside`:
	if err = encoder.Encode(obj.RewardGrowthsOutside); err != nil {
		return fmt.Errorf("error while marshaling RewardGrowthsOutside:%w", err)
	}
	return nil
}

func (obj DynamicTickData) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding DynamicTickData: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *DynamicTickData) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `LiquidityNet`:
	if err = decoder.Decode(&obj.LiquidityNet); err != nil {
		return fmt.Errorf("error while unmarshaling LiquidityNet:%w", err)
	}
	// Deserialize `LiquidityGross`:
	if err = decoder.Decode(&obj.LiquidityGross); err != nil {
		return fmt.Errorf("error while unmarshaling LiquidityGross:%w", err)
	}
	// Deserialize `FeeGrowthOutsideA`:
	if err = decoder.Decode(&obj.FeeGrowthOutsideA); err != nil {
		return fmt.Errorf("error while unmarshaling FeeGrowthOutsideA:%w", err)
	}
	// Deserialize `FeeGrowthOutsideB`:
	if err = decoder.Decode(&obj.FeeGrowthOutsideB); err != nil {
		return fmt.Errorf("error while unmarshaling FeeGrowthOutsideB:%w", err)
	}
	// Deserialize `RewardGrowthsOutside`:
	if err = decoder.Decode(&obj.RewardGrowthsOutside); err != nil {
		return fmt.Errorf("error while unmarshaling RewardGrowthsOutside:%w", err)
	}
	return nil
}

func (obj *DynamicTickData) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling DynamicTickData: %w", err)
	}
	return nil
}

func UnmarshalDynamicTickData(buf []byte) (*DynamicTickData, error) {
	obj := new(DynamicTickData)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type LockType binary.BorshEnum

const (
	LockType_Permanent LockType = iota
)

func (value LockType) String() string {
	switch value {
	case LockType_Permanent:
		return "Permanent"
	default:
		return ""
	}
}

type LockTypeLabel binary.BorshEnum

const (
	LockTypeLabel_Permanent LockTypeLabel = iota
)

func (value LockTypeLabel) String() string {
	switch value {
	case LockTypeLabel_Permanent:
		return "Permanent"
	default:
		return ""
	}
}

type AdaptiveFeeConstants struct {
	FilterPeriod             uint16
	DecayPeriod              uint16
	ReductionFactor          uint16
	AdaptiveFeeControlFactor uint32
	MaxVolatilityAccumulator uint32
	TickGroupSize            uint16
	MajorSwapThresholdTicks  uint16
	Reserved                 [16]uint8
}

func (obj AdaptiveFeeConstants) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `FilterPeriod`:
	if err = encoder.Encode(obj.FilterPeriod); err != nil {
		return fmt.Errorf("error while marshaling FilterPeriod:%w", err)
	}
	// Serialize `DecayPeriod`:
	if err = encoder.Encode(obj.DecayPeriod); err != nil {
		return fmt.Errorf("error while marshaling DecayPeriod:%w", err)
	}
	// Serialize `ReductionFactor`:
	if err = encoder.Encode(obj.ReductionFactor); err != nil {
		return fmt.Errorf("error while marshaling ReductionFactor:%w", err)
	}
	// Serialize `AdaptiveFeeControlFactor`:
	if err = encoder.Encode(obj.AdaptiveFeeControlFactor); err != nil {
		return fmt.Errorf("error while marshaling AdaptiveFeeControlFactor:%w", err)
	}
	// Serialize `MaxVolatilityAccumulator`:
	if err = encoder.Encode(obj.MaxVolatilityAccumulator); err != nil {
		return fmt.Errorf("error while marshaling MaxVolatilityAccumulator:%w", err)
	}
	// Serialize `TickGroupSize`:
	if err = encoder.Encode(obj.TickGroupSize); err != nil {
		return fmt.Errorf("error while marshaling TickGroupSize:%w", err)
	}
	// Serialize `MajorSwapThresholdTicks`:
	if err = encoder.Encode(obj.MajorSwapThresholdTicks); err != nil {
		return fmt.Errorf("error while marshaling MajorSwapThresholdTicks:%w", err)
	}
	// Serialize `Reserved`:
	if err = encoder.Encode(obj.Reserved); err != nil {
		return fmt.Errorf("error while marshaling Reserved:%w", err)
	}
	return nil
}

func (obj AdaptiveFeeConstants) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding AdaptiveFeeConstants: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *AdaptiveFeeConstants) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `FilterPeriod`:
	if err = decoder.Decode(&obj.FilterPeriod); err != nil {
		return fmt.Errorf("error while unmarshaling FilterPeriod:%w", err)
	}
	// Deserialize `DecayPeriod`:
	if err = decoder.Decode(&obj.DecayPeriod); err != nil {
		return fmt.Errorf("error while unmarshaling DecayPeriod:%w", err)
	}
	// Deserialize `ReductionFactor`:
	if err = decoder.Decode(&obj.ReductionFactor); err != nil {
		return fmt.Errorf("error while unmarshaling ReductionFactor:%w", err)
	}
	// Deserialize `AdaptiveFeeControlFactor`:
	if err = decoder.Decode(&obj.AdaptiveFeeControlFactor); err != nil {
		return fmt.Errorf("error while unmarshaling AdaptiveFeeControlFactor:%w", err)
	}
	// Deserialize `MaxVolatilityAccumulator`:
	if err = decoder.Decode(&obj.MaxVolatilityAccumulator); err != nil {
		return fmt.Errorf("error while unmarshaling MaxVolatilityAccumulator:%w", err)
	}
	// Deserialize `TickGroupSize`:
	if err = decoder.Decode(&obj.TickGroupSize); err != nil {
		return fmt.Errorf("error while unmarshaling TickGroupSize:%w", err)
	}
	// Deserialize `MajorSwapThresholdTicks`:
	if err = decoder.Decode(&obj.MajorSwapThresholdTicks); err != nil {
		return fmt.Errorf("error while unmarshaling MajorSwapThresholdTicks:%w", err)
	}
	// Deserialize `Reserved`:
	if err = decoder.Decode(&obj.Reserved); err != nil {
		return fmt.Errorf("error while unmarshaling Reserved:%w", err)
	}
	return nil
}

func (obj *AdaptiveFeeConstants) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AdaptiveFeeConstants: %w", err)
	}
	return nil
}

func UnmarshalAdaptiveFeeConstants(buf []byte) (*AdaptiveFeeConstants, error) {
	obj := new(AdaptiveFeeConstants)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type AdaptiveFeeVariables struct {
	LastReferenceUpdateTimestamp uint64
	LastMajorSwapTimestamp       uint64
	VolatilityReference          uint32
	TickGroupIndexReference      int32
	VolatilityAccumulator        uint32
	Reserved                     [16]uint8
}

func (obj AdaptiveFeeVariables) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `LastReferenceUpdateTimestamp`:
	if err = encoder.Encode(obj.LastReferenceUpdateTimestamp); err != nil {
		return fmt.Errorf("error while marshaling LastReferenceUpdateTimestamp:%w", err)
	}
	// Serialize `LastMajorSwapTimestamp`:
	if err = encoder.Encode(obj.LastMajorSwapTimestamp); err != nil {
		return fmt.Errorf("error while marshaling LastMajorSwapTimestamp:%w", err)
	}
	// Serialize `VolatilityReference`:
	if err = encoder.Encode(obj.VolatilityReference); err != nil {
		return fmt.Errorf("error while marshaling VolatilityReference:%w", err)
	}
	// Serialize `TickGroupIndexReference`:
	if err = encoder.Encode(obj.TickGroupIndexReference); err != nil {
		return fmt.Errorf("error while marshaling TickGroupIndexReference:%w", err)
	}
	// Serialize `VolatilityAccumulator`:
	if err = encoder.Encode(obj.VolatilityAccumulator); err != nil {
		return fmt.Errorf("error while marshaling VolatilityAccumulator:%w", err)
	}
	// Serialize `Reserved`:
	if err = encoder.Encode(obj.Reserved); err != nil {
		return fmt.Errorf("error while marshaling Reserved:%w", err)
	}
	return nil
}

func (obj AdaptiveFeeVariables) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding AdaptiveFeeVariables: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *AdaptiveFeeVariables) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `LastReferenceUpdateTimestamp`:
	if err = decoder.Decode(&obj.LastReferenceUpdateTimestamp); err != nil {
		return fmt.Errorf("error while unmarshaling LastReferenceUpdateTimestamp:%w", err)
	}
	// Deserialize `LastMajorSwapTimestamp`:
	if err = decoder.Decode(&obj.LastMajorSwapTimestamp); err != nil {
		return fmt.Errorf("error while unmarshaling LastMajorSwapTimestamp:%w", err)
	}
	// Deserialize `VolatilityReference`:
	if err = decoder.Decode(&obj.VolatilityReference); err != nil {
		return fmt.Errorf("error while unmarshaling VolatilityReference:%w", err)
	}
	// Deserialize `TickGroupIndexReference`:
	if err = decoder.Decode(&obj.TickGroupIndexReference); err != nil {
		return fmt.Errorf("error while unmarshaling TickGroupIndexReference:%w", err)
	}
	// Deserialize `VolatilityAccumulator`:
	if err = decoder.Decode(&obj.VolatilityAccumulator); err != nil {
		return fmt.Errorf("error while unmarshaling VolatilityAccumulator:%w", err)
	}
	// Deserialize `Reserved`:
	if err = decoder.Decode(&obj.Reserved); err != nil {
		return fmt.Errorf("error while unmarshaling Reserved:%w", err)
	}
	return nil
}

func (obj *AdaptiveFeeVariables) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AdaptiveFeeVariables: %w", err)
	}
	return nil
}

func UnmarshalAdaptiveFeeVariables(buf []byte) (*AdaptiveFeeVariables, error) {
	obj := new(AdaptiveFeeVariables)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type OpenPositionBumps struct {
	PositionBump uint8
}

func (obj OpenPositionBumps) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `PositionBump`:
	if err = encoder.Encode(obj.PositionBump); err != nil {
		return fmt.Errorf("error while marshaling PositionBump:%w", err)
	}
	return nil
}

func (obj OpenPositionBumps) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding OpenPositionBumps: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *OpenPositionBumps) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `PositionBump`:
	if err = decoder.Decode(&obj.PositionBump); err != nil {
		return fmt.Errorf("error while unmarshaling PositionBump:%w", err)
	}
	return nil
}

func (obj *OpenPositionBumps) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling OpenPositionBumps: %w", err)
	}
	return nil
}

func UnmarshalOpenPositionBumps(buf []byte) (*OpenPositionBumps, error) {
	obj := new(OpenPositionBumps)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type OpenPositionWithMetadataBumps struct {
	PositionBump uint8
	MetadataBump uint8
}

func (obj OpenPositionWithMetadataBumps) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `PositionBump`:
	if err = encoder.Encode(obj.PositionBump); err != nil {
		return fmt.Errorf("error while marshaling PositionBump:%w", err)
	}
	// Serialize `MetadataBump`:
	if err = encoder.Encode(obj.MetadataBump); err != nil {
		return fmt.Errorf("error while marshaling MetadataBump:%w", err)
	}
	return nil
}

func (obj OpenPositionWithMetadataBumps) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding OpenPositionWithMetadataBumps: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *OpenPositionWithMetadataBumps) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `PositionBump`:
	if err = decoder.Decode(&obj.PositionBump); err != nil {
		return fmt.Errorf("error while unmarshaling PositionBump:%w", err)
	}
	// Deserialize `MetadataBump`:
	if err = decoder.Decode(&obj.MetadataBump); err != nil {
		return fmt.Errorf("error while unmarshaling MetadataBump:%w", err)
	}
	return nil
}

func (obj *OpenPositionWithMetadataBumps) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling OpenPositionWithMetadataBumps: %w", err)
	}
	return nil
}

func UnmarshalOpenPositionWithMetadataBumps(buf []byte) (*OpenPositionWithMetadataBumps, error) {
	obj := new(OpenPositionWithMetadataBumps)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type PositionRewardInfo struct {
	GrowthInsideCheckpoint binary.Uint128
	AmountOwed             uint64
}

func (obj PositionRewardInfo) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `GrowthInsideCheckpoint`:
	if err = encoder.Encode(obj.GrowthInsideCheckpoint); err != nil {
		return fmt.Errorf("error while marshaling GrowthInsideCheckpoint:%w", err)
	}
	// Serialize `AmountOwed`:
	if err = encoder.Encode(obj.AmountOwed); err != nil {
		return fmt.Errorf("error while marshaling AmountOwed:%w", err)
	}
	return nil
}

func (obj PositionRewardInfo) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding PositionRewardInfo: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *PositionRewardInfo) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `GrowthInsideCheckpoint`:
	if err = decoder.Decode(&obj.GrowthInsideCheckpoint); err != nil {
		return fmt.Errorf("error while unmarshaling GrowthInsideCheckpoint:%w", err)
	}
	// Deserialize `AmountOwed`:
	if err = decoder.Decode(&obj.AmountOwed); err != nil {
		return fmt.Errorf("error while unmarshaling AmountOwed:%w", err)
	}
	return nil
}

func (obj *PositionRewardInfo) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling PositionRewardInfo: %w", err)
	}
	return nil
}

func UnmarshalPositionRewardInfo(buf []byte) (*PositionRewardInfo, error) {
	obj := new(PositionRewardInfo)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type Tick struct {
	Initialized          bool
	LiquidityNet         binary.Int128
	LiquidityGross       binary.Uint128
	FeeGrowthOutsideA    binary.Uint128
	FeeGrowthOutsideB    binary.Uint128
	RewardGrowthsOutside [3]binary.Uint128
}

func (obj Tick) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Initialized`:
	if err = encoder.Encode(obj.Initialized); err != nil {
		return fmt.Errorf("error while marshaling Initialized:%w", err)
	}
	// Serialize `LiquidityNet`:
	if err = encoder.Encode(obj.LiquidityNet); err != nil {
		return fmt.Errorf("error while marshaling LiquidityNet:%w", err)
	}
	// Serialize `LiquidityGross`:
	if err = encoder.Encode(obj.LiquidityGross); err != nil {
		return fmt.Errorf("error while marshaling LiquidityGross:%w", err)
	}
	// Serialize `FeeGrowthOutsideA`:
	if err = encoder.Encode(obj.FeeGrowthOutsideA); err != nil {
		return fmt.Errorf("error while marshaling FeeGrowthOutsideA:%w", err)
	}
	// Serialize `FeeGrowthOutsideB`:
	if err = encoder.Encode(obj.FeeGrowthOutsideB); err != nil {
		return fmt.Errorf("error while marshaling FeeGrowthOutsideB:%w", err)
	}
	// Serialize `RewardGrowthsOutside`:
	if err = encoder.Encode(obj.RewardGrowthsOutside); err != nil {
		return fmt.Errorf("error while marshaling RewardGrowthsOutside:%w", err)
	}
	return nil
}

func (obj Tick) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Tick: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Tick) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Initialized`:
	if err = decoder.Decode(&obj.Initialized); err != nil {
		return fmt.Errorf("error while unmarshaling Initialized:%w", err)
	}
	// Deserialize `LiquidityNet`:
	if err = decoder.Decode(&obj.LiquidityNet); err != nil {
		return fmt.Errorf("error while unmarshaling LiquidityNet:%w", err)
	}
	// Deserialize `LiquidityGross`:
	if err = decoder.Decode(&obj.LiquidityGross); err != nil {
		return fmt.Errorf("error while unmarshaling LiquidityGross:%w", err)
	}
	// Deserialize `FeeGrowthOutsideA`:
	if err = decoder.Decode(&obj.FeeGrowthOutsideA); err != nil {
		return fmt.Errorf("error while unmarshaling FeeGrowthOutsideA:%w", err)
	}
	// Deserialize `FeeGrowthOutsideB`:
	if err = decoder.Decode(&obj.FeeGrowthOutsideB); err != nil {
		return fmt.Errorf("error while unmarshaling FeeGrowthOutsideB:%w", err)
	}
	// Deserialize `RewardGrowthsOutside`:
	if err = decoder.Decode(&obj.RewardGrowthsOutside); err != nil {
		return fmt.Errorf("error while unmarshaling RewardGrowthsOutside:%w", err)
	}
	return nil
}

func (obj *Tick) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Tick: %w", err)
	}
	return nil
}

func UnmarshalTick(buf []byte) (*Tick, error) {
	obj := new(Tick)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type WhirlpoolBumps struct {
	WhirlpoolBump uint8
}

func (obj WhirlpoolBumps) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `WhirlpoolBump`:
	if err = encoder.Encode(obj.WhirlpoolBump); err != nil {
		return fmt.Errorf("error while marshaling WhirlpoolBump:%w", err)
	}
	return nil
}

func (obj WhirlpoolBumps) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding WhirlpoolBumps: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *WhirlpoolBumps) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `WhirlpoolBump`:
	if err = decoder.Decode(&obj.WhirlpoolBump); err != nil {
		return fmt.Errorf("error while unmarshaling WhirlpoolBump:%w", err)
	}
	return nil
}

func (obj *WhirlpoolBumps) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling WhirlpoolBumps: %w", err)
	}
	return nil
}

func UnmarshalWhirlpoolBumps(buf []byte) (*WhirlpoolBumps, error) {
	obj := new(WhirlpoolBumps)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Stores the state relevant for tracking liquidity mining rewards at the `Whirlpool` level.
// These values are used in conjunction with `PositionRewardInfo`, `Tick.reward_growths_outside`,
// and `Whirlpool.reward_last_updated_timestamp` to determine how many rewards are earned by open
// positions.
type WhirlpoolRewardInfo struct {
	// Reward token mint.
	Mint solanago.PublicKey

	// Reward vault token account.
	Vault solanago.PublicKey

	// Authority account that has permission to initialize the reward and set emissions.
	Authority solanago.PublicKey

	// Q64.64 number that indicates how many tokens per second are earned per unit of liquidity.
	EmissionsPerSecondX64 binary.Uint128

	// Q64.64 number that tracks the total tokens earned per unit of liquidity since the reward
	// emissions were turned on.
	GrowthGlobalX64 binary.Uint128
}

func (obj WhirlpoolRewardInfo) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Mint`:
	if err = encoder.Encode(obj.Mint); err != nil {
		return fmt.Errorf("error while marshaling Mint:%w", err)
	}
	// Serialize `Vault`:
	if err = encoder.Encode(obj.Vault); err != nil {
		return fmt.Errorf("error while marshaling Vault:%w", err)
	}
	// Serialize `Authority`:
	if err = encoder.Encode(obj.Authority); err != nil {
		return fmt.Errorf("error while marshaling Authority:%w", err)
	}
	// Serialize `EmissionsPerSecondX64`:
	if err = encoder.Encode(obj.EmissionsPerSecondX64); err != nil {
		return fmt.Errorf("error while marshaling EmissionsPerSecondX64:%w", err)
	}
	// Serialize `GrowthGlobalX64`:
	if err = encoder.Encode(obj.GrowthGlobalX64); err != nil {
		return fmt.Errorf("error while marshaling GrowthGlobalX64:%w", err)
	}
	return nil
}

func (obj WhirlpoolRewardInfo) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding WhirlpoolRewardInfo: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *WhirlpoolRewardInfo) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Mint`:
	if err = decoder.Decode(&obj.Mint); err != nil {
		return fmt.Errorf("error while unmarshaling Mint:%w", err)
	}
	// Deserialize `Vault`:
	if err = decoder.Decode(&obj.Vault); err != nil {
		return fmt.Errorf("error while unmarshaling Vault:%w", err)
	}
	// Deserialize `Authority`:
	if err = decoder.Decode(&obj.Authority); err != nil {
		return fmt.Errorf("error while unmarshaling Authority:%w", err)
	}
	// Deserialize `EmissionsPerSecondX64`:
	if err = decoder.Decode(&obj.EmissionsPerSecondX64); err != nil {
		return fmt.Errorf("error while unmarshaling EmissionsPerSecondX64:%w", err)
	}
	// Deserialize `GrowthGlobalX64`:
	if err = decoder.Decode(&obj.GrowthGlobalX64); err != nil {
		return fmt.Errorf("error while unmarshaling GrowthGlobalX64:%w", err)
	}
	return nil
}

func (obj *WhirlpoolRewardInfo) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling WhirlpoolRewardInfo: %w", err)
	}
	return nil
}

func UnmarshalWhirlpoolRewardInfo(buf []byte) (*WhirlpoolRewardInfo, error) {
	obj := new(WhirlpoolRewardInfo)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type AccountsType binary.BorshEnum

const (
	AccountsType_TransferHookA AccountsType = iota
	AccountsType_TransferHookB
	AccountsType_TransferHookReward
	AccountsType_TransferHookInput
	AccountsType_TransferHookIntermediate
	AccountsType_TransferHookOutput
	AccountsType_SupplementalTickArrays
	AccountsType_SupplementalTickArraysOne
	AccountsType_SupplementalTickArraysTwo
)

func (value AccountsType) String() string {
	switch value {
	case AccountsType_TransferHookA:
		return "TransferHookA"
	case AccountsType_TransferHookB:
		return "TransferHookB"
	case AccountsType_TransferHookReward:
		return "TransferHookReward"
	case AccountsType_TransferHookInput:
		return "TransferHookInput"
	case AccountsType_TransferHookIntermediate:
		return "TransferHookIntermediate"
	case AccountsType_TransferHookOutput:
		return "TransferHookOutput"
	case AccountsType_SupplementalTickArrays:
		return "SupplementalTickArrays"
	case AccountsType_SupplementalTickArraysOne:
		return "SupplementalTickArraysOne"
	case AccountsType_SupplementalTickArraysTwo:
		return "SupplementalTickArraysTwo"
	default:
		return ""
	}
}

type RemainingAccountsInfo struct {
	Slices []RemainingAccountsSlice
}

func (obj RemainingAccountsInfo) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Slices`:
	if err = encoder.Encode(obj.Slices); err != nil {
		return fmt.Errorf("error while marshaling Slices:%w", err)
	}
	return nil
}

func (obj RemainingAccountsInfo) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding RemainingAccountsInfo: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *RemainingAccountsInfo) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Slices`:
	if err = decoder.Decode(&obj.Slices); err != nil {
		return fmt.Errorf("error while unmarshaling Slices:%w", err)
	}
	return nil
}

func (obj *RemainingAccountsInfo) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling RemainingAccountsInfo: %w", err)
	}
	return nil
}

func UnmarshalRemainingAccountsInfo(buf []byte) (*RemainingAccountsInfo, error) {
	obj := new(RemainingAccountsInfo)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type RemainingAccountsSlice struct {
	AccountsType AccountsType
	Length       uint8
}

func (obj RemainingAccountsSlice) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `AccountsType`:
	if err = encoder.Encode(obj.AccountsType); err != nil {
		return fmt.Errorf("error while marshaling AccountsType:%w", err)
	}
	// Serialize `Length`:
	if err = encoder.Encode(obj.Length); err != nil {
		return fmt.Errorf("error while marshaling Length:%w", err)
	}
	return nil
}

func (obj RemainingAccountsSlice) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding RemainingAccountsSlice: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *RemainingAccountsSlice) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `AccountsType`:
	if err = decoder.Decode(&obj.AccountsType); err != nil {
		return fmt.Errorf("error while unmarshaling AccountsType:%w", err)
	}
	// Deserialize `Length`:
	if err = decoder.Decode(&obj.Length); err != nil {
		return fmt.Errorf("error while unmarshaling Length:%w", err)
	}
	return nil
}

func (obj *RemainingAccountsSlice) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling RemainingAccountsSlice: %w", err)
	}
	return nil
}

func UnmarshalRemainingAccountsSlice(buf []byte) (*RemainingAccountsSlice, error) {
	obj := new(RemainingAccountsSlice)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}
