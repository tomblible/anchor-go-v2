// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package orca_whirlpool

import (
	"bytes"
	"fmt"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
	programparser "github.com/yydsqu/solana-sdk/program_parser"
)

// Builds a "swap_v2" instruction.

// Perform a swap in this Whirlpool
//
// ### Authority
// - "token_authority" - The authority to withdraw tokens from the input token account.
//
// ### Parameters
// - `amount` - The amount of input or output token to swap from (depending on amount_specified_is_input).
// - `other_amount_threshold` - The maximum/minimum of input/output token to swap into (depending on amount_specified_is_input).
// - `sqrt_price_limit` - The maximum/minimum price the swap will swap to.
// - `amount_specified_is_input` - Specifies the token the parameter `amount`represents. If true, the amount represents the input token of the swap.
// - `a_to_b` - The direction of the swap. True if swapping from A to B. False if swapping from B to A.
//
// #### Special Errors
// - `ZeroTradableAmount` - User provided parameter `amount` is 0.
// - `InvalidSqrtPriceLimitDirection` - User provided parameter `sqrt_price_limit` does not match the direction of the trade.
// - `SqrtPriceOutOfBounds` - User provided parameter `sqrt_price_limit` is over Whirlppool's max/min bounds for sqrt-price.
// - `InvalidTickArraySequence` - User provided tick-arrays are not in sequential order required to proceed in this trade direction.
// - `TickArraySequenceInvalidIndex` - The swap loop attempted to access an invalid array index during the query of the next initialized tick.
// - `TickArrayIndexOutofBounds` - The swap loop attempted to access an invalid array index during tick crossing.
// - `LiquidityOverflow` - Liquidity value overflowed 128bits during tick crossing.
// - `InvalidTickSpacing` - The swap pool was initialized with tick-spacing of 0.
type SwapV2 struct {
	// Params:
	Amount                 uint64
	OtherAmountThreshold   uint64
	SqrtPriceLimit         binary.Uint128
	AmountSpecifiedIsInput bool
	AToB                   bool
	RemainingAccountsInfo  *RemainingAccountsInfo `bin:"optional"`
	// Accounts:
	// [0] = [] token_program_a
	TokenProgramA solanago.PublicKey `bin:"-"`
	// [1] = [] token_program_b
	TokenProgramB solanago.PublicKey `bin:"-"`
	// [2] = [] memo_program
	MemoProgram solanago.PublicKey `bin:"-"`
	// [3] = [,signer] token_authority
	TokenAuthority solanago.PublicKey `bin:"-"`
	// [4] = [writable] whirlpool
	Whirlpool solanago.PublicKey `bin:"-"`
	// [5] = [] token_mint_a
	TokenMintA solanago.PublicKey `bin:"-"`
	// [6] = [] token_mint_b
	TokenMintB solanago.PublicKey `bin:"-"`
	// [7] = [writable] token_owner_account_a
	TokenOwnerAccountA solanago.PublicKey `bin:"-"`
	// [8] = [writable] token_vault_a
	TokenVaultA solanago.PublicKey `bin:"-"`
	// [9] = [writable] token_owner_account_b
	TokenOwnerAccountB solanago.PublicKey `bin:"-"`
	// [10] = [writable] token_vault_b
	TokenVaultB solanago.PublicKey `bin:"-"`
	// [11] = [writable] tick_array0
	TickArray0 solanago.PublicKey `bin:"-"`
	// [12] = [writable] tick_array1
	TickArray1 solanago.PublicKey `bin:"-"`
	// [13] = [writable] tick_array2
	TickArray2 solanago.PublicKey `bin:"-"`
	// [14] = [writable] oracle
	Oracle solanago.PublicKey `bin:"-"`
	// PublicKeySlice
	solanago.PublicKeySlice `bin:"-"`
}

func (obj SwapV2) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `amountParam`:
	if err = encoder.Encode(obj.Amount); err != nil {
		return fmt.Errorf("error while marshaling amountParam:%w", err)
	}
	// Serialize `otherAmountThresholdParam`:
	if err = encoder.Encode(obj.OtherAmountThreshold); err != nil {
		return fmt.Errorf("error while marshaling otherAmountThresholdParam:%w", err)
	}
	// Serialize `sqrtPriceLimitParam`:
	if err = encoder.Encode(obj.SqrtPriceLimit); err != nil {
		return fmt.Errorf("error while marshaling sqrtPriceLimitParam:%w", err)
	}
	// Serialize `amountSpecifiedIsInputParam`:
	if err = encoder.Encode(obj.AmountSpecifiedIsInput); err != nil {
		return fmt.Errorf("error while marshaling amountSpecifiedIsInputParam:%w", err)
	}
	// Serialize `aToBParam`:
	if err = encoder.Encode(obj.AToB); err != nil {
		return fmt.Errorf("error while marshaling aToBParam:%w", err)
	}
	// Serialize `remainingAccountsInfoParam` (optional):
	{
		if obj.RemainingAccountsInfo == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling remainingAccountsInfoParam optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling remainingAccountsInfoParam optionality: %w", err)
			}
			if err = encoder.Encode(obj.RemainingAccountsInfo); err != nil {
				return fmt.Errorf("error while marshaling remainingAccountsInfoParam: %w", err)
			}
		}
	}
	return nil
}

func (obj *SwapV2) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Amount`:
	if err = decoder.Decode(&obj.Amount); err != nil {
		return fmt.Errorf("error while unmarshaling Amount:%w", err)
	}
	// Deserialize `OtherAmountThreshold`:
	if err = decoder.Decode(&obj.OtherAmountThreshold); err != nil {
		return fmt.Errorf("error while unmarshaling OtherAmountThreshold:%w", err)
	}
	// Deserialize `SqrtPriceLimit`:
	if err = decoder.Decode(&obj.SqrtPriceLimit); err != nil {
		return fmt.Errorf("error while unmarshaling SqrtPriceLimit:%w", err)
	}
	// Deserialize `AmountSpecifiedIsInput`:
	if err = decoder.Decode(&obj.AmountSpecifiedIsInput); err != nil {
		return fmt.Errorf("error while unmarshaling AmountSpecifiedIsInput:%w", err)
	}
	// Deserialize `AToB`:
	if err = decoder.Decode(&obj.AToB); err != nil {
		return fmt.Errorf("error while unmarshaling AToB:%w", err)
	}
	// Deserialize `RemainingAccountsInfo` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling RemainingAccountsInfo:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.RemainingAccountsInfo); err != nil {
				return fmt.Errorf("error while unmarshaling RemainingAccountsInfo:%w", err)
			}
		}
	}
	return nil
}

func (obj *SwapV2) SetAccounts(accounts solanago.PublicKeySlice) (err error) {
	if len(accounts) < 15 {
		return fmt.Errorf("too few accounts, expect %d actual %d", 15, len(accounts))
	}
	obj.TokenProgramA = accounts[0]
	obj.TokenProgramB = accounts[1]
	obj.MemoProgram = accounts[2]
	obj.TokenAuthority = accounts[3]
	obj.Whirlpool = accounts[4]
	obj.TokenMintA = accounts[5]
	obj.TokenMintB = accounts[6]
	obj.TokenOwnerAccountA = accounts[7]
	obj.TokenVaultA = accounts[8]
	obj.TokenOwnerAccountB = accounts[9]
	obj.TokenVaultB = accounts[10]
	obj.TickArray0 = accounts[11]
	obj.TickArray1 = accounts[12]
	obj.TickArray2 = accounts[13]
	obj.Oracle = accounts[14]
	obj.PublicKeySlice = accounts
	return nil
}
func (obj *SwapV2) PublicKeys() solanago.PublicKeySlice {
	return obj.PublicKeySlice
}

func (*SwapV2) TypeID() binary.TypeID {
	return binary.TypeIDFromBytes(Instruction_SwapV2)
}

func (*SwapV2) NewInstance() programparser.Instruction {
	return new(SwapV2)
}

// Builds a "swap_v2" instruction.
// Perform a swap in this Whirlpool //  // ### Authority // - "token_authority" - The authority to withdraw tokens from the input token account. //  // ### Parameters // - `amount` - The amount of input or output token to swap from (depending on amount_specified_is_input). // - `other_amount_threshold` - The maximum/minimum of input/output token to swap into (depending on amount_specified_is_input). // - `sqrt_price_limit` - The maximum/minimum price the swap will swap to. // - `amount_specified_is_input` - Specifies the token the parameter `amount`represents. If true, the amount represents the input token of the swap. // - `a_to_b` - The direction of the swap. True if swapping from A to B. False if swapping from B to A. //  // #### Special Errors // - `ZeroTradableAmount` - User provided parameter `amount` is 0. // - `InvalidSqrtPriceLimitDirection` - User provided parameter `sqrt_price_limit` does not match the direction of the trade. // - `SqrtPriceOutOfBounds` - User provided parameter `sqrt_price_limit` is over Whirlppool's max/min bounds for sqrt-price. // - `InvalidTickArraySequence` - User provided tick-arrays are not in sequential order required to proceed in this trade direction. // - `TickArraySequenceInvalidIndex` - The swap loop attempted to access an invalid array index during the query of the next initialized tick. // - `TickArrayIndexOutofBounds` - The swap loop attempted to access an invalid array index during tick crossing. // - `LiquidityOverflow` - Liquidity value overflowed 128bits during tick crossing. // - `InvalidTickSpacing` - The swap pool was initialized with tick-spacing of 0.
func NewSwapV2Instruction(
	// Params:
	amountParam uint64,
	otherAmountThresholdParam uint64,
	sqrtPriceLimitParam binary.Uint128,
	amountSpecifiedIsInputParam bool,
	aToBParam bool,
	remainingAccountsInfoParam *RemainingAccountsInfo,

	// Accounts:
	tokenProgramA solanago.PublicKey,
	tokenProgramB solanago.PublicKey,
	memoProgram solanago.PublicKey,
	tokenAuthority solanago.PublicKey,
	whirlpool solanago.PublicKey,
	tokenMintA solanago.PublicKey,
	tokenMintB solanago.PublicKey,
	tokenOwnerAccountA solanago.PublicKey,
	tokenVaultA solanago.PublicKey,
	tokenOwnerAccountB solanago.PublicKey,
	tokenVaultB solanago.PublicKey,
	tickArray0 solanago.PublicKey,
	tickArray1 solanago.PublicKey,
	tickArray2 solanago.PublicKey,
	oracle solanago.PublicKey,
	remaining__ ...*solanago.AccountMeta,
) (*solanago.GenericInstruction, error) {
	var (
		err    error
		buf__  = new(bytes.Buffer)
		enc__  = binary.NewBorshEncoder(buf__)
		metas_ = make(solanago.AccountMetaSlice, 15, 15+len(remaining__))
	)

	// Encode the instruction discriminator.
	if err = enc__.WriteBytes(Instruction_SwapV2[:], false); err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}

	{
		// Serialize `amountParam`:
		if err = enc__.Encode(amountParam); err != nil {
			return nil, fmt.Errorf("error while marshaling amountParam:%w", err)
		}
		// Serialize `otherAmountThresholdParam`:
		if err = enc__.Encode(otherAmountThresholdParam); err != nil {
			return nil, fmt.Errorf("error while marshaling otherAmountThresholdParam:%w", err)
		}
		// Serialize `sqrtPriceLimitParam`:
		if err = enc__.Encode(sqrtPriceLimitParam); err != nil {
			return nil, fmt.Errorf("error while marshaling sqrtPriceLimitParam:%w", err)
		}
		// Serialize `amountSpecifiedIsInputParam`:
		if err = enc__.Encode(amountSpecifiedIsInputParam); err != nil {
			return nil, fmt.Errorf("error while marshaling amountSpecifiedIsInputParam:%w", err)
		}
		// Serialize `aToBParam`:
		if err = enc__.Encode(aToBParam); err != nil {
			return nil, fmt.Errorf("error while marshaling aToBParam:%w", err)
		}
		// Serialize `remainingAccountsInfoParam` (optional):
		{
			if remainingAccountsInfoParam == nil {
				if err = enc__.WriteOption(false); err != nil {
					return nil, fmt.Errorf("error while marshaling remainingAccountsInfoParam optionality: %w", err)
				}
			} else {
				if err = enc__.WriteOption(true); err != nil {
					return nil, fmt.Errorf("error while marshaling remainingAccountsInfoParam optionality: %w", err)
				}
				if err = enc__.Encode(remainingAccountsInfoParam); err != nil {
					return nil, fmt.Errorf("error while marshaling remainingAccountsInfoParam: %w", err)
				}
			}
		}
	}

	// Add the accounts to the instruction.
	{
		// [0] = [] token_program_a
		metas_[0] = solanago.NewAccountMeta(tokenProgramA, false, false)
		// [1] = [] token_program_b
		metas_[1] = solanago.NewAccountMeta(tokenProgramB, false, false)
		// [2] = [] memo_program
		metas_[2] = solanago.NewAccountMeta(memoProgram, false, false)
		// [3] = [,signer] token_authority
		metas_[3] = solanago.NewAccountMeta(tokenAuthority, false, true)
		// [4] = [writable] whirlpool
		metas_[4] = solanago.NewAccountMeta(whirlpool, true, false)
		// [5] = [] token_mint_a
		metas_[5] = solanago.NewAccountMeta(tokenMintA, false, false)
		// [6] = [] token_mint_b
		metas_[6] = solanago.NewAccountMeta(tokenMintB, false, false)
		// [7] = [writable] token_owner_account_a
		metas_[7] = solanago.NewAccountMeta(tokenOwnerAccountA, true, false)
		// [8] = [writable] token_vault_a
		metas_[8] = solanago.NewAccountMeta(tokenVaultA, true, false)
		// [9] = [writable] token_owner_account_b
		metas_[9] = solanago.NewAccountMeta(tokenOwnerAccountB, true, false)
		// [10] = [writable] token_vault_b
		metas_[10] = solanago.NewAccountMeta(tokenVaultB, true, false)
		// [11] = [writable] tick_array0
		metas_[11] = solanago.NewAccountMeta(tickArray0, true, false)
		// [12] = [writable] tick_array1
		metas_[12] = solanago.NewAccountMeta(tickArray1, true, false)
		// [13] = [writable] tick_array2
		metas_[13] = solanago.NewAccountMeta(tickArray2, true, false)
		// [14] = [writable] oracle
		metas_[14] = solanago.NewAccountMeta(oracle, true, false)
		// append remaining metas
		metas_ = append(metas_, remaining__...)
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		metas_,
		buf__.Bytes(),
	), nil
}

// Builds a "BuildSwapV2" instruction.
// Perform a swap in this Whirlpool //  // ### Authority // - "token_authority" - The authority to withdraw tokens from the input token account. //  // ### Parameters // - `amount` - The amount of input or output token to swap from (depending on amount_specified_is_input). // - `other_amount_threshold` - The maximum/minimum of input/output token to swap into (depending on amount_specified_is_input). // - `sqrt_price_limit` - The maximum/minimum price the swap will swap to. // - `amount_specified_is_input` - Specifies the token the parameter `amount`represents. If true, the amount represents the input token of the swap. // - `a_to_b` - The direction of the swap. True if swapping from A to B. False if swapping from B to A. //  // #### Special Errors // - `ZeroTradableAmount` - User provided parameter `amount` is 0. // - `InvalidSqrtPriceLimitDirection` - User provided parameter `sqrt_price_limit` does not match the direction of the trade. // - `SqrtPriceOutOfBounds` - User provided parameter `sqrt_price_limit` is over Whirlppool's max/min bounds for sqrt-price. // - `InvalidTickArraySequence` - User provided tick-arrays are not in sequential order required to proceed in this trade direction. // - `TickArraySequenceInvalidIndex` - The swap loop attempted to access an invalid array index during the query of the next initialized tick. // - `TickArrayIndexOutofBounds` - The swap loop attempted to access an invalid array index during tick crossing. // - `LiquidityOverflow` - Liquidity value overflowed 128bits during tick crossing. // - `InvalidTickSpacing` - The swap pool was initialized with tick-spacing of 0.
func BuildSwapV2(
	// Params:
	amountParam uint64,
	otherAmountThresholdParam uint64,
	sqrtPriceLimitParam binary.Uint128,
	amountSpecifiedIsInputParam bool,
	aToBParam bool,
	remainingAccountsInfoParam *RemainingAccountsInfo,

	// Accounts:
	tokenProgramA solanago.PublicKey,
	tokenProgramB solanago.PublicKey,
	memoProgram solanago.PublicKey,
	tokenAuthority solanago.PublicKey,
	whirlpool solanago.PublicKey,
	tokenMintA solanago.PublicKey,
	tokenMintB solanago.PublicKey,
	tokenOwnerAccountA solanago.PublicKey,
	tokenVaultA solanago.PublicKey,
	tokenOwnerAccountB solanago.PublicKey,
	tokenVaultB solanago.PublicKey,
	tickArray0 solanago.PublicKey,
	tickArray1 solanago.PublicKey,
	tickArray2 solanago.PublicKey,
	oracle solanago.PublicKey,
	remaining__ ...*solanago.AccountMeta,
) *solanago.GenericInstruction {
	instruction_, _ := NewSwapV2Instruction(
		amountParam,
		otherAmountThresholdParam,
		sqrtPriceLimitParam,
		amountSpecifiedIsInputParam,
		aToBParam,
		remainingAccountsInfoParam,
		tokenProgramA,
		tokenProgramB,
		memoProgram,
		tokenAuthority,
		whirlpool,
		tokenMintA,
		tokenMintB,
		tokenOwnerAccountA,
		tokenVaultA,
		tokenOwnerAccountB,
		tokenVaultB,
		tickArray0,
		tickArray1,
		tickArray2,
		oracle,
		remaining__...,
	)
	return instruction_
}
