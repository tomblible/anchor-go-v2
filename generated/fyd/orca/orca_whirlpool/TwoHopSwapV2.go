// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package orca_whirlpool

import (
	"bytes"
	"fmt"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
	programparser "github.com/yydsqu/solana-sdk/program_parser"
)

// Builds a "two_hop_swap_v2" instruction.

// Perform a two-hop swap in this Whirlpool
//
// ### Authority
// - "token_authority" - The authority to withdraw tokens from the input token account.
//
// ### Parameters
// - `amount` - The amount of input or output token to swap from (depending on amount_specified_is_input).
// - `other_amount_threshold` - The maximum/minimum of input/output token to swap into (depending on amount_specified_is_input).
// - `amount_specified_is_input` - Specifies the token the parameter `amount`represents. If true, the amount represents the input token of the swap.
// - `a_to_b_one` - The direction of the swap of hop one. True if swapping from A to B. False if swapping from B to A.
// - `a_to_b_two` - The direction of the swap of hop two. True if swapping from A to B. False if swapping from B to A.
// - `sqrt_price_limit_one` - The maximum/minimum price the swap will swap to in the first hop.
// - `sqrt_price_limit_two` - The maximum/minimum price the swap will swap to in the second hop.
//
// #### Special Errors
// - `ZeroTradableAmount` - User provided parameter `amount` is 0.
// - `InvalidSqrtPriceLimitDirection` - User provided parameter `sqrt_price_limit` does not match the direction of the trade.
// - `SqrtPriceOutOfBounds` - User provided parameter `sqrt_price_limit` is over Whirlppool's max/min bounds for sqrt-price.
// - `InvalidTickArraySequence` - User provided tick-arrays are not in sequential order required to proceed in this trade direction.
// - `TickArraySequenceInvalidIndex` - The swap loop attempted to access an invalid array index during the query of the next initialized tick.
// - `TickArrayIndexOutofBounds` - The swap loop attempted to access an invalid array index during tick crossing.
// - `LiquidityOverflow` - Liquidity value overflowed 128bits during tick crossing.
// - `InvalidTickSpacing` - The swap pool was initialized with tick-spacing of 0.
// - `InvalidIntermediaryMint` - Error if the intermediary mint between hop one and two do not equal.
// - `DuplicateTwoHopPool` - Error if whirlpool one & two are the same pool.
type TwoHopSwapV2 struct {
	// Params:
	Amount                 uint64
	OtherAmountThreshold   uint64
	AmountSpecifiedIsInput bool
	AToBOne                bool
	AToBTwo                bool
	SqrtPriceLimitOne      binary.Uint128
	SqrtPriceLimitTwo      binary.Uint128
	RemainingAccountsInfo  *RemainingAccountsInfo `bin:"optional"`
	// Accounts:
	// [0] = [writable] whirlpool_one
	WhirlpoolOne solanago.PublicKey `bin:"-"`
	// [1] = [writable] whirlpool_two
	WhirlpoolTwo solanago.PublicKey `bin:"-"`
	// [2] = [] token_mint_input
	TokenMintInput solanago.PublicKey `bin:"-"`
	// [3] = [] token_mint_intermediate
	TokenMintIntermediate solanago.PublicKey `bin:"-"`
	// [4] = [] token_mint_output
	TokenMintOutput solanago.PublicKey `bin:"-"`
	// [5] = [] token_program_input
	TokenProgramInput solanago.PublicKey `bin:"-"`
	// [6] = [] token_program_intermediate
	TokenProgramIntermediate solanago.PublicKey `bin:"-"`
	// [7] = [] token_program_output
	TokenProgramOutput solanago.PublicKey `bin:"-"`
	// [8] = [writable] token_owner_account_input
	TokenOwnerAccountInput solanago.PublicKey `bin:"-"`
	// [9] = [writable] token_vault_one_input
	TokenVaultOneInput solanago.PublicKey `bin:"-"`
	// [10] = [writable] token_vault_one_intermediate
	TokenVaultOneIntermediate solanago.PublicKey `bin:"-"`
	// [11] = [writable] token_vault_two_intermediate
	TokenVaultTwoIntermediate solanago.PublicKey `bin:"-"`
	// [12] = [writable] token_vault_two_output
	TokenVaultTwoOutput solanago.PublicKey `bin:"-"`
	// [13] = [writable] token_owner_account_output
	TokenOwnerAccountOutput solanago.PublicKey `bin:"-"`
	// [14] = [,signer] token_authority
	TokenAuthority solanago.PublicKey `bin:"-"`
	// [15] = [writable] tick_array_one0
	TickArrayOne0 solanago.PublicKey `bin:"-"`
	// [16] = [writable] tick_array_one1
	TickArrayOne1 solanago.PublicKey `bin:"-"`
	// [17] = [writable] tick_array_one2
	TickArrayOne2 solanago.PublicKey `bin:"-"`
	// [18] = [writable] tick_array_two0
	TickArrayTwo0 solanago.PublicKey `bin:"-"`
	// [19] = [writable] tick_array_two1
	TickArrayTwo1 solanago.PublicKey `bin:"-"`
	// [20] = [writable] tick_array_two2
	TickArrayTwo2 solanago.PublicKey `bin:"-"`
	// [21] = [writable] oracle_one
	OracleOne solanago.PublicKey `bin:"-"`
	// [22] = [writable] oracle_two
	OracleTwo solanago.PublicKey `bin:"-"`
	// [23] = [] memo_program
	MemoProgram solanago.PublicKey `bin:"-"`
	// PublicKeySlice
	solanago.PublicKeySlice `bin:"-"`
}

func (obj TwoHopSwapV2) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `amountParam`:
	if err = encoder.Encode(obj.Amount); err != nil {
		return fmt.Errorf("error while marshaling amountParam:%w", err)
	}
	// Serialize `otherAmountThresholdParam`:
	if err = encoder.Encode(obj.OtherAmountThreshold); err != nil {
		return fmt.Errorf("error while marshaling otherAmountThresholdParam:%w", err)
	}
	// Serialize `amountSpecifiedIsInputParam`:
	if err = encoder.Encode(obj.AmountSpecifiedIsInput); err != nil {
		return fmt.Errorf("error while marshaling amountSpecifiedIsInputParam:%w", err)
	}
	// Serialize `aToBOneParam`:
	if err = encoder.Encode(obj.AToBOne); err != nil {
		return fmt.Errorf("error while marshaling aToBOneParam:%w", err)
	}
	// Serialize `aToBTwoParam`:
	if err = encoder.Encode(obj.AToBTwo); err != nil {
		return fmt.Errorf("error while marshaling aToBTwoParam:%w", err)
	}
	// Serialize `sqrtPriceLimitOneParam`:
	if err = encoder.Encode(obj.SqrtPriceLimitOne); err != nil {
		return fmt.Errorf("error while marshaling sqrtPriceLimitOneParam:%w", err)
	}
	// Serialize `sqrtPriceLimitTwoParam`:
	if err = encoder.Encode(obj.SqrtPriceLimitTwo); err != nil {
		return fmt.Errorf("error while marshaling sqrtPriceLimitTwoParam:%w", err)
	}
	// Serialize `remainingAccountsInfoParam` (optional):
	{
		if obj.RemainingAccountsInfo == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling remainingAccountsInfoParam optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling remainingAccountsInfoParam optionality: %w", err)
			}
			if err = encoder.Encode(obj.RemainingAccountsInfo); err != nil {
				return fmt.Errorf("error while marshaling remainingAccountsInfoParam: %w", err)
			}
		}
	}
	return nil
}

func (obj *TwoHopSwapV2) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Amount`:
	if err = decoder.Decode(&obj.Amount); err != nil {
		return fmt.Errorf("error while unmarshaling Amount:%w", err)
	}
	// Deserialize `OtherAmountThreshold`:
	if err = decoder.Decode(&obj.OtherAmountThreshold); err != nil {
		return fmt.Errorf("error while unmarshaling OtherAmountThreshold:%w", err)
	}
	// Deserialize `AmountSpecifiedIsInput`:
	if err = decoder.Decode(&obj.AmountSpecifiedIsInput); err != nil {
		return fmt.Errorf("error while unmarshaling AmountSpecifiedIsInput:%w", err)
	}
	// Deserialize `AToBOne`:
	if err = decoder.Decode(&obj.AToBOne); err != nil {
		return fmt.Errorf("error while unmarshaling AToBOne:%w", err)
	}
	// Deserialize `AToBTwo`:
	if err = decoder.Decode(&obj.AToBTwo); err != nil {
		return fmt.Errorf("error while unmarshaling AToBTwo:%w", err)
	}
	// Deserialize `SqrtPriceLimitOne`:
	if err = decoder.Decode(&obj.SqrtPriceLimitOne); err != nil {
		return fmt.Errorf("error while unmarshaling SqrtPriceLimitOne:%w", err)
	}
	// Deserialize `SqrtPriceLimitTwo`:
	if err = decoder.Decode(&obj.SqrtPriceLimitTwo); err != nil {
		return fmt.Errorf("error while unmarshaling SqrtPriceLimitTwo:%w", err)
	}
	// Deserialize `RemainingAccountsInfo` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling RemainingAccountsInfo:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.RemainingAccountsInfo); err != nil {
				return fmt.Errorf("error while unmarshaling RemainingAccountsInfo:%w", err)
			}
		}
	}
	return nil
}

func (obj *TwoHopSwapV2) SetAccounts(accounts solanago.PublicKeySlice) (err error) {
	if len(accounts) < 24 {
		return fmt.Errorf("too few accounts, expect %d actual %d", 24, len(accounts))
	}
	obj.WhirlpoolOne = accounts[0]
	obj.WhirlpoolTwo = accounts[1]
	obj.TokenMintInput = accounts[2]
	obj.TokenMintIntermediate = accounts[3]
	obj.TokenMintOutput = accounts[4]
	obj.TokenProgramInput = accounts[5]
	obj.TokenProgramIntermediate = accounts[6]
	obj.TokenProgramOutput = accounts[7]
	obj.TokenOwnerAccountInput = accounts[8]
	obj.TokenVaultOneInput = accounts[9]
	obj.TokenVaultOneIntermediate = accounts[10]
	obj.TokenVaultTwoIntermediate = accounts[11]
	obj.TokenVaultTwoOutput = accounts[12]
	obj.TokenOwnerAccountOutput = accounts[13]
	obj.TokenAuthority = accounts[14]
	obj.TickArrayOne0 = accounts[15]
	obj.TickArrayOne1 = accounts[16]
	obj.TickArrayOne2 = accounts[17]
	obj.TickArrayTwo0 = accounts[18]
	obj.TickArrayTwo1 = accounts[19]
	obj.TickArrayTwo2 = accounts[20]
	obj.OracleOne = accounts[21]
	obj.OracleTwo = accounts[22]
	obj.MemoProgram = accounts[23]
	obj.PublicKeySlice = accounts
	return nil
}
func (obj *TwoHopSwapV2) PublicKeys() solanago.PublicKeySlice {
	return obj.PublicKeySlice
}

func (*TwoHopSwapV2) TypeID() binary.TypeID {
	return binary.TypeIDFromBytes(Instruction_TwoHopSwapV2)
}

func (*TwoHopSwapV2) NewInstance() programparser.Instruction {
	return new(TwoHopSwapV2)
}

func (obj *TwoHopSwapV2) GetRemainingAccounts() solanago.PublicKeySlice {
	return obj.PublicKeySlice[24:]
}

// Builds a "two_hop_swap_v2" instruction.
// Perform a two-hop swap in this Whirlpool //  // ### Authority // - "token_authority" - The authority to withdraw tokens from the input token account. //  // ### Parameters // - `amount` - The amount of input or output token to swap from (depending on amount_specified_is_input). // - `other_amount_threshold` - The maximum/minimum of input/output token to swap into (depending on amount_specified_is_input). // - `amount_specified_is_input` - Specifies the token the parameter `amount`represents. If true, the amount represents the input token of the swap. // - `a_to_b_one` - The direction of the swap of hop one. True if swapping from A to B. False if swapping from B to A. // - `a_to_b_two` - The direction of the swap of hop two. True if swapping from A to B. False if swapping from B to A. // - `sqrt_price_limit_one` - The maximum/minimum price the swap will swap to in the first hop. // - `sqrt_price_limit_two` - The maximum/minimum price the swap will swap to in the second hop. //  // #### Special Errors // - `ZeroTradableAmount` - User provided parameter `amount` is 0. // - `InvalidSqrtPriceLimitDirection` - User provided parameter `sqrt_price_limit` does not match the direction of the trade. // - `SqrtPriceOutOfBounds` - User provided parameter `sqrt_price_limit` is over Whirlppool's max/min bounds for sqrt-price. // - `InvalidTickArraySequence` - User provided tick-arrays are not in sequential order required to proceed in this trade direction. // - `TickArraySequenceInvalidIndex` - The swap loop attempted to access an invalid array index during the query of the next initialized tick. // - `TickArrayIndexOutofBounds` - The swap loop attempted to access an invalid array index during tick crossing. // - `LiquidityOverflow` - Liquidity value overflowed 128bits during tick crossing. // - `InvalidTickSpacing` - The swap pool was initialized with tick-spacing of 0. // - `InvalidIntermediaryMint` - Error if the intermediary mint between hop one and two do not equal. // - `DuplicateTwoHopPool` - Error if whirlpool one & two are the same pool.
func NewTwoHopSwapV2Instruction(
	// Params:
	amountParam uint64,
	otherAmountThresholdParam uint64,
	amountSpecifiedIsInputParam bool,
	aToBOneParam bool,
	aToBTwoParam bool,
	sqrtPriceLimitOneParam binary.Uint128,
	sqrtPriceLimitTwoParam binary.Uint128,
	remainingAccountsInfoParam *RemainingAccountsInfo,

	// Accounts:
	whirlpoolOne solanago.PublicKey,
	whirlpoolTwo solanago.PublicKey,
	tokenMintInput solanago.PublicKey,
	tokenMintIntermediate solanago.PublicKey,
	tokenMintOutput solanago.PublicKey,
	tokenProgramInput solanago.PublicKey,
	tokenProgramIntermediate solanago.PublicKey,
	tokenProgramOutput solanago.PublicKey,
	tokenOwnerAccountInput solanago.PublicKey,
	tokenVaultOneInput solanago.PublicKey,
	tokenVaultOneIntermediate solanago.PublicKey,
	tokenVaultTwoIntermediate solanago.PublicKey,
	tokenVaultTwoOutput solanago.PublicKey,
	tokenOwnerAccountOutput solanago.PublicKey,
	tokenAuthority solanago.PublicKey,
	tickArrayOne0 solanago.PublicKey,
	tickArrayOne1 solanago.PublicKey,
	tickArrayOne2 solanago.PublicKey,
	tickArrayTwo0 solanago.PublicKey,
	tickArrayTwo1 solanago.PublicKey,
	tickArrayTwo2 solanago.PublicKey,
	oracleOne solanago.PublicKey,
	oracleTwo solanago.PublicKey,
	memoProgram solanago.PublicKey,
	remaining__ ...*solanago.AccountMeta,
) (*solanago.GenericInstruction, error) {
	var (
		err    error
		buf__  = new(bytes.Buffer)
		enc__  = binary.NewBorshEncoder(buf__)
		metas_ = make(solanago.AccountMetaSlice, 24, 24+len(remaining__))
	)

	// Encode the instruction discriminator.
	if err = enc__.WriteBytes(Instruction_TwoHopSwapV2[:], false); err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}

	{
		// Serialize `amountParam`:
		if err = enc__.Encode(amountParam); err != nil {
			return nil, fmt.Errorf("error while marshaling amountParam:%w", err)
		}
		// Serialize `otherAmountThresholdParam`:
		if err = enc__.Encode(otherAmountThresholdParam); err != nil {
			return nil, fmt.Errorf("error while marshaling otherAmountThresholdParam:%w", err)
		}
		// Serialize `amountSpecifiedIsInputParam`:
		if err = enc__.Encode(amountSpecifiedIsInputParam); err != nil {
			return nil, fmt.Errorf("error while marshaling amountSpecifiedIsInputParam:%w", err)
		}
		// Serialize `aToBOneParam`:
		if err = enc__.Encode(aToBOneParam); err != nil {
			return nil, fmt.Errorf("error while marshaling aToBOneParam:%w", err)
		}
		// Serialize `aToBTwoParam`:
		if err = enc__.Encode(aToBTwoParam); err != nil {
			return nil, fmt.Errorf("error while marshaling aToBTwoParam:%w", err)
		}
		// Serialize `sqrtPriceLimitOneParam`:
		if err = enc__.Encode(sqrtPriceLimitOneParam); err != nil {
			return nil, fmt.Errorf("error while marshaling sqrtPriceLimitOneParam:%w", err)
		}
		// Serialize `sqrtPriceLimitTwoParam`:
		if err = enc__.Encode(sqrtPriceLimitTwoParam); err != nil {
			return nil, fmt.Errorf("error while marshaling sqrtPriceLimitTwoParam:%w", err)
		}
		// Serialize `remainingAccountsInfoParam` (optional):
		{
			if remainingAccountsInfoParam == nil {
				if err = enc__.WriteOption(false); err != nil {
					return nil, fmt.Errorf("error while marshaling remainingAccountsInfoParam optionality: %w", err)
				}
			} else {
				if err = enc__.WriteOption(true); err != nil {
					return nil, fmt.Errorf("error while marshaling remainingAccountsInfoParam optionality: %w", err)
				}
				if err = enc__.Encode(remainingAccountsInfoParam); err != nil {
					return nil, fmt.Errorf("error while marshaling remainingAccountsInfoParam: %w", err)
				}
			}
		}
	}

	// Add the accounts to the instruction.
	{
		// [0] = [writable] whirlpool_one
		metas_[0] = solanago.NewAccountMeta(whirlpoolOne, true, false)
		// [1] = [writable] whirlpool_two
		metas_[1] = solanago.NewAccountMeta(whirlpoolTwo, true, false)
		// [2] = [] token_mint_input
		metas_[2] = solanago.NewAccountMeta(tokenMintInput, false, false)
		// [3] = [] token_mint_intermediate
		metas_[3] = solanago.NewAccountMeta(tokenMintIntermediate, false, false)
		// [4] = [] token_mint_output
		metas_[4] = solanago.NewAccountMeta(tokenMintOutput, false, false)
		// [5] = [] token_program_input
		metas_[5] = solanago.NewAccountMeta(tokenProgramInput, false, false)
		// [6] = [] token_program_intermediate
		metas_[6] = solanago.NewAccountMeta(tokenProgramIntermediate, false, false)
		// [7] = [] token_program_output
		metas_[7] = solanago.NewAccountMeta(tokenProgramOutput, false, false)
		// [8] = [writable] token_owner_account_input
		metas_[8] = solanago.NewAccountMeta(tokenOwnerAccountInput, true, false)
		// [9] = [writable] token_vault_one_input
		metas_[9] = solanago.NewAccountMeta(tokenVaultOneInput, true, false)
		// [10] = [writable] token_vault_one_intermediate
		metas_[10] = solanago.NewAccountMeta(tokenVaultOneIntermediate, true, false)
		// [11] = [writable] token_vault_two_intermediate
		metas_[11] = solanago.NewAccountMeta(tokenVaultTwoIntermediate, true, false)
		// [12] = [writable] token_vault_two_output
		metas_[12] = solanago.NewAccountMeta(tokenVaultTwoOutput, true, false)
		// [13] = [writable] token_owner_account_output
		metas_[13] = solanago.NewAccountMeta(tokenOwnerAccountOutput, true, false)
		// [14] = [,signer] token_authority
		metas_[14] = solanago.NewAccountMeta(tokenAuthority, false, true)
		// [15] = [writable] tick_array_one0
		metas_[15] = solanago.NewAccountMeta(tickArrayOne0, true, false)
		// [16] = [writable] tick_array_one1
		metas_[16] = solanago.NewAccountMeta(tickArrayOne1, true, false)
		// [17] = [writable] tick_array_one2
		metas_[17] = solanago.NewAccountMeta(tickArrayOne2, true, false)
		// [18] = [writable] tick_array_two0
		metas_[18] = solanago.NewAccountMeta(tickArrayTwo0, true, false)
		// [19] = [writable] tick_array_two1
		metas_[19] = solanago.NewAccountMeta(tickArrayTwo1, true, false)
		// [20] = [writable] tick_array_two2
		metas_[20] = solanago.NewAccountMeta(tickArrayTwo2, true, false)
		// [21] = [writable] oracle_one
		metas_[21] = solanago.NewAccountMeta(oracleOne, true, false)
		// [22] = [writable] oracle_two
		metas_[22] = solanago.NewAccountMeta(oracleTwo, true, false)
		// [23] = [] memo_program
		metas_[23] = solanago.NewAccountMeta(memoProgram, false, false)
		// append remaining metas
		metas_ = append(metas_, remaining__...)
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		metas_,
		buf__.Bytes(),
	), nil
}

// Builds a "BuildTwoHopSwapV2" instruction.
// Perform a two-hop swap in this Whirlpool //  // ### Authority // - "token_authority" - The authority to withdraw tokens from the input token account. //  // ### Parameters // - `amount` - The amount of input or output token to swap from (depending on amount_specified_is_input). // - `other_amount_threshold` - The maximum/minimum of input/output token to swap into (depending on amount_specified_is_input). // - `amount_specified_is_input` - Specifies the token the parameter `amount`represents. If true, the amount represents the input token of the swap. // - `a_to_b_one` - The direction of the swap of hop one. True if swapping from A to B. False if swapping from B to A. // - `a_to_b_two` - The direction of the swap of hop two. True if swapping from A to B. False if swapping from B to A. // - `sqrt_price_limit_one` - The maximum/minimum price the swap will swap to in the first hop. // - `sqrt_price_limit_two` - The maximum/minimum price the swap will swap to in the second hop. //  // #### Special Errors // - `ZeroTradableAmount` - User provided parameter `amount` is 0. // - `InvalidSqrtPriceLimitDirection` - User provided parameter `sqrt_price_limit` does not match the direction of the trade. // - `SqrtPriceOutOfBounds` - User provided parameter `sqrt_price_limit` is over Whirlppool's max/min bounds for sqrt-price. // - `InvalidTickArraySequence` - User provided tick-arrays are not in sequential order required to proceed in this trade direction. // - `TickArraySequenceInvalidIndex` - The swap loop attempted to access an invalid array index during the query of the next initialized tick. // - `TickArrayIndexOutofBounds` - The swap loop attempted to access an invalid array index during tick crossing. // - `LiquidityOverflow` - Liquidity value overflowed 128bits during tick crossing. // - `InvalidTickSpacing` - The swap pool was initialized with tick-spacing of 0. // - `InvalidIntermediaryMint` - Error if the intermediary mint between hop one and two do not equal. // - `DuplicateTwoHopPool` - Error if whirlpool one & two are the same pool.
func BuildTwoHopSwapV2(
	// Params:
	amountParam uint64,
	otherAmountThresholdParam uint64,
	amountSpecifiedIsInputParam bool,
	aToBOneParam bool,
	aToBTwoParam bool,
	sqrtPriceLimitOneParam binary.Uint128,
	sqrtPriceLimitTwoParam binary.Uint128,
	remainingAccountsInfoParam *RemainingAccountsInfo,

	// Accounts:
	whirlpoolOne solanago.PublicKey,
	whirlpoolTwo solanago.PublicKey,
	tokenMintInput solanago.PublicKey,
	tokenMintIntermediate solanago.PublicKey,
	tokenMintOutput solanago.PublicKey,
	tokenProgramInput solanago.PublicKey,
	tokenProgramIntermediate solanago.PublicKey,
	tokenProgramOutput solanago.PublicKey,
	tokenOwnerAccountInput solanago.PublicKey,
	tokenVaultOneInput solanago.PublicKey,
	tokenVaultOneIntermediate solanago.PublicKey,
	tokenVaultTwoIntermediate solanago.PublicKey,
	tokenVaultTwoOutput solanago.PublicKey,
	tokenOwnerAccountOutput solanago.PublicKey,
	tokenAuthority solanago.PublicKey,
	tickArrayOne0 solanago.PublicKey,
	tickArrayOne1 solanago.PublicKey,
	tickArrayOne2 solanago.PublicKey,
	tickArrayTwo0 solanago.PublicKey,
	tickArrayTwo1 solanago.PublicKey,
	tickArrayTwo2 solanago.PublicKey,
	oracleOne solanago.PublicKey,
	oracleTwo solanago.PublicKey,
	memoProgram solanago.PublicKey,
	remaining__ ...*solanago.AccountMeta,
) *solanago.GenericInstruction {
	instruction_, _ := NewTwoHopSwapV2Instruction(
		amountParam,
		otherAmountThresholdParam,
		amountSpecifiedIsInputParam,
		aToBOneParam,
		aToBTwoParam,
		sqrtPriceLimitOneParam,
		sqrtPriceLimitTwoParam,
		remainingAccountsInfoParam,
		whirlpoolOne,
		whirlpoolTwo,
		tokenMintInput,
		tokenMintIntermediate,
		tokenMintOutput,
		tokenProgramInput,
		tokenProgramIntermediate,
		tokenProgramOutput,
		tokenOwnerAccountInput,
		tokenVaultOneInput,
		tokenVaultOneIntermediate,
		tokenVaultTwoIntermediate,
		tokenVaultTwoOutput,
		tokenOwnerAccountOutput,
		tokenAuthority,
		tickArrayOne0,
		tickArrayOne1,
		tickArrayOne2,
		tickArrayTwo0,
		tickArrayTwo1,
		tickArrayTwo2,
		oracleOne,
		oracleTwo,
		memoProgram,
		remaining__...,
	)
	return instruction_
}
