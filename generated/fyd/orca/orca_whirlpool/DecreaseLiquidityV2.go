// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package orca_whirlpool

import (
	"bytes"
	"fmt"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
	programparser "github.com/yydsqu/solana-sdk/program_parser"
)

// Builds a "decrease_liquidity_v2" instruction.

// Withdraw liquidity from a position in the Whirlpool. This call also updates the position's accrued fees and rewards.
//
// ### Authority
// - `position_authority` - authority that owns the token corresponding to this desired position.
//
// ### Parameters
// - `liquidity_amount` - The total amount of Liquidity the user desires to withdraw.
// - `token_min_a` - The minimum amount of tokenA the user is willing to withdraw.
// - `token_min_b` - The minimum amount of tokenB the user is willing to withdraw.
//
// #### Special Errors
// - `LiquidityZero` - Provided liquidity amount is zero.
// - `LiquidityTooHigh` - Provided liquidity exceeds u128::max.
// - `TokenMinSubceeded` - The required token to perform this operation subceeds the user defined amount.
type DecreaseLiquidityV2 struct {
	// Params:
	LiquidityAmount       binary.Uint128
	TokenMinA             uint64
	TokenMinB             uint64
	RemainingAccountsInfo *RemainingAccountsInfo `bin:"optional"`
	// Accounts:
	// [0] = [writable] whirlpool
	Whirlpool solanago.PublicKey `bin:"-"`
	// [1] = [] token_program_a
	TokenProgramA solanago.PublicKey `bin:"-"`
	// [2] = [] token_program_b
	TokenProgramB solanago.PublicKey `bin:"-"`
	// [3] = [] memo_program
	MemoProgram solanago.PublicKey `bin:"-"`
	// [4] = [,signer] position_authority
	PositionAuthority solanago.PublicKey `bin:"-"`
	// [5] = [writable] position
	Position solanago.PublicKey `bin:"-"`
	// [6] = [] position_token_account
	PositionTokenAccount solanago.PublicKey `bin:"-"`
	// [7] = [] token_mint_a
	TokenMintA solanago.PublicKey `bin:"-"`
	// [8] = [] token_mint_b
	TokenMintB solanago.PublicKey `bin:"-"`
	// [9] = [writable] token_owner_account_a
	TokenOwnerAccountA solanago.PublicKey `bin:"-"`
	// [10] = [writable] token_owner_account_b
	TokenOwnerAccountB solanago.PublicKey `bin:"-"`
	// [11] = [writable] token_vault_a
	TokenVaultA solanago.PublicKey `bin:"-"`
	// [12] = [writable] token_vault_b
	TokenVaultB solanago.PublicKey `bin:"-"`
	// [13] = [writable] tick_array_lower
	TickArrayLower solanago.PublicKey `bin:"-"`
	// [14] = [writable] tick_array_upper
	TickArrayUpper solanago.PublicKey `bin:"-"`
	// PublicKeySlice
	solanago.PublicKeySlice `bin:"-"`
}

func (obj DecreaseLiquidityV2) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `liquidityAmountParam`:
	if err = encoder.Encode(obj.LiquidityAmount); err != nil {
		return fmt.Errorf("error while marshaling liquidityAmountParam:%w", err)
	}
	// Serialize `tokenMinAParam`:
	if err = encoder.Encode(obj.TokenMinA); err != nil {
		return fmt.Errorf("error while marshaling tokenMinAParam:%w", err)
	}
	// Serialize `tokenMinBParam`:
	if err = encoder.Encode(obj.TokenMinB); err != nil {
		return fmt.Errorf("error while marshaling tokenMinBParam:%w", err)
	}
	// Serialize `remainingAccountsInfoParam` (optional):
	{
		if obj.RemainingAccountsInfo == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling remainingAccountsInfoParam optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling remainingAccountsInfoParam optionality: %w", err)
			}
			if err = encoder.Encode(obj.RemainingAccountsInfo); err != nil {
				return fmt.Errorf("error while marshaling remainingAccountsInfoParam: %w", err)
			}
		}
	}
	return nil
}

func (obj *DecreaseLiquidityV2) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `LiquidityAmount`:
	if err = decoder.Decode(&obj.LiquidityAmount); err != nil {
		return fmt.Errorf("error while unmarshaling LiquidityAmount:%w", err)
	}
	// Deserialize `TokenMinA`:
	if err = decoder.Decode(&obj.TokenMinA); err != nil {
		return fmt.Errorf("error while unmarshaling TokenMinA:%w", err)
	}
	// Deserialize `TokenMinB`:
	if err = decoder.Decode(&obj.TokenMinB); err != nil {
		return fmt.Errorf("error while unmarshaling TokenMinB:%w", err)
	}
	// Deserialize `RemainingAccountsInfo` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling RemainingAccountsInfo:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.RemainingAccountsInfo); err != nil {
				return fmt.Errorf("error while unmarshaling RemainingAccountsInfo:%w", err)
			}
		}
	}
	return nil
}

func (obj *DecreaseLiquidityV2) SetAccounts(accounts solanago.PublicKeySlice) (err error) {
	if len(accounts) < 15 {
		return fmt.Errorf("too few accounts, expect %d actual %d", 15, len(accounts))
	}
	obj.Whirlpool = accounts[0]
	obj.TokenProgramA = accounts[1]
	obj.TokenProgramB = accounts[2]
	obj.MemoProgram = accounts[3]
	obj.PositionAuthority = accounts[4]
	obj.Position = accounts[5]
	obj.PositionTokenAccount = accounts[6]
	obj.TokenMintA = accounts[7]
	obj.TokenMintB = accounts[8]
	obj.TokenOwnerAccountA = accounts[9]
	obj.TokenOwnerAccountB = accounts[10]
	obj.TokenVaultA = accounts[11]
	obj.TokenVaultB = accounts[12]
	obj.TickArrayLower = accounts[13]
	obj.TickArrayUpper = accounts[14]
	obj.PublicKeySlice = accounts
	return nil
}
func (obj *DecreaseLiquidityV2) PublicKeys() solanago.PublicKeySlice {
	return obj.PublicKeySlice
}

func (*DecreaseLiquidityV2) TypeID() binary.TypeID {
	return binary.TypeIDFromBytes(Instruction_DecreaseLiquidityV2)
}

func (*DecreaseLiquidityV2) NewInstance() programparser.Instruction {
	return new(DecreaseLiquidityV2)
}

// Builds a "decrease_liquidity_v2" instruction.
// Withdraw liquidity from a position in the Whirlpool. This call also updates the position's accrued fees and rewards. //  // ### Authority // - `position_authority` - authority that owns the token corresponding to this desired position. //  // ### Parameters // - `liquidity_amount` - The total amount of Liquidity the user desires to withdraw. // - `token_min_a` - The minimum amount of tokenA the user is willing to withdraw. // - `token_min_b` - The minimum amount of tokenB the user is willing to withdraw. //  // #### Special Errors // - `LiquidityZero` - Provided liquidity amount is zero. // - `LiquidityTooHigh` - Provided liquidity exceeds u128::max. // - `TokenMinSubceeded` - The required token to perform this operation subceeds the user defined amount.
func NewDecreaseLiquidityV2Instruction(
	// Params:
	liquidityAmountParam binary.Uint128,
	tokenMinAParam uint64,
	tokenMinBParam uint64,
	remainingAccountsInfoParam *RemainingAccountsInfo,

	// Accounts:
	whirlpool solanago.PublicKey,
	tokenProgramA solanago.PublicKey,
	tokenProgramB solanago.PublicKey,
	memoProgram solanago.PublicKey,
	positionAuthority solanago.PublicKey,
	position solanago.PublicKey,
	positionTokenAccount solanago.PublicKey,
	tokenMintA solanago.PublicKey,
	tokenMintB solanago.PublicKey,
	tokenOwnerAccountA solanago.PublicKey,
	tokenOwnerAccountB solanago.PublicKey,
	tokenVaultA solanago.PublicKey,
	tokenVaultB solanago.PublicKey,
	tickArrayLower solanago.PublicKey,
	tickArrayUpper solanago.PublicKey,
	remaining__ ...*solanago.AccountMeta,
) (*solanago.GenericInstruction, error) {
	var (
		err    error
		buf__  = new(bytes.Buffer)
		enc__  = binary.NewBorshEncoder(buf__)
		metas_ = make(solanago.AccountMetaSlice, 15, 15+len(remaining__))
	)

	// Encode the instruction discriminator.
	if err = enc__.WriteBytes(Instruction_DecreaseLiquidityV2[:], false); err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}

	{
		// Serialize `liquidityAmountParam`:
		if err = enc__.Encode(liquidityAmountParam); err != nil {
			return nil, fmt.Errorf("error while marshaling liquidityAmountParam:%w", err)
		}
		// Serialize `tokenMinAParam`:
		if err = enc__.Encode(tokenMinAParam); err != nil {
			return nil, fmt.Errorf("error while marshaling tokenMinAParam:%w", err)
		}
		// Serialize `tokenMinBParam`:
		if err = enc__.Encode(tokenMinBParam); err != nil {
			return nil, fmt.Errorf("error while marshaling tokenMinBParam:%w", err)
		}
		// Serialize `remainingAccountsInfoParam` (optional):
		{
			if remainingAccountsInfoParam == nil {
				if err = enc__.WriteOption(false); err != nil {
					return nil, fmt.Errorf("error while marshaling remainingAccountsInfoParam optionality: %w", err)
				}
			} else {
				if err = enc__.WriteOption(true); err != nil {
					return nil, fmt.Errorf("error while marshaling remainingAccountsInfoParam optionality: %w", err)
				}
				if err = enc__.Encode(remainingAccountsInfoParam); err != nil {
					return nil, fmt.Errorf("error while marshaling remainingAccountsInfoParam: %w", err)
				}
			}
		}
	}

	// Add the accounts to the instruction.
	{
		// [0] = [writable] whirlpool
		metas_[0] = solanago.NewAccountMeta(whirlpool, true, false)
		// [1] = [] token_program_a
		metas_[1] = solanago.NewAccountMeta(tokenProgramA, false, false)
		// [2] = [] token_program_b
		metas_[2] = solanago.NewAccountMeta(tokenProgramB, false, false)
		// [3] = [] memo_program
		metas_[3] = solanago.NewAccountMeta(memoProgram, false, false)
		// [4] = [,signer] position_authority
		metas_[4] = solanago.NewAccountMeta(positionAuthority, false, true)
		// [5] = [writable] position
		metas_[5] = solanago.NewAccountMeta(position, true, false)
		// [6] = [] position_token_account
		metas_[6] = solanago.NewAccountMeta(positionTokenAccount, false, false)
		// [7] = [] token_mint_a
		metas_[7] = solanago.NewAccountMeta(tokenMintA, false, false)
		// [8] = [] token_mint_b
		metas_[8] = solanago.NewAccountMeta(tokenMintB, false, false)
		// [9] = [writable] token_owner_account_a
		metas_[9] = solanago.NewAccountMeta(tokenOwnerAccountA, true, false)
		// [10] = [writable] token_owner_account_b
		metas_[10] = solanago.NewAccountMeta(tokenOwnerAccountB, true, false)
		// [11] = [writable] token_vault_a
		metas_[11] = solanago.NewAccountMeta(tokenVaultA, true, false)
		// [12] = [writable] token_vault_b
		metas_[12] = solanago.NewAccountMeta(tokenVaultB, true, false)
		// [13] = [writable] tick_array_lower
		metas_[13] = solanago.NewAccountMeta(tickArrayLower, true, false)
		// [14] = [writable] tick_array_upper
		metas_[14] = solanago.NewAccountMeta(tickArrayUpper, true, false)
		// append remaining metas
		metas_ = append(metas_, remaining__...)
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		metas_,
		buf__.Bytes(),
	), nil
}

// Builds a "BuildDecreaseLiquidityV2" instruction.
// Withdraw liquidity from a position in the Whirlpool. This call also updates the position's accrued fees and rewards. //  // ### Authority // - `position_authority` - authority that owns the token corresponding to this desired position. //  // ### Parameters // - `liquidity_amount` - The total amount of Liquidity the user desires to withdraw. // - `token_min_a` - The minimum amount of tokenA the user is willing to withdraw. // - `token_min_b` - The minimum amount of tokenB the user is willing to withdraw. //  // #### Special Errors // - `LiquidityZero` - Provided liquidity amount is zero. // - `LiquidityTooHigh` - Provided liquidity exceeds u128::max. // - `TokenMinSubceeded` - The required token to perform this operation subceeds the user defined amount.
func BuildDecreaseLiquidityV2(
	// Params:
	liquidityAmountParam binary.Uint128,
	tokenMinAParam uint64,
	tokenMinBParam uint64,
	remainingAccountsInfoParam *RemainingAccountsInfo,

	// Accounts:
	whirlpool solanago.PublicKey,
	tokenProgramA solanago.PublicKey,
	tokenProgramB solanago.PublicKey,
	memoProgram solanago.PublicKey,
	positionAuthority solanago.PublicKey,
	position solanago.PublicKey,
	positionTokenAccount solanago.PublicKey,
	tokenMintA solanago.PublicKey,
	tokenMintB solanago.PublicKey,
	tokenOwnerAccountA solanago.PublicKey,
	tokenOwnerAccountB solanago.PublicKey,
	tokenVaultA solanago.PublicKey,
	tokenVaultB solanago.PublicKey,
	tickArrayLower solanago.PublicKey,
	tickArrayUpper solanago.PublicKey,
	remaining__ ...*solanago.AccountMeta,
) *solanago.GenericInstruction {
	instruction_, _ := NewDecreaseLiquidityV2Instruction(
		liquidityAmountParam,
		tokenMinAParam,
		tokenMinBParam,
		remainingAccountsInfoParam,
		whirlpool,
		tokenProgramA,
		tokenProgramB,
		memoProgram,
		positionAuthority,
		position,
		positionTokenAccount,
		tokenMintA,
		tokenMintB,
		tokenOwnerAccountA,
		tokenOwnerAccountB,
		tokenVaultA,
		tokenVaultB,
		tickArrayLower,
		tickArrayUpper,
		remaining__...,
	)
	return instruction_
}
