// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package orca_whirlpool

import (
	"bytes"
	"fmt"

	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
	programparser "github.com/yydsqu/solana-sdk/program_parser"
)

// Builds a "collect_fees" instruction.

// Collect fees accrued for this position.
//
// ### Authority
// - `position_authority` - authority that owns the token corresponding to this desired position.
type CollectFees struct {
	// Params:
	// Accounts:
	// [0] = [] whirlpool
	Whirlpool solanago.PublicKey `bin:"-"`
	// [1] = [,signer] position_authority
	PositionAuthority solanago.PublicKey `bin:"-"`
	// [2] = [writable] position
	Position solanago.PublicKey `bin:"-"`
	// [3] = [] position_token_account
	PositionTokenAccount solanago.PublicKey `bin:"-"`
	// [4] = [writable] token_owner_account_a
	TokenOwnerAccountA solanago.PublicKey `bin:"-"`
	// [5] = [writable] token_vault_a
	TokenVaultA solanago.PublicKey `bin:"-"`
	// [6] = [writable] token_owner_account_b
	TokenOwnerAccountB solanago.PublicKey `bin:"-"`
	// [7] = [writable] token_vault_b
	TokenVaultB solanago.PublicKey `bin:"-"`
	// [8] = [] token_program
	TokenProgram solanago.PublicKey `bin:"-"`
	// PublicKeySlice
	solanago.PublicKeySlice `bin:"-"`
}

func (obj CollectFees) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *CollectFees) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *CollectFees) SetAccounts(accounts solanago.PublicKeySlice) (err error) {
	if len(accounts) < 9 {
		return fmt.Errorf("too few accounts, expect %d actual %d", 9, len(accounts))
	}
	obj.Whirlpool = accounts[0]
	obj.PositionAuthority = accounts[1]
	obj.Position = accounts[2]
	obj.PositionTokenAccount = accounts[3]
	obj.TokenOwnerAccountA = accounts[4]
	obj.TokenVaultA = accounts[5]
	obj.TokenOwnerAccountB = accounts[6]
	obj.TokenVaultB = accounts[7]
	obj.TokenProgram = accounts[8]
	obj.PublicKeySlice = accounts
	return nil
}
func (obj *CollectFees) PublicKeys() solanago.PublicKeySlice {
	return obj.PublicKeySlice
}

func (*CollectFees) TypeID() binary.TypeID {
	return binary.TypeIDFromBytes(Instruction_CollectFees)
}

func (*CollectFees) NewInstance() programparser.Instruction {
	return new(CollectFees)
}

func (obj *CollectFees) GetRemainingAccounts() solanago.PublicKeySlice {
	if len(obj.PublicKeySlice) <= 9 {
		return nil
	}
	return obj.PublicKeySlice[9:]
}

// Builds a "collect_fees" instruction.
// Collect fees accrued for this position. //  // ### Authority // - `position_authority` - authority that owns the token corresponding to this desired position.
func NewCollectFeesInstruction(
	whirlpool solanago.PublicKey,
	positionAuthority solanago.PublicKey,
	position solanago.PublicKey,
	positionTokenAccount solanago.PublicKey,
	tokenOwnerAccountA solanago.PublicKey,
	tokenVaultA solanago.PublicKey,
	tokenOwnerAccountB solanago.PublicKey,
	tokenVaultB solanago.PublicKey,
	tokenProgram solanago.PublicKey,
	remaining__ ...*solanago.AccountMeta,
) (*solanago.GenericInstruction, error) {
	var (
		err    error
		buf__  = new(bytes.Buffer)
		enc__  = binary.NewBorshEncoder(buf__)
		metas_ = make(solanago.AccountMetaSlice, 9, 9+len(remaining__))
	)

	// Encode the instruction discriminator.
	if err = enc__.WriteBytes(Instruction_CollectFees[:], false); err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}

	// Add the accounts to the instruction.
	{
		// [0] = [] whirlpool
		metas_[0] = solanago.NewAccountMeta(whirlpool, false, false)
		// [1] = [,signer] position_authority
		metas_[1] = solanago.NewAccountMeta(positionAuthority, false, true)
		// [2] = [writable] position
		metas_[2] = solanago.NewAccountMeta(position, true, false)
		// [3] = [] position_token_account
		metas_[3] = solanago.NewAccountMeta(positionTokenAccount, false, false)
		// [4] = [writable] token_owner_account_a
		metas_[4] = solanago.NewAccountMeta(tokenOwnerAccountA, true, false)
		// [5] = [writable] token_vault_a
		metas_[5] = solanago.NewAccountMeta(tokenVaultA, true, false)
		// [6] = [writable] token_owner_account_b
		metas_[6] = solanago.NewAccountMeta(tokenOwnerAccountB, true, false)
		// [7] = [writable] token_vault_b
		metas_[7] = solanago.NewAccountMeta(tokenVaultB, true, false)
		// [8] = [] token_program
		metas_[8] = solanago.NewAccountMeta(tokenProgram, false, false)
		// append remaining metas
		metas_ = append(metas_, remaining__...)
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		metas_,
		buf__.Bytes(),
	), nil
}

// Builds a "BuildCollectFees" instruction.
// Collect fees accrued for this position. //  // ### Authority // - `position_authority` - authority that owns the token corresponding to this desired position.
func BuildCollectFees(
	whirlpool solanago.PublicKey,
	positionAuthority solanago.PublicKey,
	position solanago.PublicKey,
	positionTokenAccount solanago.PublicKey,
	tokenOwnerAccountA solanago.PublicKey,
	tokenVaultA solanago.PublicKey,
	tokenOwnerAccountB solanago.PublicKey,
	tokenVaultB solanago.PublicKey,
	tokenProgram solanago.PublicKey,
	remaining__ ...*solanago.AccountMeta,
) *solanago.GenericInstruction {
	instruction_, _ := NewCollectFeesInstruction(
		whirlpool,
		positionAuthority,
		position,
		positionTokenAccount,
		tokenOwnerAccountA,
		tokenVaultA,
		tokenOwnerAccountB,
		tokenVaultB,
		tokenProgram,
		remaining__...,
	)
	return instruction_
}
