// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains parsers for the types defined in the IDL.

package meteora_pools

import (
	"bytes"
	"fmt"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

type Instruction interface {
	TypeID() binary.TypeID
	SetAccounts(accounts solanago.PublicKeySlice) error
	Copy() Instruction
}

// Multiplier for the pool token. Used to normalized token with different decimal into the same precision.
type TokenMultiplier struct {
	// Multiplier for token A of the pool.
	TokenAMultiplier uint64

	// Multiplier for token B of the pool.
	TokenBMultiplier uint64

	// Record the highest token decimal in the pool. For example, Token A is 6 decimal, token B is 9 decimal. This will save value of 9.
	PrecisionFactor uint8
}

func (obj TokenMultiplier) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `TokenAMultiplier`:
	if err = encoder.Encode(obj.TokenAMultiplier); err != nil {
		return fmt.Errorf("error while marshaling TokenAMultiplier:%w", err)
	}
	// Serialize `TokenBMultiplier`:
	if err = encoder.Encode(obj.TokenBMultiplier); err != nil {
		return fmt.Errorf("error while marshaling TokenBMultiplier:%w", err)
	}
	// Serialize `PrecisionFactor`:
	if err = encoder.Encode(obj.PrecisionFactor); err != nil {
		return fmt.Errorf("error while marshaling PrecisionFactor:%w", err)
	}
	return nil
}

func (obj TokenMultiplier) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding TokenMultiplier: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *TokenMultiplier) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `TokenAMultiplier`:
	if err = decoder.Decode(&obj.TokenAMultiplier); err != nil {
		return fmt.Errorf("error while unmarshaling TokenAMultiplier:%w", err)
	}
	// Deserialize `TokenBMultiplier`:
	if err = decoder.Decode(&obj.TokenBMultiplier); err != nil {
		return fmt.Errorf("error while unmarshaling TokenBMultiplier:%w", err)
	}
	// Deserialize `PrecisionFactor`:
	if err = decoder.Decode(&obj.PrecisionFactor); err != nil {
		return fmt.Errorf("error while unmarshaling PrecisionFactor:%w", err)
	}
	return nil
}

func (obj *TokenMultiplier) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling TokenMultiplier: %w", err)
	}
	return nil
}

func UnmarshalTokenMultiplier(buf []byte) (*TokenMultiplier, error) {
	obj := new(TokenMultiplier)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Information regarding fee charges
type PoolFees struct {
	// Trade fees are extra token amounts that are held inside the token
	// accounts during a trade, making the value of liquidity tokens rise.
	// Trade fee numerator
	TradeFeeNumerator uint64

	// Trade fee denominator
	TradeFeeDenominator uint64

	// Protocol trading fees are extra token amounts that are held inside the token
	// accounts during a trade, with the equivalent in pool tokens minted to
	// the protocol of the program.
	// Protocol trade fee numerator
	ProtocolTradeFeeNumerator uint64

	// Protocol trade fee denominator
	ProtocolTradeFeeDenominator uint64
}

func (obj PoolFees) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `TradeFeeNumerator`:
	if err = encoder.Encode(obj.TradeFeeNumerator); err != nil {
		return fmt.Errorf("error while marshaling TradeFeeNumerator:%w", err)
	}
	// Serialize `TradeFeeDenominator`:
	if err = encoder.Encode(obj.TradeFeeDenominator); err != nil {
		return fmt.Errorf("error while marshaling TradeFeeDenominator:%w", err)
	}
	// Serialize `ProtocolTradeFeeNumerator`:
	if err = encoder.Encode(obj.ProtocolTradeFeeNumerator); err != nil {
		return fmt.Errorf("error while marshaling ProtocolTradeFeeNumerator:%w", err)
	}
	// Serialize `ProtocolTradeFeeDenominator`:
	if err = encoder.Encode(obj.ProtocolTradeFeeDenominator); err != nil {
		return fmt.Errorf("error while marshaling ProtocolTradeFeeDenominator:%w", err)
	}
	return nil
}

func (obj PoolFees) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding PoolFees: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *PoolFees) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `TradeFeeNumerator`:
	if err = decoder.Decode(&obj.TradeFeeNumerator); err != nil {
		return fmt.Errorf("error while unmarshaling TradeFeeNumerator:%w", err)
	}
	// Deserialize `TradeFeeDenominator`:
	if err = decoder.Decode(&obj.TradeFeeDenominator); err != nil {
		return fmt.Errorf("error while unmarshaling TradeFeeDenominator:%w", err)
	}
	// Deserialize `ProtocolTradeFeeNumerator`:
	if err = decoder.Decode(&obj.ProtocolTradeFeeNumerator); err != nil {
		return fmt.Errorf("error while unmarshaling ProtocolTradeFeeNumerator:%w", err)
	}
	// Deserialize `ProtocolTradeFeeDenominator`:
	if err = decoder.Decode(&obj.ProtocolTradeFeeDenominator); err != nil {
		return fmt.Errorf("error while unmarshaling ProtocolTradeFeeDenominator:%w", err)
	}
	return nil
}

func (obj *PoolFees) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling PoolFees: %w", err)
	}
	return nil
}

func UnmarshalPoolFees(buf []byte) (*PoolFees, error) {
	obj := new(PoolFees)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Contains information for depeg pool
type Depeg struct {
	// The virtual price of staking / interest bearing token
	BaseVirtualPrice uint64

	// The last time base_virtual_price is updated
	BaseCacheUpdated uint64

	// Type of the depeg pool
	DepegType DepegType
}

func (obj Depeg) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `BaseVirtualPrice`:
	if err = encoder.Encode(obj.BaseVirtualPrice); err != nil {
		return fmt.Errorf("error while marshaling BaseVirtualPrice:%w", err)
	}
	// Serialize `BaseCacheUpdated`:
	if err = encoder.Encode(obj.BaseCacheUpdated); err != nil {
		return fmt.Errorf("error while marshaling BaseCacheUpdated:%w", err)
	}
	// Serialize `DepegType`:
	if err = encoder.Encode(obj.DepegType); err != nil {
		return fmt.Errorf("error while marshaling DepegType:%w", err)
	}
	return nil
}

func (obj Depeg) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Depeg: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Depeg) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `BaseVirtualPrice`:
	if err = decoder.Decode(&obj.BaseVirtualPrice); err != nil {
		return fmt.Errorf("error while unmarshaling BaseVirtualPrice:%w", err)
	}
	// Deserialize `BaseCacheUpdated`:
	if err = decoder.Decode(&obj.BaseCacheUpdated); err != nil {
		return fmt.Errorf("error while unmarshaling BaseCacheUpdated:%w", err)
	}
	// Deserialize `DepegType`:
	if err = decoder.Decode(&obj.DepegType); err != nil {
		return fmt.Errorf("error while unmarshaling DepegType:%w", err)
	}
	return nil
}

func (obj *Depeg) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Depeg: %w", err)
	}
	return nil
}

func UnmarshalDepeg(buf []byte) (*Depeg, error) {
	obj := new(Depeg)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ConfigParameters struct {
	TradeFeeNumerator         uint64
	ProtocolTradeFeeNumerator uint64
	ActivationDuration        uint64
	VaultConfigKey            solanago.PublicKey
	PoolCreatorAuthority      solanago.PublicKey
	ActivationType            uint8
	Index                     uint64
	PartnerFeeNumerator       uint64
}

func (obj ConfigParameters) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `TradeFeeNumerator`:
	if err = encoder.Encode(obj.TradeFeeNumerator); err != nil {
		return fmt.Errorf("error while marshaling TradeFeeNumerator:%w", err)
	}
	// Serialize `ProtocolTradeFeeNumerator`:
	if err = encoder.Encode(obj.ProtocolTradeFeeNumerator); err != nil {
		return fmt.Errorf("error while marshaling ProtocolTradeFeeNumerator:%w", err)
	}
	// Serialize `ActivationDuration`:
	if err = encoder.Encode(obj.ActivationDuration); err != nil {
		return fmt.Errorf("error while marshaling ActivationDuration:%w", err)
	}
	// Serialize `VaultConfigKey`:
	if err = encoder.Encode(obj.VaultConfigKey); err != nil {
		return fmt.Errorf("error while marshaling VaultConfigKey:%w", err)
	}
	// Serialize `PoolCreatorAuthority`:
	if err = encoder.Encode(obj.PoolCreatorAuthority); err != nil {
		return fmt.Errorf("error while marshaling PoolCreatorAuthority:%w", err)
	}
	// Serialize `ActivationType`:
	if err = encoder.Encode(obj.ActivationType); err != nil {
		return fmt.Errorf("error while marshaling ActivationType:%w", err)
	}
	// Serialize `Index`:
	if err = encoder.Encode(obj.Index); err != nil {
		return fmt.Errorf("error while marshaling Index:%w", err)
	}
	// Serialize `PartnerFeeNumerator`:
	if err = encoder.Encode(obj.PartnerFeeNumerator); err != nil {
		return fmt.Errorf("error while marshaling PartnerFeeNumerator:%w", err)
	}
	return nil
}

func (obj ConfigParameters) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding ConfigParameters: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *ConfigParameters) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `TradeFeeNumerator`:
	if err = decoder.Decode(&obj.TradeFeeNumerator); err != nil {
		return fmt.Errorf("error while unmarshaling TradeFeeNumerator:%w", err)
	}
	// Deserialize `ProtocolTradeFeeNumerator`:
	if err = decoder.Decode(&obj.ProtocolTradeFeeNumerator); err != nil {
		return fmt.Errorf("error while unmarshaling ProtocolTradeFeeNumerator:%w", err)
	}
	// Deserialize `ActivationDuration`:
	if err = decoder.Decode(&obj.ActivationDuration); err != nil {
		return fmt.Errorf("error while unmarshaling ActivationDuration:%w", err)
	}
	// Deserialize `VaultConfigKey`:
	if err = decoder.Decode(&obj.VaultConfigKey); err != nil {
		return fmt.Errorf("error while unmarshaling VaultConfigKey:%w", err)
	}
	// Deserialize `PoolCreatorAuthority`:
	if err = decoder.Decode(&obj.PoolCreatorAuthority); err != nil {
		return fmt.Errorf("error while unmarshaling PoolCreatorAuthority:%w", err)
	}
	// Deserialize `ActivationType`:
	if err = decoder.Decode(&obj.ActivationType); err != nil {
		return fmt.Errorf("error while unmarshaling ActivationType:%w", err)
	}
	// Deserialize `Index`:
	if err = decoder.Decode(&obj.Index); err != nil {
		return fmt.Errorf("error while unmarshaling Index:%w", err)
	}
	// Deserialize `PartnerFeeNumerator`:
	if err = decoder.Decode(&obj.PartnerFeeNumerator); err != nil {
		return fmt.Errorf("error while unmarshaling PartnerFeeNumerator:%w", err)
	}
	return nil
}

func (obj *ConfigParameters) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ConfigParameters: %w", err)
	}
	return nil
}

func UnmarshalConfigParameters(buf []byte) (*ConfigParameters, error) {
	obj := new(ConfigParameters)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type CustomizableParams struct {
	// Trading fee.
	TradeFeeNumerator uint32

	// The pool start trading.
	ActivationPoint *uint64 `bin:"optional"`

	// Whether the pool support alpha vault
	HasAlphaVault bool

	// Activation type
	ActivationType uint8

	// Padding
	Padding [90]uint8
}

func (obj CustomizableParams) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `TradeFeeNumerator`:
	if err = encoder.Encode(obj.TradeFeeNumerator); err != nil {
		return fmt.Errorf("error while marshaling TradeFeeNumerator:%w", err)
	}
	// Serialize `ActivationPoint` (optional):
	{
		if obj.ActivationPoint == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling ActivationPoint optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling ActivationPoint optionality: %w", err)
			}
			if err = encoder.Encode(obj.ActivationPoint); err != nil {
				return fmt.Errorf("error while marshaling ActivationPoint: %w", err)
			}
		}
	}
	// Serialize `HasAlphaVault`:
	if err = encoder.Encode(obj.HasAlphaVault); err != nil {
		return fmt.Errorf("error while marshaling HasAlphaVault:%w", err)
	}
	// Serialize `ActivationType`:
	if err = encoder.Encode(obj.ActivationType); err != nil {
		return fmt.Errorf("error while marshaling ActivationType:%w", err)
	}
	// Serialize `Padding`:
	if err = encoder.Encode(obj.Padding); err != nil {
		return fmt.Errorf("error while marshaling Padding:%w", err)
	}
	return nil
}

func (obj CustomizableParams) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding CustomizableParams: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *CustomizableParams) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `TradeFeeNumerator`:
	if err = decoder.Decode(&obj.TradeFeeNumerator); err != nil {
		return fmt.Errorf("error while unmarshaling TradeFeeNumerator:%w", err)
	}
	// Deserialize `ActivationPoint` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling ActivationPoint:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.ActivationPoint); err != nil {
				return fmt.Errorf("error while unmarshaling ActivationPoint:%w", err)
			}
		}
	}
	// Deserialize `HasAlphaVault`:
	if err = decoder.Decode(&obj.HasAlphaVault); err != nil {
		return fmt.Errorf("error while unmarshaling HasAlphaVault:%w", err)
	}
	// Deserialize `ActivationType`:
	if err = decoder.Decode(&obj.ActivationType); err != nil {
		return fmt.Errorf("error while unmarshaling ActivationType:%w", err)
	}
	// Deserialize `Padding`:
	if err = decoder.Decode(&obj.Padding); err != nil {
		return fmt.Errorf("error while unmarshaling Padding:%w", err)
	}
	return nil
}

func (obj *CustomizableParams) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CustomizableParams: %w", err)
	}
	return nil
}

func UnmarshalCustomizableParams(buf []byte) (*CustomizableParams, error) {
	obj := new(CustomizableParams)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Padding for future pool fields
type Padding struct {
	// Padding 0
	Padding0 [6]uint8

	// Padding 1
	Padding1 [21]uint64

	// Padding 2
	Padding2 [21]uint64
}

func (obj Padding) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Padding0`:
	if err = encoder.Encode(obj.Padding0); err != nil {
		return fmt.Errorf("error while marshaling Padding0:%w", err)
	}
	// Serialize `Padding1`:
	if err = encoder.Encode(obj.Padding1); err != nil {
		return fmt.Errorf("error while marshaling Padding1:%w", err)
	}
	// Serialize `Padding2`:
	if err = encoder.Encode(obj.Padding2); err != nil {
		return fmt.Errorf("error while marshaling Padding2:%w", err)
	}
	return nil
}

func (obj Padding) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Padding: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Padding) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Padding0`:
	if err = decoder.Decode(&obj.Padding0); err != nil {
		return fmt.Errorf("error while unmarshaling Padding0:%w", err)
	}
	// Deserialize `Padding1`:
	if err = decoder.Decode(&obj.Padding1); err != nil {
		return fmt.Errorf("error while unmarshaling Padding1:%w", err)
	}
	// Deserialize `Padding2`:
	if err = decoder.Decode(&obj.Padding2); err != nil {
		return fmt.Errorf("error while unmarshaling Padding2:%w", err)
	}
	return nil
}

func (obj *Padding) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Padding: %w", err)
	}
	return nil
}

func UnmarshalPadding(buf []byte) (*Padding, error) {
	obj := new(Padding)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type PartnerInfo struct {
	FeeNumerator     uint64
	PartnerAuthority solanago.PublicKey
	PendingFeeA      uint64
	PendingFeeB      uint64
}

func (obj PartnerInfo) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `FeeNumerator`:
	if err = encoder.Encode(obj.FeeNumerator); err != nil {
		return fmt.Errorf("error while marshaling FeeNumerator:%w", err)
	}
	// Serialize `PartnerAuthority`:
	if err = encoder.Encode(obj.PartnerAuthority); err != nil {
		return fmt.Errorf("error while marshaling PartnerAuthority:%w", err)
	}
	// Serialize `PendingFeeA`:
	if err = encoder.Encode(obj.PendingFeeA); err != nil {
		return fmt.Errorf("error while marshaling PendingFeeA:%w", err)
	}
	// Serialize `PendingFeeB`:
	if err = encoder.Encode(obj.PendingFeeB); err != nil {
		return fmt.Errorf("error while marshaling PendingFeeB:%w", err)
	}
	return nil
}

func (obj PartnerInfo) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding PartnerInfo: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *PartnerInfo) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `FeeNumerator`:
	if err = decoder.Decode(&obj.FeeNumerator); err != nil {
		return fmt.Errorf("error while unmarshaling FeeNumerator:%w", err)
	}
	// Deserialize `PartnerAuthority`:
	if err = decoder.Decode(&obj.PartnerAuthority); err != nil {
		return fmt.Errorf("error while unmarshaling PartnerAuthority:%w", err)
	}
	// Deserialize `PendingFeeA`:
	if err = decoder.Decode(&obj.PendingFeeA); err != nil {
		return fmt.Errorf("error while unmarshaling PendingFeeA:%w", err)
	}
	// Deserialize `PendingFeeB`:
	if err = decoder.Decode(&obj.PendingFeeB); err != nil {
		return fmt.Errorf("error while unmarshaling PendingFeeB:%w", err)
	}
	return nil
}

func (obj *PartnerInfo) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling PartnerInfo: %w", err)
	}
	return nil
}

func UnmarshalPartnerInfo(buf []byte) (*PartnerInfo, error) {
	obj := new(PartnerInfo)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type Bootstrapping struct {
	// Activation point, can be slot or timestamp
	ActivationPoint uint64

	// Whitelisted vault to be able to buy pool before activation_point
	WhitelistedVault solanago.PublicKey

	// Need to store pool creator in lauch pool, so they can modify liquidity before activation_point
	PoolCreator solanago.PublicKey

	// Activation type, 0 means by slot, 1 means by timestamp
	ActivationType uint8
}

func (obj Bootstrapping) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `ActivationPoint`:
	if err = encoder.Encode(obj.ActivationPoint); err != nil {
		return fmt.Errorf("error while marshaling ActivationPoint:%w", err)
	}
	// Serialize `WhitelistedVault`:
	if err = encoder.Encode(obj.WhitelistedVault); err != nil {
		return fmt.Errorf("error while marshaling WhitelistedVault:%w", err)
	}
	// Serialize `PoolCreator`:
	if err = encoder.Encode(obj.PoolCreator); err != nil {
		return fmt.Errorf("error while marshaling PoolCreator:%w", err)
	}
	// Serialize `ActivationType`:
	if err = encoder.Encode(obj.ActivationType); err != nil {
		return fmt.Errorf("error while marshaling ActivationType:%w", err)
	}
	return nil
}

func (obj Bootstrapping) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Bootstrapping: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Bootstrapping) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `ActivationPoint`:
	if err = decoder.Decode(&obj.ActivationPoint); err != nil {
		return fmt.Errorf("error while unmarshaling ActivationPoint:%w", err)
	}
	// Deserialize `WhitelistedVault`:
	if err = decoder.Decode(&obj.WhitelistedVault); err != nil {
		return fmt.Errorf("error while unmarshaling WhitelistedVault:%w", err)
	}
	// Deserialize `PoolCreator`:
	if err = decoder.Decode(&obj.PoolCreator); err != nil {
		return fmt.Errorf("error while unmarshaling PoolCreator:%w", err)
	}
	// Deserialize `ActivationType`:
	if err = decoder.Decode(&obj.ActivationType); err != nil {
		return fmt.Errorf("error while unmarshaling ActivationType:%w", err)
	}
	return nil
}

func (obj *Bootstrapping) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Bootstrapping: %w", err)
	}
	return nil
}

func UnmarshalBootstrapping(buf []byte) (*Bootstrapping, error) {
	obj := new(Bootstrapping)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Type of the activation
type ActivationType binary.BorshEnum

const (
	ActivationType_Slot ActivationType = iota
	ActivationType_Timestamp
)

func (value ActivationType) String() string {
	switch value {
	case ActivationType_Slot:
		return "Slot"
	case ActivationType_Timestamp:
		return "Timestamp"
	default:
		return ""
	}
}

// Rounding direction
type RoundDirection binary.BorshEnum

const (
	RoundDirection_Floor RoundDirection = iota
	RoundDirection_Ceiling
)

func (value RoundDirection) String() string {
	switch value {
	case RoundDirection_Floor:
		return "Floor"
	case RoundDirection_Ceiling:
		return "Ceiling"
	default:
		return ""
	}
}

// Trade (swap) direction
type TradeDirection binary.BorshEnum

const (
	TradeDirection_AtoB TradeDirection = iota
	TradeDirection_BtoA
)

func (value TradeDirection) String() string {
	switch value {
	case TradeDirection_AtoB:
		return "AtoB"
	case TradeDirection_BtoA:
		return "BtoA"
	default:
		return ""
	}
}

// Type of the swap curve
// The "isNewCurveType" interface for the "NewCurveType" complex enum.
type NewCurveType interface {
	isNewCurveType()
}

type newCurveTypeEnumContainer struct {
	Enum            binary.BorshEnum `bin:"enum"`
	ConstantProduct NewCurveType_ConstantProduct
	Stable          NewCurveType_Stable
	NewCurve        NewCurveType_NewCurve
}

func DecodeNewCurveType(decoder *binary.Decoder) (NewCurveType, error) {
	{
		tmp := new(newCurveTypeEnumContainer)
		err := decoder.Decode(tmp)
		if err != nil {
			return nil, fmt.Errorf("failed parsing NewCurveType: %w", err)
		}
		switch tmp.Enum {
		case 0:
			return (*NewCurveType_ConstantProduct)(&tmp.Enum), nil
		case 1:
			return &tmp.Stable, nil
		case 2:
			return &tmp.NewCurve, nil
		default:
			return nil, fmt.Errorf("NewCurveType: unknown enum index: %v", tmp.Enum)
		}
	}
}

func EncodeNewCurveType(encoder *binary.Encoder, value NewCurveType) error {
	{
		tmp := newCurveTypeEnumContainer{}
		switch realvalue := value.(type) {
		case *NewCurveType_ConstantProduct:
			tmp.Enum = 0
			tmp.ConstantProduct = *realvalue
		case *NewCurveType_Stable:
			tmp.Enum = 1
			tmp.Stable = *realvalue
		case *NewCurveType_NewCurve:
			tmp.Enum = 2
			tmp.NewCurve = *realvalue
		}
		return encoder.Encode(tmp)
	}
}

type NewCurveType_ConstantProduct uint8

func (obj NewCurveType_ConstantProduct) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *NewCurveType_ConstantProduct) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (_ *NewCurveType_ConstantProduct) isNewCurveType() {}

// Variant "Stable" of enum "NewCurveType"
type NewCurveType_Stable struct {
	Amp                     uint64          `json:"amp"`
	TokenMultiplier         TokenMultiplier `json:"tokenMultiplier"`
	Depeg                   Depeg           `json:"depeg"`
	LastAmpUpdatedTimestamp uint64          `json:"lastAmpUpdatedTimestamp"`
}

func (obj NewCurveType_Stable) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Amp`:
	if err = encoder.Encode(obj.Amp); err != nil {
		return fmt.Errorf("error while marshaling Amp:%w", err)
	}
	// Serialize `TokenMultiplier`:
	if err = encoder.Encode(obj.TokenMultiplier); err != nil {
		return fmt.Errorf("error while marshaling TokenMultiplier:%w", err)
	}
	// Serialize `Depeg`:
	if err = encoder.Encode(obj.Depeg); err != nil {
		return fmt.Errorf("error while marshaling Depeg:%w", err)
	}
	// Serialize `LastAmpUpdatedTimestamp`:
	if err = encoder.Encode(obj.LastAmpUpdatedTimestamp); err != nil {
		return fmt.Errorf("error while marshaling LastAmpUpdatedTimestamp:%w", err)
	}
	return nil
}

func (obj NewCurveType_Stable) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding NewCurveType_Stable: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *NewCurveType_Stable) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Amp`:
	if err = decoder.Decode(&obj.Amp); err != nil {
		return fmt.Errorf("error while unmarshaling Amp:%w", err)
	}
	// Deserialize `TokenMultiplier`:
	if err = decoder.Decode(&obj.TokenMultiplier); err != nil {
		return fmt.Errorf("error while unmarshaling TokenMultiplier:%w", err)
	}
	// Deserialize `Depeg`:
	if err = decoder.Decode(&obj.Depeg); err != nil {
		return fmt.Errorf("error while unmarshaling Depeg:%w", err)
	}
	// Deserialize `LastAmpUpdatedTimestamp`:
	if err = decoder.Decode(&obj.LastAmpUpdatedTimestamp); err != nil {
		return fmt.Errorf("error while unmarshaling LastAmpUpdatedTimestamp:%w", err)
	}
	return nil
}

func (obj *NewCurveType_Stable) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling NewCurveType_Stable: %w", err)
	}
	return nil
}

func UnmarshalNewCurveType_Stable(buf []byte) (*NewCurveType_Stable, error) {
	obj := new(NewCurveType_Stable)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *NewCurveType_Stable) isNewCurveType() {}

// Variant "NewCurve" of enum "NewCurveType"
type NewCurveType_NewCurve struct {
	FieldOne uint64 `json:"fieldOne"`
	FieldTwo uint64 `json:"fieldTwo"`
}

func (obj NewCurveType_NewCurve) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `FieldOne`:
	if err = encoder.Encode(obj.FieldOne); err != nil {
		return fmt.Errorf("error while marshaling FieldOne:%w", err)
	}
	// Serialize `FieldTwo`:
	if err = encoder.Encode(obj.FieldTwo); err != nil {
		return fmt.Errorf("error while marshaling FieldTwo:%w", err)
	}
	return nil
}

func (obj NewCurveType_NewCurve) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding NewCurveType_NewCurve: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *NewCurveType_NewCurve) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `FieldOne`:
	if err = decoder.Decode(&obj.FieldOne); err != nil {
		return fmt.Errorf("error while unmarshaling FieldOne:%w", err)
	}
	// Deserialize `FieldTwo`:
	if err = decoder.Decode(&obj.FieldTwo); err != nil {
		return fmt.Errorf("error while unmarshaling FieldTwo:%w", err)
	}
	return nil
}

func (obj *NewCurveType_NewCurve) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling NewCurveType_NewCurve: %w", err)
	}
	return nil
}

func UnmarshalNewCurveType_NewCurve(buf []byte) (*NewCurveType_NewCurve, error) {
	obj := new(NewCurveType_NewCurve)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *NewCurveType_NewCurve) isNewCurveType() {}

// Type of the swap curve
// The "isCurveType" interface for the "CurveType" complex enum.
type CurveType interface {
	isCurveType()
}

type curveTypeEnumContainer struct {
	Enum            binary.BorshEnum `bin:"enum"`
	ConstantProduct CurveType_ConstantProduct
	Stable          CurveType_Stable
}

func DecodeCurveType(decoder *binary.Decoder) (CurveType, error) {
	{
		tmp := new(curveTypeEnumContainer)
		err := decoder.Decode(tmp)
		if err != nil {
			return nil, fmt.Errorf("failed parsing CurveType: %w", err)
		}
		switch tmp.Enum {
		case 0:
			return (*CurveType_ConstantProduct)(&tmp.Enum), nil
		case 1:
			return &tmp.Stable, nil
		default:
			return nil, fmt.Errorf("CurveType: unknown enum index: %v", tmp.Enum)
		}
	}
}

func EncodeCurveType(encoder *binary.Encoder, value CurveType) error {
	{
		tmp := curveTypeEnumContainer{}
		switch realvalue := value.(type) {
		case *CurveType_ConstantProduct:
			tmp.Enum = 0
			tmp.ConstantProduct = *realvalue
		case *CurveType_Stable:
			tmp.Enum = 1
			tmp.Stable = *realvalue
		}
		return encoder.Encode(tmp)
	}
}

type CurveType_ConstantProduct uint8

func (obj CurveType_ConstantProduct) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *CurveType_ConstantProduct) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (_ *CurveType_ConstantProduct) isCurveType() {}

// Variant "Stable" of enum "CurveType"
type CurveType_Stable struct {
	Amp                     uint64          `json:"amp"`
	TokenMultiplier         TokenMultiplier `json:"tokenMultiplier"`
	Depeg                   Depeg           `json:"depeg"`
	LastAmpUpdatedTimestamp uint64          `json:"lastAmpUpdatedTimestamp"`
}

func (obj CurveType_Stable) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Amp`:
	if err = encoder.Encode(obj.Amp); err != nil {
		return fmt.Errorf("error while marshaling Amp:%w", err)
	}
	// Serialize `TokenMultiplier`:
	if err = encoder.Encode(obj.TokenMultiplier); err != nil {
		return fmt.Errorf("error while marshaling TokenMultiplier:%w", err)
	}
	// Serialize `Depeg`:
	if err = encoder.Encode(obj.Depeg); err != nil {
		return fmt.Errorf("error while marshaling Depeg:%w", err)
	}
	// Serialize `LastAmpUpdatedTimestamp`:
	if err = encoder.Encode(obj.LastAmpUpdatedTimestamp); err != nil {
		return fmt.Errorf("error while marshaling LastAmpUpdatedTimestamp:%w", err)
	}
	return nil
}

func (obj CurveType_Stable) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding CurveType_Stable: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *CurveType_Stable) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Amp`:
	if err = decoder.Decode(&obj.Amp); err != nil {
		return fmt.Errorf("error while unmarshaling Amp:%w", err)
	}
	// Deserialize `TokenMultiplier`:
	if err = decoder.Decode(&obj.TokenMultiplier); err != nil {
		return fmt.Errorf("error while unmarshaling TokenMultiplier:%w", err)
	}
	// Deserialize `Depeg`:
	if err = decoder.Decode(&obj.Depeg); err != nil {
		return fmt.Errorf("error while unmarshaling Depeg:%w", err)
	}
	// Deserialize `LastAmpUpdatedTimestamp`:
	if err = decoder.Decode(&obj.LastAmpUpdatedTimestamp); err != nil {
		return fmt.Errorf("error while unmarshaling LastAmpUpdatedTimestamp:%w", err)
	}
	return nil
}

func (obj *CurveType_Stable) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CurveType_Stable: %w", err)
	}
	return nil
}

func UnmarshalCurveType_Stable(buf []byte) (*CurveType_Stable, error) {
	obj := new(CurveType_Stable)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *CurveType_Stable) isCurveType() {}

// Type of depeg pool
type DepegType binary.BorshEnum

const (
	DepegType_None DepegType = iota
	DepegType_Marinade
	DepegType_Lido
	DepegType_SplStake
)

func (value DepegType) String() string {
	switch value {
	case DepegType_None:
		return "None"
	case DepegType_Marinade:
		return "Marinade"
	case DepegType_Lido:
		return "Lido"
	case DepegType_SplStake:
		return "SplStake"
	default:
		return ""
	}
}

// Round up, down
type Rounding binary.BorshEnum

const (
	Rounding_Up Rounding = iota
	Rounding_Down
)

func (value Rounding) String() string {
	switch value {
	case Rounding_Up:
		return "Up"
	case Rounding_Down:
		return "Down"
	default:
		return ""
	}
}

// Pool type
type PoolType binary.BorshEnum

const (
	PoolType_Permissioned PoolType = iota
	PoolType_Permissionless
)

func (value PoolType) String() string {
	switch value {
	case PoolType_Permissioned:
		return "Permissioned"
	case PoolType_Permissionless:
		return "Permissionless"
	default:
		return ""
	}
}
