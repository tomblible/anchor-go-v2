// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package meteora_pools

import (
	"bytes"
	"fmt"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
	programparser "github.com/yydsqu/solana-sdk/program_parser"
)

// Builds a "swap" instruction.

// Swap token A to B, or vice versa. An amount of trading fee will be charged for liquidity provider, and the admin of the pool.
type Swap struct {
	// Params:
	InAmount         uint64
	MinimumOutAmount uint64
	// Accounts:
	// [0] = [writable] pool
	Pool solanago.PublicKey `bin:"-"`
	// [1] = [writable] user_source_token
	UserSourceToken solanago.PublicKey `bin:"-"`
	// [2] = [writable] user_destination_token
	UserDestinationToken solanago.PublicKey `bin:"-"`
	// [3] = [writable] a_vault
	AVault solanago.PublicKey `bin:"-"`
	// [4] = [writable] b_vault
	BVault solanago.PublicKey `bin:"-"`
	// [5] = [writable] a_token_vault
	ATokenVault solanago.PublicKey `bin:"-"`
	// [6] = [writable] b_token_vault
	BTokenVault solanago.PublicKey `bin:"-"`
	// [7] = [writable] a_vault_lp_mint
	AVaultLpMint solanago.PublicKey `bin:"-"`
	// [8] = [writable] b_vault_lp_mint
	BVaultLpMint solanago.PublicKey `bin:"-"`
	// [9] = [writable] a_vault_lp
	AVaultLp solanago.PublicKey `bin:"-"`
	// [10] = [writable] b_vault_lp
	BVaultLp solanago.PublicKey `bin:"-"`
	// [11] = [writable] protocol_token_fee
	ProtocolTokenFee solanago.PublicKey `bin:"-"`
	// [12] = [,signer] user
	User solanago.PublicKey `bin:"-"`
	// [13] = [] vault_program
	VaultProgram solanago.PublicKey `bin:"-"`
	// [14] = [] token_program
	TokenProgram solanago.PublicKey `bin:"-"`
	// PublicKeySlice
	solanago.PublicKeySlice `bin:"-"`
}

func (obj Swap) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `inAmountParam`:
	if err = encoder.Encode(obj.InAmount); err != nil {
		return fmt.Errorf("error while marshaling inAmountParam:%w", err)
	}
	// Serialize `minimumOutAmountParam`:
	if err = encoder.Encode(obj.MinimumOutAmount); err != nil {
		return fmt.Errorf("error while marshaling minimumOutAmountParam:%w", err)
	}
	return nil
}

func (obj *Swap) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `InAmount`:
	if err = decoder.Decode(&obj.InAmount); err != nil {
		return fmt.Errorf("error while unmarshaling InAmount:%w", err)
	}
	// Deserialize `MinimumOutAmount`:
	if err = decoder.Decode(&obj.MinimumOutAmount); err != nil {
		return fmt.Errorf("error while unmarshaling MinimumOutAmount:%w", err)
	}
	return nil
}

func (obj *Swap) SetAccounts(accounts solanago.PublicKeySlice) (err error) {
	if len(accounts) < 15 {
		return fmt.Errorf("too few accounts, expect %d actual %d", 15, len(accounts))
	}
	obj.Pool = accounts[0]
	obj.UserSourceToken = accounts[1]
	obj.UserDestinationToken = accounts[2]
	obj.AVault = accounts[3]
	obj.BVault = accounts[4]
	obj.ATokenVault = accounts[5]
	obj.BTokenVault = accounts[6]
	obj.AVaultLpMint = accounts[7]
	obj.BVaultLpMint = accounts[8]
	obj.AVaultLp = accounts[9]
	obj.BVaultLp = accounts[10]
	obj.ProtocolTokenFee = accounts[11]
	obj.User = accounts[12]
	obj.VaultProgram = accounts[13]
	obj.TokenProgram = accounts[14]
	obj.PublicKeySlice = accounts
	return nil
}
func (obj *Swap) PublicKeys() solanago.PublicKeySlice {
	return obj.PublicKeySlice
}

func (*Swap) TypeID() binary.TypeID {
	return binary.TypeIDFromBytes(Instruction_Swap)
}

func (*Swap) NewInstance() programparser.Instruction {
	return new(Swap)
}

func (obj *Swap) GetRemainingAccounts() solanago.PublicKeySlice {
	return obj.PublicKeySlice[15:]
}

// Builds a "swap" instruction.
// Swap token A to B, or vice versa. An amount of trading fee will be charged for liquidity provider, and the admin of the pool.
func NewSwapInstruction(
	// Params:
	inAmountParam uint64,
	minimumOutAmountParam uint64,

	// Accounts:
	pool solanago.PublicKey,
	userSourceToken solanago.PublicKey,
	userDestinationToken solanago.PublicKey,
	aVault solanago.PublicKey,
	bVault solanago.PublicKey,
	aTokenVault solanago.PublicKey,
	bTokenVault solanago.PublicKey,
	aVaultLpMint solanago.PublicKey,
	bVaultLpMint solanago.PublicKey,
	aVaultLp solanago.PublicKey,
	bVaultLp solanago.PublicKey,
	protocolTokenFee solanago.PublicKey,
	user solanago.PublicKey,
	vaultProgram solanago.PublicKey,
	tokenProgram solanago.PublicKey,
	remaining__ ...*solanago.AccountMeta,
) (*solanago.GenericInstruction, error) {
	var (
		err    error
		buf__  = new(bytes.Buffer)
		enc__  = binary.NewBorshEncoder(buf__)
		metas_ = make(solanago.AccountMetaSlice, 15, 15+len(remaining__))
	)

	// Encode the instruction discriminator.
	if err = enc__.WriteBytes(Instruction_Swap[:], false); err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}

	{
		// Serialize `inAmountParam`:
		if err = enc__.Encode(inAmountParam); err != nil {
			return nil, fmt.Errorf("error while marshaling inAmountParam:%w", err)
		}
		// Serialize `minimumOutAmountParam`:
		if err = enc__.Encode(minimumOutAmountParam); err != nil {
			return nil, fmt.Errorf("error while marshaling minimumOutAmountParam:%w", err)
		}
	}

	// Add the accounts to the instruction.
	{
		// [0] = [writable] pool
		// Pool account (PDA)
		metas_[0] = solanago.NewAccountMeta(pool, true, false)
		// [1] = [writable] user_source_token
		// User token account. Token from this account will be transfer into the vault by the pool in exchange for another token of the pool.
		metas_[1] = solanago.NewAccountMeta(userSourceToken, true, false)
		// [2] = [writable] user_destination_token
		// User token account. The exchanged token will be transfer into this account from the pool.
		metas_[2] = solanago.NewAccountMeta(userDestinationToken, true, false)
		// [3] = [writable] a_vault
		// Vault account for token a. token a of the pool will be deposit / withdraw from this vault account.
		metas_[3] = solanago.NewAccountMeta(aVault, true, false)
		// [4] = [writable] b_vault
		// Vault account for token b. token b of the pool will be deposit / withdraw from this vault account.
		metas_[4] = solanago.NewAccountMeta(bVault, true, false)
		// [5] = [writable] a_token_vault
		// Token vault account of vault A
		metas_[5] = solanago.NewAccountMeta(aTokenVault, true, false)
		// [6] = [writable] b_token_vault
		// Token vault account of vault B
		metas_[6] = solanago.NewAccountMeta(bTokenVault, true, false)
		// [7] = [writable] a_vault_lp_mint
		// Lp token mint of vault a
		metas_[7] = solanago.NewAccountMeta(aVaultLpMint, true, false)
		// [8] = [writable] b_vault_lp_mint
		// Lp token mint of vault b
		metas_[8] = solanago.NewAccountMeta(bVaultLpMint, true, false)
		// [9] = [writable] a_vault_lp
		// LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault.
		metas_[9] = solanago.NewAccountMeta(aVaultLp, true, false)
		// [10] = [writable] b_vault_lp
		// LP token account of vault B. Used to receive/burn the vault LP upon deposit/withdraw from the vault.
		metas_[10] = solanago.NewAccountMeta(bVaultLp, true, false)
		// [11] = [writable] protocol_token_fee
		// Protocol fee token account. Used to receive trading fee. It's mint field must matched with user_source_token mint field.
		metas_[11] = solanago.NewAccountMeta(protocolTokenFee, true, false)
		// [12] = [,signer] user
		// User account. Must be owner of user_source_token.
		metas_[12] = solanago.NewAccountMeta(user, false, true)
		// [13] = [] vault_program
		// Vault program. the pool will deposit/withdraw liquidity from the vault.
		metas_[13] = solanago.NewAccountMeta(vaultProgram, false, false)
		// [14] = [] token_program
		// Token program.
		metas_[14] = solanago.NewAccountMeta(tokenProgram, false, false)
		// append remaining metas
		metas_ = append(metas_, remaining__...)
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		metas_,
		buf__.Bytes(),
	), nil
}

// Builds a "BuildSwap" instruction.
// Swap token A to B, or vice versa. An amount of trading fee will be charged for liquidity provider, and the admin of the pool.
func BuildSwap(
	// Params:
	inAmountParam uint64,
	minimumOutAmountParam uint64,

	// Accounts:
	pool solanago.PublicKey,
	userSourceToken solanago.PublicKey,
	userDestinationToken solanago.PublicKey,
	aVault solanago.PublicKey,
	bVault solanago.PublicKey,
	aTokenVault solanago.PublicKey,
	bTokenVault solanago.PublicKey,
	aVaultLpMint solanago.PublicKey,
	bVaultLpMint solanago.PublicKey,
	aVaultLp solanago.PublicKey,
	bVaultLp solanago.PublicKey,
	protocolTokenFee solanago.PublicKey,
	user solanago.PublicKey,
	vaultProgram solanago.PublicKey,
	tokenProgram solanago.PublicKey,
	remaining__ ...*solanago.AccountMeta,
) *solanago.GenericInstruction {
	instruction_, _ := NewSwapInstruction(
		inAmountParam,
		minimumOutAmountParam,
		pool,
		userSourceToken,
		userDestinationToken,
		aVault,
		bVault,
		aTokenVault,
		bTokenVault,
		aVaultLpMint,
		bVaultLpMint,
		aVaultLp,
		bVaultLp,
		protocolTokenFee,
		user,
		vaultProgram,
		tokenProgram,
		remaining__...,
	)
	return instruction_
}
