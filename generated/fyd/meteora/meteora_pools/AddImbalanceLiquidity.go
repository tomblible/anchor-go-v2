// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package meteora_pools

import (
	"bytes"
	"fmt"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
	programparser "github.com/yydsqu/solana-sdk/program_parser"
)

// Builds a "add_imbalance_liquidity" instruction.

// Deposit tokens to the pool in an imbalance ratio. Only supported by pool with stable swap curve.
type AddImbalanceLiquidity struct {
	// Params:
	MinimumPoolTokenAmount uint64
	TokenAAmount           uint64
	TokenBAmount           uint64
	// Accounts:
	// [0] = [writable] pool
	Pool solanago.PublicKey `bin:"-"`
	// [1] = [writable] lp_mint
	LpMint solanago.PublicKey `bin:"-"`
	// [2] = [writable] user_pool_lp
	UserPoolLp solanago.PublicKey `bin:"-"`
	// [3] = [writable] a_vault_lp
	AVaultLp solanago.PublicKey `bin:"-"`
	// [4] = [writable] b_vault_lp
	BVaultLp solanago.PublicKey `bin:"-"`
	// [5] = [writable] a_vault
	AVault solanago.PublicKey `bin:"-"`
	// [6] = [writable] b_vault
	BVault solanago.PublicKey `bin:"-"`
	// [7] = [writable] a_vault_lp_mint
	AVaultLpMint solanago.PublicKey `bin:"-"`
	// [8] = [writable] b_vault_lp_mint
	BVaultLpMint solanago.PublicKey `bin:"-"`
	// [9] = [writable] a_token_vault
	ATokenVault solanago.PublicKey `bin:"-"`
	// [10] = [writable] b_token_vault
	BTokenVault solanago.PublicKey `bin:"-"`
	// [11] = [writable] user_a_token
	UserAToken solanago.PublicKey `bin:"-"`
	// [12] = [writable] user_b_token
	UserBToken solanago.PublicKey `bin:"-"`
	// [13] = [,signer] user
	User solanago.PublicKey `bin:"-"`
	// [14] = [] vault_program
	VaultProgram solanago.PublicKey `bin:"-"`
	// [15] = [] token_program
	TokenProgram solanago.PublicKey `bin:"-"`
	// PublicKeySlice
	solanago.PublicKeySlice `bin:"-"`
}

func (obj AddImbalanceLiquidity) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `minimumPoolTokenAmountParam`:
	if err = encoder.Encode(obj.MinimumPoolTokenAmount); err != nil {
		return fmt.Errorf("error while marshaling minimumPoolTokenAmountParam:%w", err)
	}
	// Serialize `tokenAAmountParam`:
	if err = encoder.Encode(obj.TokenAAmount); err != nil {
		return fmt.Errorf("error while marshaling tokenAAmountParam:%w", err)
	}
	// Serialize `tokenBAmountParam`:
	if err = encoder.Encode(obj.TokenBAmount); err != nil {
		return fmt.Errorf("error while marshaling tokenBAmountParam:%w", err)
	}
	return nil
}

func (obj *AddImbalanceLiquidity) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `MinimumPoolTokenAmount`:
	if err = decoder.Decode(&obj.MinimumPoolTokenAmount); err != nil {
		return fmt.Errorf("error while unmarshaling MinimumPoolTokenAmount:%w", err)
	}
	// Deserialize `TokenAAmount`:
	if err = decoder.Decode(&obj.TokenAAmount); err != nil {
		return fmt.Errorf("error while unmarshaling TokenAAmount:%w", err)
	}
	// Deserialize `TokenBAmount`:
	if err = decoder.Decode(&obj.TokenBAmount); err != nil {
		return fmt.Errorf("error while unmarshaling TokenBAmount:%w", err)
	}
	return nil
}

func (obj *AddImbalanceLiquidity) SetAccounts(accounts solanago.PublicKeySlice) (err error) {
	if len(accounts) < 16 {
		return fmt.Errorf("too few accounts, expect %d actual %d", 16, len(accounts))
	}
	obj.Pool = accounts[0]
	obj.LpMint = accounts[1]
	obj.UserPoolLp = accounts[2]
	obj.AVaultLp = accounts[3]
	obj.BVaultLp = accounts[4]
	obj.AVault = accounts[5]
	obj.BVault = accounts[6]
	obj.AVaultLpMint = accounts[7]
	obj.BVaultLpMint = accounts[8]
	obj.ATokenVault = accounts[9]
	obj.BTokenVault = accounts[10]
	obj.UserAToken = accounts[11]
	obj.UserBToken = accounts[12]
	obj.User = accounts[13]
	obj.VaultProgram = accounts[14]
	obj.TokenProgram = accounts[15]
	obj.PublicKeySlice = accounts
	return nil
}
func (obj *AddImbalanceLiquidity) PublicKeys() solanago.PublicKeySlice {
	return obj.PublicKeySlice
}

func (*AddImbalanceLiquidity) TypeID() binary.TypeID {
	return binary.TypeIDFromBytes(Instruction_AddImbalanceLiquidity)
}

func (*AddImbalanceLiquidity) NewInstance() programparser.Instruction {
	return new(AddImbalanceLiquidity)
}

func (inst *AddImbalanceLiquidity) GetRemainingAccounts() solanago.PublicKeySlice {
	return inst.PublicKeySlice[16:]
}

// Builds a "add_imbalance_liquidity" instruction.
// Deposit tokens to the pool in an imbalance ratio. Only supported by pool with stable swap curve.
func NewAddImbalanceLiquidityInstruction(
	// Params:
	minimumPoolTokenAmountParam uint64,
	tokenAAmountParam uint64,
	tokenBAmountParam uint64,

	// Accounts:
	pool solanago.PublicKey,
	lpMint solanago.PublicKey,
	userPoolLp solanago.PublicKey,
	aVaultLp solanago.PublicKey,
	bVaultLp solanago.PublicKey,
	aVault solanago.PublicKey,
	bVault solanago.PublicKey,
	aVaultLpMint solanago.PublicKey,
	bVaultLpMint solanago.PublicKey,
	aTokenVault solanago.PublicKey,
	bTokenVault solanago.PublicKey,
	userAToken solanago.PublicKey,
	userBToken solanago.PublicKey,
	user solanago.PublicKey,
	vaultProgram solanago.PublicKey,
	tokenProgram solanago.PublicKey,
	remaining__ ...*solanago.AccountMeta,
) (*solanago.GenericInstruction, error) {
	var (
		err    error
		buf__  = new(bytes.Buffer)
		enc__  = binary.NewBorshEncoder(buf__)
		metas_ = make(solanago.AccountMetaSlice, 16, 16+len(remaining__))
	)

	// Encode the instruction discriminator.
	if err = enc__.WriteBytes(Instruction_AddImbalanceLiquidity[:], false); err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}

	{
		// Serialize `minimumPoolTokenAmountParam`:
		if err = enc__.Encode(minimumPoolTokenAmountParam); err != nil {
			return nil, fmt.Errorf("error while marshaling minimumPoolTokenAmountParam:%w", err)
		}
		// Serialize `tokenAAmountParam`:
		if err = enc__.Encode(tokenAAmountParam); err != nil {
			return nil, fmt.Errorf("error while marshaling tokenAAmountParam:%w", err)
		}
		// Serialize `tokenBAmountParam`:
		if err = enc__.Encode(tokenBAmountParam); err != nil {
			return nil, fmt.Errorf("error while marshaling tokenBAmountParam:%w", err)
		}
	}

	// Add the accounts to the instruction.
	{
		// [0] = [writable] pool
		// Pool account (PDA)
		metas_[0] = solanago.NewAccountMeta(pool, true, false)
		// [1] = [writable] lp_mint
		// LP token mint of the pool
		metas_[1] = solanago.NewAccountMeta(lpMint, true, false)
		// [2] = [writable] user_pool_lp
		// user pool lp token account. lp will be burned from this account upon success liquidity removal.
		metas_[2] = solanago.NewAccountMeta(userPoolLp, true, false)
		// [3] = [writable] a_vault_lp
		// LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault.
		metas_[3] = solanago.NewAccountMeta(aVaultLp, true, false)
		// [4] = [writable] b_vault_lp
		// LP token account of vault B. Used to receive/burn the vault LP upon deposit/withdraw from the vault.
		metas_[4] = solanago.NewAccountMeta(bVaultLp, true, false)
		// [5] = [writable] a_vault
		// Vault account for token a. token a of the pool will be deposit / withdraw from this vault account.
		metas_[5] = solanago.NewAccountMeta(aVault, true, false)
		// [6] = [writable] b_vault
		// Vault account for token b. token b of the pool will be deposit / withdraw from this vault account.
		metas_[6] = solanago.NewAccountMeta(bVault, true, false)
		// [7] = [writable] a_vault_lp_mint
		// LP token mint of vault a
		metas_[7] = solanago.NewAccountMeta(aVaultLpMint, true, false)
		// [8] = [writable] b_vault_lp_mint
		// LP token mint of vault b
		metas_[8] = solanago.NewAccountMeta(bVaultLpMint, true, false)
		// [9] = [writable] a_token_vault
		// Token vault account of vault A
		metas_[9] = solanago.NewAccountMeta(aTokenVault, true, false)
		// [10] = [writable] b_token_vault
		// Token vault account of vault B
		metas_[10] = solanago.NewAccountMeta(bTokenVault, true, false)
		// [11] = [writable] user_a_token
		// User token A account. Token will be transfer from this account if it is add liquidity operation. Else, token will be transfer into this account.
		metas_[11] = solanago.NewAccountMeta(userAToken, true, false)
		// [12] = [writable] user_b_token
		// User token B account. Token will be transfer from this account if it is add liquidity operation. Else, token will be transfer into this account.
		metas_[12] = solanago.NewAccountMeta(userBToken, true, false)
		// [13] = [,signer] user
		// User account. Must be owner of user_a_token, and user_b_token.
		metas_[13] = solanago.NewAccountMeta(user, false, true)
		// [14] = [] vault_program
		// Vault program. the pool will deposit/withdraw liquidity from the vault.
		metas_[14] = solanago.NewAccountMeta(vaultProgram, false, false)
		// [15] = [] token_program
		// Token program.
		metas_[15] = solanago.NewAccountMeta(tokenProgram, false, false)
		// append remaining metas
		metas_ = append(metas_, remaining__...)
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		metas_,
		buf__.Bytes(),
	), nil
}

// Builds a "BuildAddImbalanceLiquidity" instruction.
// Deposit tokens to the pool in an imbalance ratio. Only supported by pool with stable swap curve.
func BuildAddImbalanceLiquidity(
	// Params:
	minimumPoolTokenAmountParam uint64,
	tokenAAmountParam uint64,
	tokenBAmountParam uint64,

	// Accounts:
	pool solanago.PublicKey,
	lpMint solanago.PublicKey,
	userPoolLp solanago.PublicKey,
	aVaultLp solanago.PublicKey,
	bVaultLp solanago.PublicKey,
	aVault solanago.PublicKey,
	bVault solanago.PublicKey,
	aVaultLpMint solanago.PublicKey,
	bVaultLpMint solanago.PublicKey,
	aTokenVault solanago.PublicKey,
	bTokenVault solanago.PublicKey,
	userAToken solanago.PublicKey,
	userBToken solanago.PublicKey,
	user solanago.PublicKey,
	vaultProgram solanago.PublicKey,
	tokenProgram solanago.PublicKey,
	remaining__ ...*solanago.AccountMeta,
) *solanago.GenericInstruction {
	instruction_, _ := NewAddImbalanceLiquidityInstruction(
		minimumPoolTokenAmountParam,
		tokenAAmountParam,
		tokenBAmountParam,
		pool,
		lpMint,
		userPoolLp,
		aVaultLp,
		bVaultLp,
		aVault,
		bVault,
		aVaultLpMint,
		bVaultLpMint,
		aTokenVault,
		bTokenVault,
		userAToken,
		userBToken,
		user,
		vaultProgram,
		tokenProgram,
		remaining__...,
	)
	return instruction_
}
