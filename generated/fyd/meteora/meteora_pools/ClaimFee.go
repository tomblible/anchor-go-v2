// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package meteora_pools

import (
	"bytes"
	"fmt"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
	programparser "github.com/yydsqu/solana-sdk/program_parser"
)

// Builds a "claim_fee" instruction.

// Claim fee
type ClaimFee struct {
	// Params:
	MaxAmount uint64
	// Accounts:
	// [0] = [writable] pool
	Pool solanago.PublicKey `bin:"-"`
	// [1] = [writable] lp_mint
	LpMint solanago.PublicKey `bin:"-"`
	// [2] = [writable] lock_escrow
	LockEscrow solanago.PublicKey `bin:"-"`
	// [3] = [writable,signer] owner
	Owner solanago.PublicKey `bin:"-"`
	// [4] = [writable] source_tokens
	SourceTokens solanago.PublicKey `bin:"-"`
	// [5] = [writable] escrow_vault
	EscrowVault solanago.PublicKey `bin:"-"`
	// [6] = [] token_program
	TokenProgram solanago.PublicKey `bin:"-"`
	// [7] = [writable] a_token_vault
	ATokenVault solanago.PublicKey `bin:"-"`
	// [8] = [writable] b_token_vault
	BTokenVault solanago.PublicKey `bin:"-"`
	// [9] = [writable] a_vault
	AVault solanago.PublicKey `bin:"-"`
	// [10] = [writable] b_vault
	BVault solanago.PublicKey `bin:"-"`
	// [11] = [writable] a_vault_lp
	AVaultLp solanago.PublicKey `bin:"-"`
	// [12] = [writable] b_vault_lp
	BVaultLp solanago.PublicKey `bin:"-"`
	// [13] = [writable] a_vault_lp_mint
	AVaultLpMint solanago.PublicKey `bin:"-"`
	// [14] = [writable] b_vault_lp_mint
	BVaultLpMint solanago.PublicKey `bin:"-"`
	// [15] = [writable] user_a_token
	UserAToken solanago.PublicKey `bin:"-"`
	// [16] = [writable] user_b_token
	UserBToken solanago.PublicKey `bin:"-"`
	// [17] = [] vault_program
	VaultProgram solanago.PublicKey `bin:"-"`
	// PublicKeySlice
	solanago.PublicKeySlice `bin:"-"`
}

func (obj ClaimFee) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `maxAmountParam`:
	if err = encoder.Encode(obj.MaxAmount); err != nil {
		return fmt.Errorf("error while marshaling maxAmountParam:%w", err)
	}
	return nil
}

func (obj *ClaimFee) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `MaxAmount`:
	if err = decoder.Decode(&obj.MaxAmount); err != nil {
		return fmt.Errorf("error while unmarshaling MaxAmount:%w", err)
	}
	return nil
}

func (obj *ClaimFee) SetAccounts(accounts solanago.PublicKeySlice) (err error) {
	if len(accounts) < 18 {
		return fmt.Errorf("too few accounts, expect %d actual %d", 18, len(accounts))
	}
	obj.Pool = accounts[0]
	obj.LpMint = accounts[1]
	obj.LockEscrow = accounts[2]
	obj.Owner = accounts[3]
	obj.SourceTokens = accounts[4]
	obj.EscrowVault = accounts[5]
	obj.TokenProgram = accounts[6]
	obj.ATokenVault = accounts[7]
	obj.BTokenVault = accounts[8]
	obj.AVault = accounts[9]
	obj.BVault = accounts[10]
	obj.AVaultLp = accounts[11]
	obj.BVaultLp = accounts[12]
	obj.AVaultLpMint = accounts[13]
	obj.BVaultLpMint = accounts[14]
	obj.UserAToken = accounts[15]
	obj.UserBToken = accounts[16]
	obj.VaultProgram = accounts[17]
	obj.PublicKeySlice = accounts
	return nil
}
func (obj *ClaimFee) PublicKeys() solanago.PublicKeySlice {
	return obj.PublicKeySlice
}

func (*ClaimFee) TypeID() binary.TypeID {
	return binary.TypeIDFromBytes(Instruction_ClaimFee)
}

func (*ClaimFee) NewInstance() programparser.Instruction {
	return new(ClaimFee)
}

func (obj *ClaimFee) GetRemainingAccounts() solanago.PublicKeySlice {
	return obj.PublicKeySlice[18:]
}

// Builds a "claim_fee" instruction.
// Claim fee
func NewClaimFeeInstruction(
	// Params:
	maxAmountParam uint64,

	// Accounts:
	pool solanago.PublicKey,
	lpMint solanago.PublicKey,
	lockEscrow solanago.PublicKey,
	owner solanago.PublicKey,
	sourceTokens solanago.PublicKey,
	escrowVault solanago.PublicKey,
	tokenProgram solanago.PublicKey,
	aTokenVault solanago.PublicKey,
	bTokenVault solanago.PublicKey,
	aVault solanago.PublicKey,
	bVault solanago.PublicKey,
	aVaultLp solanago.PublicKey,
	bVaultLp solanago.PublicKey,
	aVaultLpMint solanago.PublicKey,
	bVaultLpMint solanago.PublicKey,
	userAToken solanago.PublicKey,
	userBToken solanago.PublicKey,
	vaultProgram solanago.PublicKey,
	remaining__ ...*solanago.AccountMeta,
) (*solanago.GenericInstruction, error) {
	var (
		err    error
		buf__  = new(bytes.Buffer)
		enc__  = binary.NewBorshEncoder(buf__)
		metas_ = make(solanago.AccountMetaSlice, 18, 18+len(remaining__))
	)

	// Encode the instruction discriminator.
	if err = enc__.WriteBytes(Instruction_ClaimFee[:], false); err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}

	{
		// Serialize `maxAmountParam`:
		if err = enc__.Encode(maxAmountParam); err != nil {
			return nil, fmt.Errorf("error while marshaling maxAmountParam:%w", err)
		}
	}

	// Add the accounts to the instruction.
	{
		// [0] = [writable] pool
		// Pool account
		metas_[0] = solanago.NewAccountMeta(pool, true, false)
		// [1] = [writable] lp_mint
		// LP token mint of the pool
		metas_[1] = solanago.NewAccountMeta(lpMint, true, false)
		// [2] = [writable] lock_escrow
		// Lock account
		metas_[2] = solanago.NewAccountMeta(lockEscrow, true, false)
		// [3] = [writable,signer] owner
		// Owner of lock account
		metas_[3] = solanago.NewAccountMeta(owner, true, true)
		// [4] = [writable] source_tokens
		// owner lp token account
		metas_[4] = solanago.NewAccountMeta(sourceTokens, true, false)
		// [5] = [writable] escrow_vault
		// Escrow vault
		metas_[5] = solanago.NewAccountMeta(escrowVault, true, false)
		// [6] = [] token_program
		// Token program.
		metas_[6] = solanago.NewAccountMeta(tokenProgram, false, false)
		// [7] = [writable] a_token_vault
		// Token vault account of vault A
		metas_[7] = solanago.NewAccountMeta(aTokenVault, true, false)
		// [8] = [writable] b_token_vault
		// Token vault account of vault B
		metas_[8] = solanago.NewAccountMeta(bTokenVault, true, false)
		// [9] = [writable] a_vault
		// Vault account for token a. token a of the pool will be deposit / withdraw from this vault account.
		metas_[9] = solanago.NewAccountMeta(aVault, true, false)
		// [10] = [writable] b_vault
		// Vault account for token b. token b of the pool will be deposit / withdraw from this vault account.
		metas_[10] = solanago.NewAccountMeta(bVault, true, false)
		// [11] = [writable] a_vault_lp
		// LP token account of vault A. Used to receive/burn the vault LP upon deposit/withdraw from the vault.
		metas_[11] = solanago.NewAccountMeta(aVaultLp, true, false)
		// [12] = [writable] b_vault_lp
		// LP token account of vault B. Used to receive/burn the vault LP upon deposit/withdraw from the vault.
		metas_[12] = solanago.NewAccountMeta(bVaultLp, true, false)
		// [13] = [writable] a_vault_lp_mint
		// LP token mint of vault a
		metas_[13] = solanago.NewAccountMeta(aVaultLpMint, true, false)
		// [14] = [writable] b_vault_lp_mint
		// LP token mint of vault b
		metas_[14] = solanago.NewAccountMeta(bVaultLpMint, true, false)
		// [15] = [writable] user_a_token
		// User token A account. Token will be transfer from this account if it is add liquidity operation. Else, token will be transfer into this account.
		metas_[15] = solanago.NewAccountMeta(userAToken, true, false)
		// [16] = [writable] user_b_token
		// User token B account. Token will be transfer from this account if it is add liquidity operation. Else, token will be transfer into this account.
		metas_[16] = solanago.NewAccountMeta(userBToken, true, false)
		// [17] = [] vault_program
		// Vault program. the pool will deposit/withdraw liquidity from the vault.
		metas_[17] = solanago.NewAccountMeta(vaultProgram, false, false)
		// append remaining metas
		metas_ = append(metas_, remaining__...)
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		metas_,
		buf__.Bytes(),
	), nil
}

// Builds a "BuildClaimFee" instruction.
// Claim fee
func BuildClaimFee(
	// Params:
	maxAmountParam uint64,

	// Accounts:
	pool solanago.PublicKey,
	lpMint solanago.PublicKey,
	lockEscrow solanago.PublicKey,
	owner solanago.PublicKey,
	sourceTokens solanago.PublicKey,
	escrowVault solanago.PublicKey,
	tokenProgram solanago.PublicKey,
	aTokenVault solanago.PublicKey,
	bTokenVault solanago.PublicKey,
	aVault solanago.PublicKey,
	bVault solanago.PublicKey,
	aVaultLp solanago.PublicKey,
	bVaultLp solanago.PublicKey,
	aVaultLpMint solanago.PublicKey,
	bVaultLpMint solanago.PublicKey,
	userAToken solanago.PublicKey,
	userBToken solanago.PublicKey,
	vaultProgram solanago.PublicKey,
	remaining__ ...*solanago.AccountMeta,
) *solanago.GenericInstruction {
	instruction_, _ := NewClaimFeeInstruction(
		maxAmountParam,
		pool,
		lpMint,
		lockEscrow,
		owner,
		sourceTokens,
		escrowVault,
		tokenProgram,
		aTokenVault,
		bTokenVault,
		aVault,
		bVault,
		aVaultLp,
		bVaultLp,
		aVaultLpMint,
		bVaultLpMint,
		userAToken,
		userBToken,
		vaultProgram,
		remaining__...,
	)
	return instruction_
}
