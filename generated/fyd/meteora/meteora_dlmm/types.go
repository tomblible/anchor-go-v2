// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains parsers for the types defined in the IDL.

package meteora_dlmm

import (
	"bytes"
	"fmt"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

type Instruction interface {
	TypeID() binary.TypeID
	SetAccounts(accounts solanago.PublicKeySlice) error
	Copy() Instruction
}

// The "isAccountsType" interface for the "AccountsType" complex enum.
type AccountsType interface {
	isAccountsType()
}

type accountsTypeEnumContainer struct {
	Enum                    binary.BorshEnum `bin:"enum"`
	TransferHookX           AccountsType_TransferHookX
	TransferHookY           AccountsType_TransferHookY
	TransferHookReward      AccountsType_TransferHookReward
	TransferHookMultiReward AccountsType_TransferHookMultiReward
}

func DecodeAccountsType(decoder *binary.Decoder) (AccountsType, error) {
	{
		tmp := new(accountsTypeEnumContainer)
		err := decoder.Decode(tmp)
		if err != nil {
			return nil, fmt.Errorf("failed parsing AccountsType: %w", err)
		}
		switch tmp.Enum {
		case 0:
			return (*AccountsType_TransferHookX)(&tmp.Enum), nil
		case 1:
			return (*AccountsType_TransferHookY)(&tmp.Enum), nil
		case 2:
			return (*AccountsType_TransferHookReward)(&tmp.Enum), nil
		case 3:
			return &tmp.TransferHookMultiReward, nil
		default:
			return nil, fmt.Errorf("AccountsType: unknown enum index: %v", tmp.Enum)
		}
	}
}

func EncodeAccountsType(encoder *binary.Encoder, value AccountsType) error {
	{
		tmp := accountsTypeEnumContainer{}
		switch realvalue := value.(type) {
		case *AccountsType_TransferHookX:
			tmp.Enum = 0
			tmp.TransferHookX = *realvalue
		case *AccountsType_TransferHookY:
			tmp.Enum = 1
			tmp.TransferHookY = *realvalue
		case *AccountsType_TransferHookReward:
			tmp.Enum = 2
			tmp.TransferHookReward = *realvalue
		case *AccountsType_TransferHookMultiReward:
			tmp.Enum = 3
			tmp.TransferHookMultiReward = *realvalue
		}
		return encoder.Encode(tmp)
	}
}

type AccountsType_TransferHookX uint8

func (obj AccountsType_TransferHookX) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *AccountsType_TransferHookX) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (_ *AccountsType_TransferHookX) isAccountsType() {}

type AccountsType_TransferHookY uint8

func (obj AccountsType_TransferHookY) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *AccountsType_TransferHookY) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (_ *AccountsType_TransferHookY) isAccountsType() {}

type AccountsType_TransferHookReward uint8

func (obj AccountsType_TransferHookReward) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *AccountsType_TransferHookReward) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (_ *AccountsType_TransferHookReward) isAccountsType() {}

// Variant "TransferHookMultiReward" of enum "AccountsType"
type AccountsType_TransferHookMultiReward struct {
	V0 uint8 `json:"v0"`
}

func (obj AccountsType_TransferHookMultiReward) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `V0`:
	if err = encoder.Encode(obj.V0); err != nil {
		return fmt.Errorf("error while marshaling V0:%w", err)
	}
	return nil
}

func (obj AccountsType_TransferHookMultiReward) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding AccountsType_TransferHookMultiReward: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *AccountsType_TransferHookMultiReward) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `V0`:
	if err = decoder.Decode(&obj.V0); err != nil {
		return fmt.Errorf("error while unmarshaling V0:%w", err)
	}
	return nil
}

func (obj *AccountsType_TransferHookMultiReward) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AccountsType_TransferHookMultiReward: %w", err)
	}
	return nil
}

func UnmarshalAccountsType_TransferHookMultiReward(buf []byte) (*AccountsType_TransferHookMultiReward, error) {
	obj := new(AccountsType_TransferHookMultiReward)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

func (_ *AccountsType_TransferHookMultiReward) isAccountsType() {}

// Type of the activation
type ActivationType binary.BorshEnum

const (
	ActivationType_Slot ActivationType = iota
	ActivationType_Timestamp
)

func (value ActivationType) String() string {
	switch value {
	case ActivationType_Slot:
		return "Slot"
	case ActivationType_Timestamp:
		return "Timestamp"
	default:
		return ""
	}
}

type AddLiquidityParams struct {
	MinDeltaId       int32
	MaxDeltaId       int32
	X0               uint64
	Y0               uint64
	DeltaX           uint64
	DeltaY           uint64
	BitFlag          uint8
	FavorXInActiveId bool
	Padding          [16]uint8
}

func (obj AddLiquidityParams) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `MinDeltaId`:
	if err = encoder.Encode(obj.MinDeltaId); err != nil {
		return fmt.Errorf("error while marshaling MinDeltaId:%w", err)
	}
	// Serialize `MaxDeltaId`:
	if err = encoder.Encode(obj.MaxDeltaId); err != nil {
		return fmt.Errorf("error while marshaling MaxDeltaId:%w", err)
	}
	// Serialize `X0`:
	if err = encoder.Encode(obj.X0); err != nil {
		return fmt.Errorf("error while marshaling X0:%w", err)
	}
	// Serialize `Y0`:
	if err = encoder.Encode(obj.Y0); err != nil {
		return fmt.Errorf("error while marshaling Y0:%w", err)
	}
	// Serialize `DeltaX`:
	if err = encoder.Encode(obj.DeltaX); err != nil {
		return fmt.Errorf("error while marshaling DeltaX:%w", err)
	}
	// Serialize `DeltaY`:
	if err = encoder.Encode(obj.DeltaY); err != nil {
		return fmt.Errorf("error while marshaling DeltaY:%w", err)
	}
	// Serialize `BitFlag`:
	if err = encoder.Encode(obj.BitFlag); err != nil {
		return fmt.Errorf("error while marshaling BitFlag:%w", err)
	}
	// Serialize `FavorXInActiveId`:
	if err = encoder.Encode(obj.FavorXInActiveId); err != nil {
		return fmt.Errorf("error while marshaling FavorXInActiveId:%w", err)
	}
	// Serialize `Padding`:
	if err = encoder.Encode(obj.Padding); err != nil {
		return fmt.Errorf("error while marshaling Padding:%w", err)
	}
	return nil
}

func (obj AddLiquidityParams) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding AddLiquidityParams: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *AddLiquidityParams) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `MinDeltaId`:
	if err = decoder.Decode(&obj.MinDeltaId); err != nil {
		return fmt.Errorf("error while unmarshaling MinDeltaId:%w", err)
	}
	// Deserialize `MaxDeltaId`:
	if err = decoder.Decode(&obj.MaxDeltaId); err != nil {
		return fmt.Errorf("error while unmarshaling MaxDeltaId:%w", err)
	}
	// Deserialize `X0`:
	if err = decoder.Decode(&obj.X0); err != nil {
		return fmt.Errorf("error while unmarshaling X0:%w", err)
	}
	// Deserialize `Y0`:
	if err = decoder.Decode(&obj.Y0); err != nil {
		return fmt.Errorf("error while unmarshaling Y0:%w", err)
	}
	// Deserialize `DeltaX`:
	if err = decoder.Decode(&obj.DeltaX); err != nil {
		return fmt.Errorf("error while unmarshaling DeltaX:%w", err)
	}
	// Deserialize `DeltaY`:
	if err = decoder.Decode(&obj.DeltaY); err != nil {
		return fmt.Errorf("error while unmarshaling DeltaY:%w", err)
	}
	// Deserialize `BitFlag`:
	if err = decoder.Decode(&obj.BitFlag); err != nil {
		return fmt.Errorf("error while unmarshaling BitFlag:%w", err)
	}
	// Deserialize `FavorXInActiveId`:
	if err = decoder.Decode(&obj.FavorXInActiveId); err != nil {
		return fmt.Errorf("error while unmarshaling FavorXInActiveId:%w", err)
	}
	// Deserialize `Padding`:
	if err = decoder.Decode(&obj.Padding); err != nil {
		return fmt.Errorf("error while unmarshaling Padding:%w", err)
	}
	return nil
}

func (obj *AddLiquidityParams) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AddLiquidityParams: %w", err)
	}
	return nil
}

func UnmarshalAddLiquidityParams(buf []byte) (*AddLiquidityParams, error) {
	obj := new(AddLiquidityParams)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type AddLiquiditySingleSidePreciseParameter struct {
	Bins                 []CompressedBinDepositAmount
	DecompressMultiplier uint64
}

func (obj AddLiquiditySingleSidePreciseParameter) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Bins`:
	if err = encoder.Encode(obj.Bins); err != nil {
		return fmt.Errorf("error while marshaling Bins:%w", err)
	}
	// Serialize `DecompressMultiplier`:
	if err = encoder.Encode(obj.DecompressMultiplier); err != nil {
		return fmt.Errorf("error while marshaling DecompressMultiplier:%w", err)
	}
	return nil
}

func (obj AddLiquiditySingleSidePreciseParameter) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding AddLiquiditySingleSidePreciseParameter: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *AddLiquiditySingleSidePreciseParameter) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Bins`:
	if err = decoder.Decode(&obj.Bins); err != nil {
		return fmt.Errorf("error while unmarshaling Bins:%w", err)
	}
	// Deserialize `DecompressMultiplier`:
	if err = decoder.Decode(&obj.DecompressMultiplier); err != nil {
		return fmt.Errorf("error while unmarshaling DecompressMultiplier:%w", err)
	}
	return nil
}

func (obj *AddLiquiditySingleSidePreciseParameter) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AddLiquiditySingleSidePreciseParameter: %w", err)
	}
	return nil
}

func UnmarshalAddLiquiditySingleSidePreciseParameter(buf []byte) (*AddLiquiditySingleSidePreciseParameter, error) {
	obj := new(AddLiquiditySingleSidePreciseParameter)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type AddLiquiditySingleSidePreciseParameter2 struct {
	Bins                 []CompressedBinDepositAmount
	DecompressMultiplier uint64
	MaxAmount            uint64
}

func (obj AddLiquiditySingleSidePreciseParameter2) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Bins`:
	if err = encoder.Encode(obj.Bins); err != nil {
		return fmt.Errorf("error while marshaling Bins:%w", err)
	}
	// Serialize `DecompressMultiplier`:
	if err = encoder.Encode(obj.DecompressMultiplier); err != nil {
		return fmt.Errorf("error while marshaling DecompressMultiplier:%w", err)
	}
	// Serialize `MaxAmount`:
	if err = encoder.Encode(obj.MaxAmount); err != nil {
		return fmt.Errorf("error while marshaling MaxAmount:%w", err)
	}
	return nil
}

func (obj AddLiquiditySingleSidePreciseParameter2) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding AddLiquiditySingleSidePreciseParameter2: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *AddLiquiditySingleSidePreciseParameter2) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Bins`:
	if err = decoder.Decode(&obj.Bins); err != nil {
		return fmt.Errorf("error while unmarshaling Bins:%w", err)
	}
	// Deserialize `DecompressMultiplier`:
	if err = decoder.Decode(&obj.DecompressMultiplier); err != nil {
		return fmt.Errorf("error while unmarshaling DecompressMultiplier:%w", err)
	}
	// Deserialize `MaxAmount`:
	if err = decoder.Decode(&obj.MaxAmount); err != nil {
		return fmt.Errorf("error while unmarshaling MaxAmount:%w", err)
	}
	return nil
}

func (obj *AddLiquiditySingleSidePreciseParameter2) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling AddLiquiditySingleSidePreciseParameter2: %w", err)
	}
	return nil
}

func UnmarshalAddLiquiditySingleSidePreciseParameter2(buf []byte) (*AddLiquiditySingleSidePreciseParameter2, error) {
	obj := new(AddLiquiditySingleSidePreciseParameter2)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type BaseFeeParameter struct {
	// Portion of swap fees retained by the protocol by controlling protocol_share parameter. protocol_swap_fee = protocol_share * total_swap_fee
	ProtocolShare uint16

	// Base factor for base fee rate
	BaseFactor uint16

	// Base fee power factor
	BaseFeePowerFactor uint8
}

func (obj BaseFeeParameter) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `ProtocolShare`:
	if err = encoder.Encode(obj.ProtocolShare); err != nil {
		return fmt.Errorf("error while marshaling ProtocolShare:%w", err)
	}
	// Serialize `BaseFactor`:
	if err = encoder.Encode(obj.BaseFactor); err != nil {
		return fmt.Errorf("error while marshaling BaseFactor:%w", err)
	}
	// Serialize `BaseFeePowerFactor`:
	if err = encoder.Encode(obj.BaseFeePowerFactor); err != nil {
		return fmt.Errorf("error while marshaling BaseFeePowerFactor:%w", err)
	}
	return nil
}

func (obj BaseFeeParameter) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding BaseFeeParameter: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *BaseFeeParameter) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `ProtocolShare`:
	if err = decoder.Decode(&obj.ProtocolShare); err != nil {
		return fmt.Errorf("error while unmarshaling ProtocolShare:%w", err)
	}
	// Deserialize `BaseFactor`:
	if err = decoder.Decode(&obj.BaseFactor); err != nil {
		return fmt.Errorf("error while unmarshaling BaseFactor:%w", err)
	}
	// Deserialize `BaseFeePowerFactor`:
	if err = decoder.Decode(&obj.BaseFeePowerFactor); err != nil {
		return fmt.Errorf("error while unmarshaling BaseFeePowerFactor:%w", err)
	}
	return nil
}

func (obj *BaseFeeParameter) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling BaseFeeParameter: %w", err)
	}
	return nil
}

func UnmarshalBaseFeeParameter(buf []byte) (*BaseFeeParameter, error) {
	obj := new(BaseFeeParameter)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type Bin struct {
	// Amount of token X in the bin. This already excluded protocol fees.
	AmountX uint64

	// Amount of token Y in the bin. This already excluded protocol fees.
	AmountY uint64

	// Bin price
	Price binary.Uint128

	// Liquidities of the bin. This is the same as LP mint supply. q-number
	LiquiditySupply binary.Uint128

	// reward_a_per_token_stored
	RewardPerTokenStored [2]binary.Uint128

	// Swap fee amount of token X per liquidity deposited.
	FeeAmountXPerTokenStored binary.Uint128

	// Swap fee amount of token Y per liquidity deposited.
	FeeAmountYPerTokenStored binary.Uint128

	// Total token X swap into the bin. Only used for tracking purpose.
	AmountXIn binary.Uint128

	// Total token Y swap into he bin. Only used for tracking purpose.
	AmountYIn binary.Uint128
}

func (obj Bin) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `AmountX`:
	if err = encoder.Encode(obj.AmountX); err != nil {
		return fmt.Errorf("error while marshaling AmountX:%w", err)
	}
	// Serialize `AmountY`:
	if err = encoder.Encode(obj.AmountY); err != nil {
		return fmt.Errorf("error while marshaling AmountY:%w", err)
	}
	// Serialize `Price`:
	if err = encoder.Encode(obj.Price); err != nil {
		return fmt.Errorf("error while marshaling Price:%w", err)
	}
	// Serialize `LiquiditySupply`:
	if err = encoder.Encode(obj.LiquiditySupply); err != nil {
		return fmt.Errorf("error while marshaling LiquiditySupply:%w", err)
	}
	// Serialize `RewardPerTokenStored`:
	if err = encoder.Encode(obj.RewardPerTokenStored); err != nil {
		return fmt.Errorf("error while marshaling RewardPerTokenStored:%w", err)
	}
	// Serialize `FeeAmountXPerTokenStored`:
	if err = encoder.Encode(obj.FeeAmountXPerTokenStored); err != nil {
		return fmt.Errorf("error while marshaling FeeAmountXPerTokenStored:%w", err)
	}
	// Serialize `FeeAmountYPerTokenStored`:
	if err = encoder.Encode(obj.FeeAmountYPerTokenStored); err != nil {
		return fmt.Errorf("error while marshaling FeeAmountYPerTokenStored:%w", err)
	}
	// Serialize `AmountXIn`:
	if err = encoder.Encode(obj.AmountXIn); err != nil {
		return fmt.Errorf("error while marshaling AmountXIn:%w", err)
	}
	// Serialize `AmountYIn`:
	if err = encoder.Encode(obj.AmountYIn); err != nil {
		return fmt.Errorf("error while marshaling AmountYIn:%w", err)
	}
	return nil
}

func (obj Bin) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Bin: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Bin) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `AmountX`:
	if err = decoder.Decode(&obj.AmountX); err != nil {
		return fmt.Errorf("error while unmarshaling AmountX:%w", err)
	}
	// Deserialize `AmountY`:
	if err = decoder.Decode(&obj.AmountY); err != nil {
		return fmt.Errorf("error while unmarshaling AmountY:%w", err)
	}
	// Deserialize `Price`:
	if err = decoder.Decode(&obj.Price); err != nil {
		return fmt.Errorf("error while unmarshaling Price:%w", err)
	}
	// Deserialize `LiquiditySupply`:
	if err = decoder.Decode(&obj.LiquiditySupply); err != nil {
		return fmt.Errorf("error while unmarshaling LiquiditySupply:%w", err)
	}
	// Deserialize `RewardPerTokenStored`:
	if err = decoder.Decode(&obj.RewardPerTokenStored); err != nil {
		return fmt.Errorf("error while unmarshaling RewardPerTokenStored:%w", err)
	}
	// Deserialize `FeeAmountXPerTokenStored`:
	if err = decoder.Decode(&obj.FeeAmountXPerTokenStored); err != nil {
		return fmt.Errorf("error while unmarshaling FeeAmountXPerTokenStored:%w", err)
	}
	// Deserialize `FeeAmountYPerTokenStored`:
	if err = decoder.Decode(&obj.FeeAmountYPerTokenStored); err != nil {
		return fmt.Errorf("error while unmarshaling FeeAmountYPerTokenStored:%w", err)
	}
	// Deserialize `AmountXIn`:
	if err = decoder.Decode(&obj.AmountXIn); err != nil {
		return fmt.Errorf("error while unmarshaling AmountXIn:%w", err)
	}
	// Deserialize `AmountYIn`:
	if err = decoder.Decode(&obj.AmountYIn); err != nil {
		return fmt.Errorf("error while unmarshaling AmountYIn:%w", err)
	}
	return nil
}

func (obj *Bin) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Bin: %w", err)
	}
	return nil
}

func UnmarshalBin(buf []byte) (*Bin, error) {
	obj := new(Bin)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type BinLiquidityDistribution struct {
	// Define the bin ID wish to deposit to.
	BinId int32

	// DistributionX (or distributionY) is the percentages of amountX (or amountY) you want to add to each bin.
	DistributionX uint16

	// DistributionX (or distributionY) is the percentages of amountX (or amountY) you want to add to each bin.
	DistributionY uint16
}

func (obj BinLiquidityDistribution) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `BinId`:
	if err = encoder.Encode(obj.BinId); err != nil {
		return fmt.Errorf("error while marshaling BinId:%w", err)
	}
	// Serialize `DistributionX`:
	if err = encoder.Encode(obj.DistributionX); err != nil {
		return fmt.Errorf("error while marshaling DistributionX:%w", err)
	}
	// Serialize `DistributionY`:
	if err = encoder.Encode(obj.DistributionY); err != nil {
		return fmt.Errorf("error while marshaling DistributionY:%w", err)
	}
	return nil
}

func (obj BinLiquidityDistribution) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding BinLiquidityDistribution: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *BinLiquidityDistribution) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `BinId`:
	if err = decoder.Decode(&obj.BinId); err != nil {
		return fmt.Errorf("error while unmarshaling BinId:%w", err)
	}
	// Deserialize `DistributionX`:
	if err = decoder.Decode(&obj.DistributionX); err != nil {
		return fmt.Errorf("error while unmarshaling DistributionX:%w", err)
	}
	// Deserialize `DistributionY`:
	if err = decoder.Decode(&obj.DistributionY); err != nil {
		return fmt.Errorf("error while unmarshaling DistributionY:%w", err)
	}
	return nil
}

func (obj *BinLiquidityDistribution) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling BinLiquidityDistribution: %w", err)
	}
	return nil
}

func UnmarshalBinLiquidityDistribution(buf []byte) (*BinLiquidityDistribution, error) {
	obj := new(BinLiquidityDistribution)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type BinLiquidityDistributionByWeight struct {
	// Define the bin ID wish to deposit to.
	BinId int32

	// weight of liquidity distributed for this bin id
	Weight uint16
}

func (obj BinLiquidityDistributionByWeight) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `BinId`:
	if err = encoder.Encode(obj.BinId); err != nil {
		return fmt.Errorf("error while marshaling BinId:%w", err)
	}
	// Serialize `Weight`:
	if err = encoder.Encode(obj.Weight); err != nil {
		return fmt.Errorf("error while marshaling Weight:%w", err)
	}
	return nil
}

func (obj BinLiquidityDistributionByWeight) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding BinLiquidityDistributionByWeight: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *BinLiquidityDistributionByWeight) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `BinId`:
	if err = decoder.Decode(&obj.BinId); err != nil {
		return fmt.Errorf("error while unmarshaling BinId:%w", err)
	}
	// Deserialize `Weight`:
	if err = decoder.Decode(&obj.Weight); err != nil {
		return fmt.Errorf("error while unmarshaling Weight:%w", err)
	}
	return nil
}

func (obj *BinLiquidityDistributionByWeight) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling BinLiquidityDistributionByWeight: %w", err)
	}
	return nil
}

func UnmarshalBinLiquidityDistributionByWeight(buf []byte) (*BinLiquidityDistributionByWeight, error) {
	obj := new(BinLiquidityDistributionByWeight)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type BinLiquidityReduction struct {
	BinId       int32
	BpsToRemove uint16
}

func (obj BinLiquidityReduction) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `BinId`:
	if err = encoder.Encode(obj.BinId); err != nil {
		return fmt.Errorf("error while marshaling BinId:%w", err)
	}
	// Serialize `BpsToRemove`:
	if err = encoder.Encode(obj.BpsToRemove); err != nil {
		return fmt.Errorf("error while marshaling BpsToRemove:%w", err)
	}
	return nil
}

func (obj BinLiquidityReduction) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding BinLiquidityReduction: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *BinLiquidityReduction) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `BinId`:
	if err = decoder.Decode(&obj.BinId); err != nil {
		return fmt.Errorf("error while unmarshaling BinId:%w", err)
	}
	// Deserialize `BpsToRemove`:
	if err = decoder.Decode(&obj.BpsToRemove); err != nil {
		return fmt.Errorf("error while unmarshaling BpsToRemove:%w", err)
	}
	return nil
}

func (obj *BinLiquidityReduction) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling BinLiquidityReduction: %w", err)
	}
	return nil
}

func UnmarshalBinLiquidityReduction(buf []byte) (*BinLiquidityReduction, error) {
	obj := new(BinLiquidityReduction)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type CompressedBinDepositAmount struct {
	BinId  int32
	Amount uint32
}

func (obj CompressedBinDepositAmount) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `BinId`:
	if err = encoder.Encode(obj.BinId); err != nil {
		return fmt.Errorf("error while marshaling BinId:%w", err)
	}
	// Serialize `Amount`:
	if err = encoder.Encode(obj.Amount); err != nil {
		return fmt.Errorf("error while marshaling Amount:%w", err)
	}
	return nil
}

func (obj CompressedBinDepositAmount) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding CompressedBinDepositAmount: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *CompressedBinDepositAmount) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `BinId`:
	if err = decoder.Decode(&obj.BinId); err != nil {
		return fmt.Errorf("error while unmarshaling BinId:%w", err)
	}
	// Deserialize `Amount`:
	if err = decoder.Decode(&obj.Amount); err != nil {
		return fmt.Errorf("error while unmarshaling Amount:%w", err)
	}
	return nil
}

func (obj *CompressedBinDepositAmount) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CompressedBinDepositAmount: %w", err)
	}
	return nil
}

func UnmarshalCompressedBinDepositAmount(buf []byte) (*CompressedBinDepositAmount, error) {
	obj := new(CompressedBinDepositAmount)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type CustomizableParams struct {
	// Pool price
	ActiveId int32

	// Bin step
	BinStep uint16

	// Base factor
	BaseFactor uint16

	// Activation type. 0 = Slot, 1 = Time. Check ActivationType enum
	ActivationType uint8

	// Whether the pool has an alpha vault
	HasAlphaVault bool

	// Decide when does the pool start trade. None = Now
	ActivationPoint *uint64 `bin:"optional"`

	// Pool creator have permission to enable/disable pool with restricted program validation. Only applicable for customizable permissionless pool.
	CreatorPoolOnOffControl bool

	// Base fee power factor
	BaseFeePowerFactor uint8

	// Padding, for future use
	Padding [62]uint8
}

func (obj CustomizableParams) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `ActiveId`:
	if err = encoder.Encode(obj.ActiveId); err != nil {
		return fmt.Errorf("error while marshaling ActiveId:%w", err)
	}
	// Serialize `BinStep`:
	if err = encoder.Encode(obj.BinStep); err != nil {
		return fmt.Errorf("error while marshaling BinStep:%w", err)
	}
	// Serialize `BaseFactor`:
	if err = encoder.Encode(obj.BaseFactor); err != nil {
		return fmt.Errorf("error while marshaling BaseFactor:%w", err)
	}
	// Serialize `ActivationType`:
	if err = encoder.Encode(obj.ActivationType); err != nil {
		return fmt.Errorf("error while marshaling ActivationType:%w", err)
	}
	// Serialize `HasAlphaVault`:
	if err = encoder.Encode(obj.HasAlphaVault); err != nil {
		return fmt.Errorf("error while marshaling HasAlphaVault:%w", err)
	}
	// Serialize `ActivationPoint` (optional):
	{
		if obj.ActivationPoint == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling ActivationPoint optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling ActivationPoint optionality: %w", err)
			}
			if err = encoder.Encode(obj.ActivationPoint); err != nil {
				return fmt.Errorf("error while marshaling ActivationPoint: %w", err)
			}
		}
	}
	// Serialize `CreatorPoolOnOffControl`:
	if err = encoder.Encode(obj.CreatorPoolOnOffControl); err != nil {
		return fmt.Errorf("error while marshaling CreatorPoolOnOffControl:%w", err)
	}
	// Serialize `BaseFeePowerFactor`:
	if err = encoder.Encode(obj.BaseFeePowerFactor); err != nil {
		return fmt.Errorf("error while marshaling BaseFeePowerFactor:%w", err)
	}
	// Serialize `Padding`:
	if err = encoder.Encode(obj.Padding); err != nil {
		return fmt.Errorf("error while marshaling Padding:%w", err)
	}
	return nil
}

func (obj CustomizableParams) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding CustomizableParams: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *CustomizableParams) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `ActiveId`:
	if err = decoder.Decode(&obj.ActiveId); err != nil {
		return fmt.Errorf("error while unmarshaling ActiveId:%w", err)
	}
	// Deserialize `BinStep`:
	if err = decoder.Decode(&obj.BinStep); err != nil {
		return fmt.Errorf("error while unmarshaling BinStep:%w", err)
	}
	// Deserialize `BaseFactor`:
	if err = decoder.Decode(&obj.BaseFactor); err != nil {
		return fmt.Errorf("error while unmarshaling BaseFactor:%w", err)
	}
	// Deserialize `ActivationType`:
	if err = decoder.Decode(&obj.ActivationType); err != nil {
		return fmt.Errorf("error while unmarshaling ActivationType:%w", err)
	}
	// Deserialize `HasAlphaVault`:
	if err = decoder.Decode(&obj.HasAlphaVault); err != nil {
		return fmt.Errorf("error while unmarshaling HasAlphaVault:%w", err)
	}
	// Deserialize `ActivationPoint` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling ActivationPoint:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.ActivationPoint); err != nil {
				return fmt.Errorf("error while unmarshaling ActivationPoint:%w", err)
			}
		}
	}
	// Deserialize `CreatorPoolOnOffControl`:
	if err = decoder.Decode(&obj.CreatorPoolOnOffControl); err != nil {
		return fmt.Errorf("error while unmarshaling CreatorPoolOnOffControl:%w", err)
	}
	// Deserialize `BaseFeePowerFactor`:
	if err = decoder.Decode(&obj.BaseFeePowerFactor); err != nil {
		return fmt.Errorf("error while unmarshaling BaseFeePowerFactor:%w", err)
	}
	// Deserialize `Padding`:
	if err = decoder.Decode(&obj.Padding); err != nil {
		return fmt.Errorf("error while unmarshaling Padding:%w", err)
	}
	return nil
}

func (obj *CustomizableParams) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling CustomizableParams: %w", err)
	}
	return nil
}

func UnmarshalCustomizableParams(buf []byte) (*CustomizableParams, error) {
	obj := new(CustomizableParams)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type DummyIx struct {
	PairStatus       PairStatus
	PairType         PairType
	ActivationType   ActivationType
	TokenProgramFlag TokenProgramFlags
	ResizeSide       ResizeSide
	Rounding         Rounding
}

func (obj DummyIx) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `PairStatus`:
	if err = encoder.Encode(obj.PairStatus); err != nil {
		return fmt.Errorf("error while marshaling PairStatus:%w", err)
	}
	// Serialize `PairType`:
	if err = encoder.Encode(obj.PairType); err != nil {
		return fmt.Errorf("error while marshaling PairType:%w", err)
	}
	// Serialize `ActivationType`:
	if err = encoder.Encode(obj.ActivationType); err != nil {
		return fmt.Errorf("error while marshaling ActivationType:%w", err)
	}
	// Serialize `TokenProgramFlag`:
	if err = encoder.Encode(obj.TokenProgramFlag); err != nil {
		return fmt.Errorf("error while marshaling TokenProgramFlag:%w", err)
	}
	// Serialize `ResizeSide`:
	if err = encoder.Encode(obj.ResizeSide); err != nil {
		return fmt.Errorf("error while marshaling ResizeSide:%w", err)
	}
	// Serialize `Rounding`:
	if err = encoder.Encode(obj.Rounding); err != nil {
		return fmt.Errorf("error while marshaling Rounding:%w", err)
	}
	return nil
}

func (obj DummyIx) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding DummyIx: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *DummyIx) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `PairStatus`:
	if err = decoder.Decode(&obj.PairStatus); err != nil {
		return fmt.Errorf("error while unmarshaling PairStatus:%w", err)
	}
	// Deserialize `PairType`:
	if err = decoder.Decode(&obj.PairType); err != nil {
		return fmt.Errorf("error while unmarshaling PairType:%w", err)
	}
	// Deserialize `ActivationType`:
	if err = decoder.Decode(&obj.ActivationType); err != nil {
		return fmt.Errorf("error while unmarshaling ActivationType:%w", err)
	}
	// Deserialize `TokenProgramFlag`:
	if err = decoder.Decode(&obj.TokenProgramFlag); err != nil {
		return fmt.Errorf("error while unmarshaling TokenProgramFlag:%w", err)
	}
	// Deserialize `ResizeSide`:
	if err = decoder.Decode(&obj.ResizeSide); err != nil {
		return fmt.Errorf("error while unmarshaling ResizeSide:%w", err)
	}
	// Deserialize `Rounding`:
	if err = decoder.Decode(&obj.Rounding); err != nil {
		return fmt.Errorf("error while unmarshaling Rounding:%w", err)
	}
	return nil
}

func (obj *DummyIx) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling DummyIx: %w", err)
	}
	return nil
}

func UnmarshalDummyIx(buf []byte) (*DummyIx, error) {
	obj := new(DummyIx)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type DynamicFeeParameter struct {
	// Filter period determine high frequency trading time window.
	FilterPeriod uint16

	// Decay period determine when the volatile fee start decay / decrease.
	DecayPeriod uint16

	// Reduction factor controls the volatile fee rate decrement rate.
	ReductionFactor uint16

	// Used to scale the variable fee component depending on the dynamic of the market
	VariableFeeControl uint32

	// Maximum number of bin crossed can be accumulated. Used to cap volatile fee rate.
	MaxVolatilityAccumulator uint32
}

func (obj DynamicFeeParameter) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `FilterPeriod`:
	if err = encoder.Encode(obj.FilterPeriod); err != nil {
		return fmt.Errorf("error while marshaling FilterPeriod:%w", err)
	}
	// Serialize `DecayPeriod`:
	if err = encoder.Encode(obj.DecayPeriod); err != nil {
		return fmt.Errorf("error while marshaling DecayPeriod:%w", err)
	}
	// Serialize `ReductionFactor`:
	if err = encoder.Encode(obj.ReductionFactor); err != nil {
		return fmt.Errorf("error while marshaling ReductionFactor:%w", err)
	}
	// Serialize `VariableFeeControl`:
	if err = encoder.Encode(obj.VariableFeeControl); err != nil {
		return fmt.Errorf("error while marshaling VariableFeeControl:%w", err)
	}
	// Serialize `MaxVolatilityAccumulator`:
	if err = encoder.Encode(obj.MaxVolatilityAccumulator); err != nil {
		return fmt.Errorf("error while marshaling MaxVolatilityAccumulator:%w", err)
	}
	return nil
}

func (obj DynamicFeeParameter) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding DynamicFeeParameter: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *DynamicFeeParameter) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `FilterPeriod`:
	if err = decoder.Decode(&obj.FilterPeriod); err != nil {
		return fmt.Errorf("error while unmarshaling FilterPeriod:%w", err)
	}
	// Deserialize `DecayPeriod`:
	if err = decoder.Decode(&obj.DecayPeriod); err != nil {
		return fmt.Errorf("error while unmarshaling DecayPeriod:%w", err)
	}
	// Deserialize `ReductionFactor`:
	if err = decoder.Decode(&obj.ReductionFactor); err != nil {
		return fmt.Errorf("error while unmarshaling ReductionFactor:%w", err)
	}
	// Deserialize `VariableFeeControl`:
	if err = decoder.Decode(&obj.VariableFeeControl); err != nil {
		return fmt.Errorf("error while unmarshaling VariableFeeControl:%w", err)
	}
	// Deserialize `MaxVolatilityAccumulator`:
	if err = decoder.Decode(&obj.MaxVolatilityAccumulator); err != nil {
		return fmt.Errorf("error while unmarshaling MaxVolatilityAccumulator:%w", err)
	}
	return nil
}

func (obj *DynamicFeeParameter) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling DynamicFeeParameter: %w", err)
	}
	return nil
}

func UnmarshalDynamicFeeParameter(buf []byte) (*DynamicFeeParameter, error) {
	obj := new(DynamicFeeParameter)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type FeeInfo struct {
	FeeXPerTokenComplete binary.Uint128
	FeeYPerTokenComplete binary.Uint128
	FeeXPending          uint64
	FeeYPending          uint64
}

func (obj FeeInfo) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `FeeXPerTokenComplete`:
	if err = encoder.Encode(obj.FeeXPerTokenComplete); err != nil {
		return fmt.Errorf("error while marshaling FeeXPerTokenComplete:%w", err)
	}
	// Serialize `FeeYPerTokenComplete`:
	if err = encoder.Encode(obj.FeeYPerTokenComplete); err != nil {
		return fmt.Errorf("error while marshaling FeeYPerTokenComplete:%w", err)
	}
	// Serialize `FeeXPending`:
	if err = encoder.Encode(obj.FeeXPending); err != nil {
		return fmt.Errorf("error while marshaling FeeXPending:%w", err)
	}
	// Serialize `FeeYPending`:
	if err = encoder.Encode(obj.FeeYPending); err != nil {
		return fmt.Errorf("error while marshaling FeeYPending:%w", err)
	}
	return nil
}

func (obj FeeInfo) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding FeeInfo: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *FeeInfo) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `FeeXPerTokenComplete`:
	if err = decoder.Decode(&obj.FeeXPerTokenComplete); err != nil {
		return fmt.Errorf("error while unmarshaling FeeXPerTokenComplete:%w", err)
	}
	// Deserialize `FeeYPerTokenComplete`:
	if err = decoder.Decode(&obj.FeeYPerTokenComplete); err != nil {
		return fmt.Errorf("error while unmarshaling FeeYPerTokenComplete:%w", err)
	}
	// Deserialize `FeeXPending`:
	if err = decoder.Decode(&obj.FeeXPending); err != nil {
		return fmt.Errorf("error while unmarshaling FeeXPending:%w", err)
	}
	// Deserialize `FeeYPending`:
	if err = decoder.Decode(&obj.FeeYPending); err != nil {
		return fmt.Errorf("error while unmarshaling FeeYPending:%w", err)
	}
	return nil
}

func (obj *FeeInfo) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling FeeInfo: %w", err)
	}
	return nil
}

func UnmarshalFeeInfo(buf []byte) (*FeeInfo, error) {
	obj := new(FeeInfo)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitPermissionPairIx struct {
	ActiveId           int32
	BinStep            uint16
	BaseFactor         uint16
	BaseFeePowerFactor uint8
	ActivationType     uint8
	ProtocolShare      uint16
}

func (obj InitPermissionPairIx) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `ActiveId`:
	if err = encoder.Encode(obj.ActiveId); err != nil {
		return fmt.Errorf("error while marshaling ActiveId:%w", err)
	}
	// Serialize `BinStep`:
	if err = encoder.Encode(obj.BinStep); err != nil {
		return fmt.Errorf("error while marshaling BinStep:%w", err)
	}
	// Serialize `BaseFactor`:
	if err = encoder.Encode(obj.BaseFactor); err != nil {
		return fmt.Errorf("error while marshaling BaseFactor:%w", err)
	}
	// Serialize `BaseFeePowerFactor`:
	if err = encoder.Encode(obj.BaseFeePowerFactor); err != nil {
		return fmt.Errorf("error while marshaling BaseFeePowerFactor:%w", err)
	}
	// Serialize `ActivationType`:
	if err = encoder.Encode(obj.ActivationType); err != nil {
		return fmt.Errorf("error while marshaling ActivationType:%w", err)
	}
	// Serialize `ProtocolShare`:
	if err = encoder.Encode(obj.ProtocolShare); err != nil {
		return fmt.Errorf("error while marshaling ProtocolShare:%w", err)
	}
	return nil
}

func (obj InitPermissionPairIx) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding InitPermissionPairIx: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *InitPermissionPairIx) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `ActiveId`:
	if err = decoder.Decode(&obj.ActiveId); err != nil {
		return fmt.Errorf("error while unmarshaling ActiveId:%w", err)
	}
	// Deserialize `BinStep`:
	if err = decoder.Decode(&obj.BinStep); err != nil {
		return fmt.Errorf("error while unmarshaling BinStep:%w", err)
	}
	// Deserialize `BaseFactor`:
	if err = decoder.Decode(&obj.BaseFactor); err != nil {
		return fmt.Errorf("error while unmarshaling BaseFactor:%w", err)
	}
	// Deserialize `BaseFeePowerFactor`:
	if err = decoder.Decode(&obj.BaseFeePowerFactor); err != nil {
		return fmt.Errorf("error while unmarshaling BaseFeePowerFactor:%w", err)
	}
	// Deserialize `ActivationType`:
	if err = decoder.Decode(&obj.ActivationType); err != nil {
		return fmt.Errorf("error while unmarshaling ActivationType:%w", err)
	}
	// Deserialize `ProtocolShare`:
	if err = decoder.Decode(&obj.ProtocolShare); err != nil {
		return fmt.Errorf("error while unmarshaling ProtocolShare:%w", err)
	}
	return nil
}

func (obj *InitPermissionPairIx) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitPermissionPairIx: %w", err)
	}
	return nil
}

func UnmarshalInitPermissionPairIx(buf []byte) (*InitPermissionPairIx, error) {
	obj := new(InitPermissionPairIx)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitPresetParameters2Ix struct {
	Index uint16

	// Bin step. Represent the price increment / decrement.
	BinStep uint16

	// Used for base fee calculation. base_fee_rate = base_factor * bin_step * 10 * 10^base_fee_power_factor
	BaseFactor uint16

	// Filter period determine high frequency trading time window.
	FilterPeriod uint16

	// Decay period determine when the volatile fee start decay / decrease.
	DecayPeriod uint16

	// Reduction factor controls the volatile fee rate decrement rate.
	ReductionFactor uint16

	// Used to scale the variable fee component depending on the dynamic of the market
	VariableFeeControl uint32

	// Maximum number of bin crossed can be accumulated. Used to cap volatile fee rate.
	MaxVolatilityAccumulator uint32

	// Portion of swap fees retained by the protocol by controlling protocol_share parameter. protocol_swap_fee = protocol_share * total_swap_fee
	ProtocolShare uint16

	// Base fee power factor
	BaseFeePowerFactor uint8
}

func (obj InitPresetParameters2Ix) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Index`:
	if err = encoder.Encode(obj.Index); err != nil {
		return fmt.Errorf("error while marshaling Index:%w", err)
	}
	// Serialize `BinStep`:
	if err = encoder.Encode(obj.BinStep); err != nil {
		return fmt.Errorf("error while marshaling BinStep:%w", err)
	}
	// Serialize `BaseFactor`:
	if err = encoder.Encode(obj.BaseFactor); err != nil {
		return fmt.Errorf("error while marshaling BaseFactor:%w", err)
	}
	// Serialize `FilterPeriod`:
	if err = encoder.Encode(obj.FilterPeriod); err != nil {
		return fmt.Errorf("error while marshaling FilterPeriod:%w", err)
	}
	// Serialize `DecayPeriod`:
	if err = encoder.Encode(obj.DecayPeriod); err != nil {
		return fmt.Errorf("error while marshaling DecayPeriod:%w", err)
	}
	// Serialize `ReductionFactor`:
	if err = encoder.Encode(obj.ReductionFactor); err != nil {
		return fmt.Errorf("error while marshaling ReductionFactor:%w", err)
	}
	// Serialize `VariableFeeControl`:
	if err = encoder.Encode(obj.VariableFeeControl); err != nil {
		return fmt.Errorf("error while marshaling VariableFeeControl:%w", err)
	}
	// Serialize `MaxVolatilityAccumulator`:
	if err = encoder.Encode(obj.MaxVolatilityAccumulator); err != nil {
		return fmt.Errorf("error while marshaling MaxVolatilityAccumulator:%w", err)
	}
	// Serialize `ProtocolShare`:
	if err = encoder.Encode(obj.ProtocolShare); err != nil {
		return fmt.Errorf("error while marshaling ProtocolShare:%w", err)
	}
	// Serialize `BaseFeePowerFactor`:
	if err = encoder.Encode(obj.BaseFeePowerFactor); err != nil {
		return fmt.Errorf("error while marshaling BaseFeePowerFactor:%w", err)
	}
	return nil
}

func (obj InitPresetParameters2Ix) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding InitPresetParameters2Ix: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *InitPresetParameters2Ix) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Index`:
	if err = decoder.Decode(&obj.Index); err != nil {
		return fmt.Errorf("error while unmarshaling Index:%w", err)
	}
	// Deserialize `BinStep`:
	if err = decoder.Decode(&obj.BinStep); err != nil {
		return fmt.Errorf("error while unmarshaling BinStep:%w", err)
	}
	// Deserialize `BaseFactor`:
	if err = decoder.Decode(&obj.BaseFactor); err != nil {
		return fmt.Errorf("error while unmarshaling BaseFactor:%w", err)
	}
	// Deserialize `FilterPeriod`:
	if err = decoder.Decode(&obj.FilterPeriod); err != nil {
		return fmt.Errorf("error while unmarshaling FilterPeriod:%w", err)
	}
	// Deserialize `DecayPeriod`:
	if err = decoder.Decode(&obj.DecayPeriod); err != nil {
		return fmt.Errorf("error while unmarshaling DecayPeriod:%w", err)
	}
	// Deserialize `ReductionFactor`:
	if err = decoder.Decode(&obj.ReductionFactor); err != nil {
		return fmt.Errorf("error while unmarshaling ReductionFactor:%w", err)
	}
	// Deserialize `VariableFeeControl`:
	if err = decoder.Decode(&obj.VariableFeeControl); err != nil {
		return fmt.Errorf("error while unmarshaling VariableFeeControl:%w", err)
	}
	// Deserialize `MaxVolatilityAccumulator`:
	if err = decoder.Decode(&obj.MaxVolatilityAccumulator); err != nil {
		return fmt.Errorf("error while unmarshaling MaxVolatilityAccumulator:%w", err)
	}
	// Deserialize `ProtocolShare`:
	if err = decoder.Decode(&obj.ProtocolShare); err != nil {
		return fmt.Errorf("error while unmarshaling ProtocolShare:%w", err)
	}
	// Deserialize `BaseFeePowerFactor`:
	if err = decoder.Decode(&obj.BaseFeePowerFactor); err != nil {
		return fmt.Errorf("error while unmarshaling BaseFeePowerFactor:%w", err)
	}
	return nil
}

func (obj *InitPresetParameters2Ix) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitPresetParameters2Ix: %w", err)
	}
	return nil
}

func UnmarshalInitPresetParameters2Ix(buf []byte) (*InitPresetParameters2Ix, error) {
	obj := new(InitPresetParameters2Ix)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitPresetParametersIx struct {
	// Bin step. Represent the price increment / decrement.
	BinStep uint16

	// Used for base fee calculation. base_fee_rate = base_factor * bin_step * 10 * 10^base_fee_power_factor
	BaseFactor uint16

	// Filter period determine high frequency trading time window.
	FilterPeriod uint16

	// Decay period determine when the volatile fee start decay / decrease.
	DecayPeriod uint16

	// Reduction factor controls the volatile fee rate decrement rate.
	ReductionFactor uint16

	// Used to scale the variable fee component depending on the dynamic of the market
	VariableFeeControl uint32

	// Maximum number of bin crossed can be accumulated. Used to cap volatile fee rate.
	MaxVolatilityAccumulator uint32

	// Portion of swap fees retained by the protocol by controlling protocol_share parameter. protocol_swap_fee = protocol_share * total_swap_fee
	ProtocolShare uint16
}

func (obj InitPresetParametersIx) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `BinStep`:
	if err = encoder.Encode(obj.BinStep); err != nil {
		return fmt.Errorf("error while marshaling BinStep:%w", err)
	}
	// Serialize `BaseFactor`:
	if err = encoder.Encode(obj.BaseFactor); err != nil {
		return fmt.Errorf("error while marshaling BaseFactor:%w", err)
	}
	// Serialize `FilterPeriod`:
	if err = encoder.Encode(obj.FilterPeriod); err != nil {
		return fmt.Errorf("error while marshaling FilterPeriod:%w", err)
	}
	// Serialize `DecayPeriod`:
	if err = encoder.Encode(obj.DecayPeriod); err != nil {
		return fmt.Errorf("error while marshaling DecayPeriod:%w", err)
	}
	// Serialize `ReductionFactor`:
	if err = encoder.Encode(obj.ReductionFactor); err != nil {
		return fmt.Errorf("error while marshaling ReductionFactor:%w", err)
	}
	// Serialize `VariableFeeControl`:
	if err = encoder.Encode(obj.VariableFeeControl); err != nil {
		return fmt.Errorf("error while marshaling VariableFeeControl:%w", err)
	}
	// Serialize `MaxVolatilityAccumulator`:
	if err = encoder.Encode(obj.MaxVolatilityAccumulator); err != nil {
		return fmt.Errorf("error while marshaling MaxVolatilityAccumulator:%w", err)
	}
	// Serialize `ProtocolShare`:
	if err = encoder.Encode(obj.ProtocolShare); err != nil {
		return fmt.Errorf("error while marshaling ProtocolShare:%w", err)
	}
	return nil
}

func (obj InitPresetParametersIx) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding InitPresetParametersIx: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *InitPresetParametersIx) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `BinStep`:
	if err = decoder.Decode(&obj.BinStep); err != nil {
		return fmt.Errorf("error while unmarshaling BinStep:%w", err)
	}
	// Deserialize `BaseFactor`:
	if err = decoder.Decode(&obj.BaseFactor); err != nil {
		return fmt.Errorf("error while unmarshaling BaseFactor:%w", err)
	}
	// Deserialize `FilterPeriod`:
	if err = decoder.Decode(&obj.FilterPeriod); err != nil {
		return fmt.Errorf("error while unmarshaling FilterPeriod:%w", err)
	}
	// Deserialize `DecayPeriod`:
	if err = decoder.Decode(&obj.DecayPeriod); err != nil {
		return fmt.Errorf("error while unmarshaling DecayPeriod:%w", err)
	}
	// Deserialize `ReductionFactor`:
	if err = decoder.Decode(&obj.ReductionFactor); err != nil {
		return fmt.Errorf("error while unmarshaling ReductionFactor:%w", err)
	}
	// Deserialize `VariableFeeControl`:
	if err = decoder.Decode(&obj.VariableFeeControl); err != nil {
		return fmt.Errorf("error while unmarshaling VariableFeeControl:%w", err)
	}
	// Deserialize `MaxVolatilityAccumulator`:
	if err = decoder.Decode(&obj.MaxVolatilityAccumulator); err != nil {
		return fmt.Errorf("error while unmarshaling MaxVolatilityAccumulator:%w", err)
	}
	// Deserialize `ProtocolShare`:
	if err = decoder.Decode(&obj.ProtocolShare); err != nil {
		return fmt.Errorf("error while unmarshaling ProtocolShare:%w", err)
	}
	return nil
}

func (obj *InitPresetParametersIx) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitPresetParametersIx: %w", err)
	}
	return nil
}

func UnmarshalInitPresetParametersIx(buf []byte) (*InitPresetParametersIx, error) {
	obj := new(InitPresetParametersIx)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type InitializeLbPair2Params struct {
	// Pool price
	ActiveId int32

	// Padding, for future use
	Padding [96]uint8
}

func (obj InitializeLbPair2Params) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `ActiveId`:
	if err = encoder.Encode(obj.ActiveId); err != nil {
		return fmt.Errorf("error while marshaling ActiveId:%w", err)
	}
	// Serialize `Padding`:
	if err = encoder.Encode(obj.Padding); err != nil {
		return fmt.Errorf("error while marshaling Padding:%w", err)
	}
	return nil
}

func (obj InitializeLbPair2Params) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding InitializeLbPair2Params: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *InitializeLbPair2Params) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `ActiveId`:
	if err = decoder.Decode(&obj.ActiveId); err != nil {
		return fmt.Errorf("error while unmarshaling ActiveId:%w", err)
	}
	// Deserialize `Padding`:
	if err = decoder.Decode(&obj.Padding); err != nil {
		return fmt.Errorf("error while unmarshaling Padding:%w", err)
	}
	return nil
}

func (obj *InitializeLbPair2Params) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling InitializeLbPair2Params: %w", err)
	}
	return nil
}

func UnmarshalInitializeLbPair2Params(buf []byte) (*InitializeLbPair2Params, error) {
	obj := new(InitializeLbPair2Params)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type LiquidityOneSideParameter struct {
	// Amount of X token or Y token to deposit
	Amount uint64

	// Active bin that integrator observe off-chain
	ActiveId int32

	// max active bin slippage allowed
	MaxActiveBinSlippage int32

	// Liquidity distribution to each bins
	BinLiquidityDist []BinLiquidityDistributionByWeight
}

func (obj LiquidityOneSideParameter) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Amount`:
	if err = encoder.Encode(obj.Amount); err != nil {
		return fmt.Errorf("error while marshaling Amount:%w", err)
	}
	// Serialize `ActiveId`:
	if err = encoder.Encode(obj.ActiveId); err != nil {
		return fmt.Errorf("error while marshaling ActiveId:%w", err)
	}
	// Serialize `MaxActiveBinSlippage`:
	if err = encoder.Encode(obj.MaxActiveBinSlippage); err != nil {
		return fmt.Errorf("error while marshaling MaxActiveBinSlippage:%w", err)
	}
	// Serialize `BinLiquidityDist`:
	if err = encoder.Encode(obj.BinLiquidityDist); err != nil {
		return fmt.Errorf("error while marshaling BinLiquidityDist:%w", err)
	}
	return nil
}

func (obj LiquidityOneSideParameter) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding LiquidityOneSideParameter: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *LiquidityOneSideParameter) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Amount`:
	if err = decoder.Decode(&obj.Amount); err != nil {
		return fmt.Errorf("error while unmarshaling Amount:%w", err)
	}
	// Deserialize `ActiveId`:
	if err = decoder.Decode(&obj.ActiveId); err != nil {
		return fmt.Errorf("error while unmarshaling ActiveId:%w", err)
	}
	// Deserialize `MaxActiveBinSlippage`:
	if err = decoder.Decode(&obj.MaxActiveBinSlippage); err != nil {
		return fmt.Errorf("error while unmarshaling MaxActiveBinSlippage:%w", err)
	}
	// Deserialize `BinLiquidityDist`:
	if err = decoder.Decode(&obj.BinLiquidityDist); err != nil {
		return fmt.Errorf("error while unmarshaling BinLiquidityDist:%w", err)
	}
	return nil
}

func (obj *LiquidityOneSideParameter) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling LiquidityOneSideParameter: %w", err)
	}
	return nil
}

func UnmarshalLiquidityOneSideParameter(buf []byte) (*LiquidityOneSideParameter, error) {
	obj := new(LiquidityOneSideParameter)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type LiquidityParameter struct {
	// Amount of X token to deposit
	AmountX uint64

	// Amount of Y token to deposit
	AmountY uint64

	// Liquidity distribution to each bins
	BinLiquidityDist []BinLiquidityDistribution
}

func (obj LiquidityParameter) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `AmountX`:
	if err = encoder.Encode(obj.AmountX); err != nil {
		return fmt.Errorf("error while marshaling AmountX:%w", err)
	}
	// Serialize `AmountY`:
	if err = encoder.Encode(obj.AmountY); err != nil {
		return fmt.Errorf("error while marshaling AmountY:%w", err)
	}
	// Serialize `BinLiquidityDist`:
	if err = encoder.Encode(obj.BinLiquidityDist); err != nil {
		return fmt.Errorf("error while marshaling BinLiquidityDist:%w", err)
	}
	return nil
}

func (obj LiquidityParameter) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding LiquidityParameter: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *LiquidityParameter) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `AmountX`:
	if err = decoder.Decode(&obj.AmountX); err != nil {
		return fmt.Errorf("error while unmarshaling AmountX:%w", err)
	}
	// Deserialize `AmountY`:
	if err = decoder.Decode(&obj.AmountY); err != nil {
		return fmt.Errorf("error while unmarshaling AmountY:%w", err)
	}
	// Deserialize `BinLiquidityDist`:
	if err = decoder.Decode(&obj.BinLiquidityDist); err != nil {
		return fmt.Errorf("error while unmarshaling BinLiquidityDist:%w", err)
	}
	return nil
}

func (obj *LiquidityParameter) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling LiquidityParameter: %w", err)
	}
	return nil
}

func UnmarshalLiquidityParameter(buf []byte) (*LiquidityParameter, error) {
	obj := new(LiquidityParameter)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type LiquidityParameterByStrategy struct {
	// Amount of X token to deposit
	AmountX uint64

	// Amount of Y token to deposit
	AmountY uint64

	// Active bin that integrator observe off-chain
	ActiveId int32

	// max active bin slippage allowed
	MaxActiveBinSlippage int32

	// strategy parameters
	StrategyParameters StrategyParameters
}

func (obj LiquidityParameterByStrategy) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `AmountX`:
	if err = encoder.Encode(obj.AmountX); err != nil {
		return fmt.Errorf("error while marshaling AmountX:%w", err)
	}
	// Serialize `AmountY`:
	if err = encoder.Encode(obj.AmountY); err != nil {
		return fmt.Errorf("error while marshaling AmountY:%w", err)
	}
	// Serialize `ActiveId`:
	if err = encoder.Encode(obj.ActiveId); err != nil {
		return fmt.Errorf("error while marshaling ActiveId:%w", err)
	}
	// Serialize `MaxActiveBinSlippage`:
	if err = encoder.Encode(obj.MaxActiveBinSlippage); err != nil {
		return fmt.Errorf("error while marshaling MaxActiveBinSlippage:%w", err)
	}
	// Serialize `StrategyParameters`:
	if err = encoder.Encode(obj.StrategyParameters); err != nil {
		return fmt.Errorf("error while marshaling StrategyParameters:%w", err)
	}
	return nil
}

func (obj LiquidityParameterByStrategy) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding LiquidityParameterByStrategy: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *LiquidityParameterByStrategy) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `AmountX`:
	if err = decoder.Decode(&obj.AmountX); err != nil {
		return fmt.Errorf("error while unmarshaling AmountX:%w", err)
	}
	// Deserialize `AmountY`:
	if err = decoder.Decode(&obj.AmountY); err != nil {
		return fmt.Errorf("error while unmarshaling AmountY:%w", err)
	}
	// Deserialize `ActiveId`:
	if err = decoder.Decode(&obj.ActiveId); err != nil {
		return fmt.Errorf("error while unmarshaling ActiveId:%w", err)
	}
	// Deserialize `MaxActiveBinSlippage`:
	if err = decoder.Decode(&obj.MaxActiveBinSlippage); err != nil {
		return fmt.Errorf("error while unmarshaling MaxActiveBinSlippage:%w", err)
	}
	// Deserialize `StrategyParameters`:
	if err = decoder.Decode(&obj.StrategyParameters); err != nil {
		return fmt.Errorf("error while unmarshaling StrategyParameters:%w", err)
	}
	return nil
}

func (obj *LiquidityParameterByStrategy) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling LiquidityParameterByStrategy: %w", err)
	}
	return nil
}

func UnmarshalLiquidityParameterByStrategy(buf []byte) (*LiquidityParameterByStrategy, error) {
	obj := new(LiquidityParameterByStrategy)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type LiquidityParameterByStrategyOneSide struct {
	// Amount of X token or Y token to deposit
	Amount uint64

	// Active bin that integrator observe off-chain
	ActiveId int32

	// max active bin slippage allowed
	MaxActiveBinSlippage int32

	// strategy parameters
	StrategyParameters StrategyParameters
}

func (obj LiquidityParameterByStrategyOneSide) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Amount`:
	if err = encoder.Encode(obj.Amount); err != nil {
		return fmt.Errorf("error while marshaling Amount:%w", err)
	}
	// Serialize `ActiveId`:
	if err = encoder.Encode(obj.ActiveId); err != nil {
		return fmt.Errorf("error while marshaling ActiveId:%w", err)
	}
	// Serialize `MaxActiveBinSlippage`:
	if err = encoder.Encode(obj.MaxActiveBinSlippage); err != nil {
		return fmt.Errorf("error while marshaling MaxActiveBinSlippage:%w", err)
	}
	// Serialize `StrategyParameters`:
	if err = encoder.Encode(obj.StrategyParameters); err != nil {
		return fmt.Errorf("error while marshaling StrategyParameters:%w", err)
	}
	return nil
}

func (obj LiquidityParameterByStrategyOneSide) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding LiquidityParameterByStrategyOneSide: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *LiquidityParameterByStrategyOneSide) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Amount`:
	if err = decoder.Decode(&obj.Amount); err != nil {
		return fmt.Errorf("error while unmarshaling Amount:%w", err)
	}
	// Deserialize `ActiveId`:
	if err = decoder.Decode(&obj.ActiveId); err != nil {
		return fmt.Errorf("error while unmarshaling ActiveId:%w", err)
	}
	// Deserialize `MaxActiveBinSlippage`:
	if err = decoder.Decode(&obj.MaxActiveBinSlippage); err != nil {
		return fmt.Errorf("error while unmarshaling MaxActiveBinSlippage:%w", err)
	}
	// Deserialize `StrategyParameters`:
	if err = decoder.Decode(&obj.StrategyParameters); err != nil {
		return fmt.Errorf("error while unmarshaling StrategyParameters:%w", err)
	}
	return nil
}

func (obj *LiquidityParameterByStrategyOneSide) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling LiquidityParameterByStrategyOneSide: %w", err)
	}
	return nil
}

func UnmarshalLiquidityParameterByStrategyOneSide(buf []byte) (*LiquidityParameterByStrategyOneSide, error) {
	obj := new(LiquidityParameterByStrategyOneSide)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type LiquidityParameterByWeight struct {
	// Amount of X token to deposit
	AmountX uint64

	// Amount of Y token to deposit
	AmountY uint64

	// Active bin that integrator observe off-chain
	ActiveId int32

	// max active bin slippage allowed
	MaxActiveBinSlippage int32

	// Liquidity distribution to each bins
	BinLiquidityDist []BinLiquidityDistributionByWeight
}

func (obj LiquidityParameterByWeight) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `AmountX`:
	if err = encoder.Encode(obj.AmountX); err != nil {
		return fmt.Errorf("error while marshaling AmountX:%w", err)
	}
	// Serialize `AmountY`:
	if err = encoder.Encode(obj.AmountY); err != nil {
		return fmt.Errorf("error while marshaling AmountY:%w", err)
	}
	// Serialize `ActiveId`:
	if err = encoder.Encode(obj.ActiveId); err != nil {
		return fmt.Errorf("error while marshaling ActiveId:%w", err)
	}
	// Serialize `MaxActiveBinSlippage`:
	if err = encoder.Encode(obj.MaxActiveBinSlippage); err != nil {
		return fmt.Errorf("error while marshaling MaxActiveBinSlippage:%w", err)
	}
	// Serialize `BinLiquidityDist`:
	if err = encoder.Encode(obj.BinLiquidityDist); err != nil {
		return fmt.Errorf("error while marshaling BinLiquidityDist:%w", err)
	}
	return nil
}

func (obj LiquidityParameterByWeight) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding LiquidityParameterByWeight: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *LiquidityParameterByWeight) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `AmountX`:
	if err = decoder.Decode(&obj.AmountX); err != nil {
		return fmt.Errorf("error while unmarshaling AmountX:%w", err)
	}
	// Deserialize `AmountY`:
	if err = decoder.Decode(&obj.AmountY); err != nil {
		return fmt.Errorf("error while unmarshaling AmountY:%w", err)
	}
	// Deserialize `ActiveId`:
	if err = decoder.Decode(&obj.ActiveId); err != nil {
		return fmt.Errorf("error while unmarshaling ActiveId:%w", err)
	}
	// Deserialize `MaxActiveBinSlippage`:
	if err = decoder.Decode(&obj.MaxActiveBinSlippage); err != nil {
		return fmt.Errorf("error while unmarshaling MaxActiveBinSlippage:%w", err)
	}
	// Deserialize `BinLiquidityDist`:
	if err = decoder.Decode(&obj.BinLiquidityDist); err != nil {
		return fmt.Errorf("error while unmarshaling BinLiquidityDist:%w", err)
	}
	return nil
}

func (obj *LiquidityParameterByWeight) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling LiquidityParameterByWeight: %w", err)
	}
	return nil
}

func UnmarshalLiquidityParameterByWeight(buf []byte) (*LiquidityParameterByWeight, error) {
	obj := new(LiquidityParameterByWeight)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Pair status. 0 = Enabled, 1 = Disabled. Putting 0 as enabled for backward compatibility.
type PairStatus binary.BorshEnum

const (
	PairStatus_Enabled PairStatus = iota
	PairStatus_Disabled
)

func (value PairStatus) String() string {
	switch value {
	case PairStatus_Enabled:
		return "Enabled"
	case PairStatus_Disabled:
		return "Disabled"
	default:
		return ""
	}
}

// Type of the Pair. 0 = Permissionless, 1 = Permission, 2 = CustomizablePermissionless. Putting 0 as permissionless for backward compatibility.
type PairType binary.BorshEnum

const (
	PairType_Permissionless PairType = iota
	PairType_Permission
	PairType_CustomizablePermissionless
	PairType_PermissionlessV2
)

func (value PairType) String() string {
	switch value {
	case PairType_Permissionless:
		return "Permissionless"
	case PairType_Permission:
		return "Permission"
	case PairType_CustomizablePermissionless:
		return "CustomizablePermissionless"
	case PairType_PermissionlessV2:
		return "PermissionlessV2"
	default:
		return ""
	}
}

type PositionBinData struct {
	LiquidityShare binary.Uint128
	RewardInfo     UserRewardInfo
	FeeInfo        FeeInfo
}

func (obj PositionBinData) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `LiquidityShare`:
	if err = encoder.Encode(obj.LiquidityShare); err != nil {
		return fmt.Errorf("error while marshaling LiquidityShare:%w", err)
	}
	// Serialize `RewardInfo`:
	if err = encoder.Encode(obj.RewardInfo); err != nil {
		return fmt.Errorf("error while marshaling RewardInfo:%w", err)
	}
	// Serialize `FeeInfo`:
	if err = encoder.Encode(obj.FeeInfo); err != nil {
		return fmt.Errorf("error while marshaling FeeInfo:%w", err)
	}
	return nil
}

func (obj PositionBinData) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding PositionBinData: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *PositionBinData) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `LiquidityShare`:
	if err = decoder.Decode(&obj.LiquidityShare); err != nil {
		return fmt.Errorf("error while unmarshaling LiquidityShare:%w", err)
	}
	// Deserialize `RewardInfo`:
	if err = decoder.Decode(&obj.RewardInfo); err != nil {
		return fmt.Errorf("error while unmarshaling RewardInfo:%w", err)
	}
	// Deserialize `FeeInfo`:
	if err = decoder.Decode(&obj.FeeInfo); err != nil {
		return fmt.Errorf("error while unmarshaling FeeInfo:%w", err)
	}
	return nil
}

func (obj *PositionBinData) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling PositionBinData: %w", err)
	}
	return nil
}

func UnmarshalPositionBinData(buf []byte) (*PositionBinData, error) {
	obj := new(PositionBinData)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type ProtocolFee struct {
	AmountX uint64
	AmountY uint64
}

func (obj ProtocolFee) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `AmountX`:
	if err = encoder.Encode(obj.AmountX); err != nil {
		return fmt.Errorf("error while marshaling AmountX:%w", err)
	}
	// Serialize `AmountY`:
	if err = encoder.Encode(obj.AmountY); err != nil {
		return fmt.Errorf("error while marshaling AmountY:%w", err)
	}
	return nil
}

func (obj ProtocolFee) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding ProtocolFee: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *ProtocolFee) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `AmountX`:
	if err = decoder.Decode(&obj.AmountX); err != nil {
		return fmt.Errorf("error while unmarshaling AmountX:%w", err)
	}
	// Deserialize `AmountY`:
	if err = decoder.Decode(&obj.AmountY); err != nil {
		return fmt.Errorf("error while unmarshaling AmountY:%w", err)
	}
	return nil
}

func (obj *ProtocolFee) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ProtocolFee: %w", err)
	}
	return nil
}

func UnmarshalProtocolFee(buf []byte) (*ProtocolFee, error) {
	obj := new(ProtocolFee)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type RebalanceLiquidityParams struct {
	// active id
	ActiveId int32

	// max active bin slippage allowed
	MaxActiveBinSlippage uint16

	// a flag to indicate that whether fee should be harvested
	ShouldClaimFee bool

	// a flag to indicate that whether rewards should be harvested
	ShouldClaimReward bool

	// threshold for withdraw token x
	MinWithdrawXAmount uint64

	// threshold for deposit token x
	MaxDepositXAmount uint64

	// threshold for withdraw token y
	MinWithdrawYAmount uint64

	// threshold for deposit token y
	MaxDepositYAmount uint64

	// padding 32 bytes for future usage
	Padding [32]uint8

	// removes
	Removes []RemoveLiquidityParams

	// adds
	Adds []AddLiquidityParams
}

func (obj RebalanceLiquidityParams) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `ActiveId`:
	if err = encoder.Encode(obj.ActiveId); err != nil {
		return fmt.Errorf("error while marshaling ActiveId:%w", err)
	}
	// Serialize `MaxActiveBinSlippage`:
	if err = encoder.Encode(obj.MaxActiveBinSlippage); err != nil {
		return fmt.Errorf("error while marshaling MaxActiveBinSlippage:%w", err)
	}
	// Serialize `ShouldClaimFee`:
	if err = encoder.Encode(obj.ShouldClaimFee); err != nil {
		return fmt.Errorf("error while marshaling ShouldClaimFee:%w", err)
	}
	// Serialize `ShouldClaimReward`:
	if err = encoder.Encode(obj.ShouldClaimReward); err != nil {
		return fmt.Errorf("error while marshaling ShouldClaimReward:%w", err)
	}
	// Serialize `MinWithdrawXAmount`:
	if err = encoder.Encode(obj.MinWithdrawXAmount); err != nil {
		return fmt.Errorf("error while marshaling MinWithdrawXAmount:%w", err)
	}
	// Serialize `MaxDepositXAmount`:
	if err = encoder.Encode(obj.MaxDepositXAmount); err != nil {
		return fmt.Errorf("error while marshaling MaxDepositXAmount:%w", err)
	}
	// Serialize `MinWithdrawYAmount`:
	if err = encoder.Encode(obj.MinWithdrawYAmount); err != nil {
		return fmt.Errorf("error while marshaling MinWithdrawYAmount:%w", err)
	}
	// Serialize `MaxDepositYAmount`:
	if err = encoder.Encode(obj.MaxDepositYAmount); err != nil {
		return fmt.Errorf("error while marshaling MaxDepositYAmount:%w", err)
	}
	// Serialize `Padding`:
	if err = encoder.Encode(obj.Padding); err != nil {
		return fmt.Errorf("error while marshaling Padding:%w", err)
	}
	// Serialize `Removes`:
	if err = encoder.Encode(obj.Removes); err != nil {
		return fmt.Errorf("error while marshaling Removes:%w", err)
	}
	// Serialize `Adds`:
	if err = encoder.Encode(obj.Adds); err != nil {
		return fmt.Errorf("error while marshaling Adds:%w", err)
	}
	return nil
}

func (obj RebalanceLiquidityParams) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding RebalanceLiquidityParams: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *RebalanceLiquidityParams) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `ActiveId`:
	if err = decoder.Decode(&obj.ActiveId); err != nil {
		return fmt.Errorf("error while unmarshaling ActiveId:%w", err)
	}
	// Deserialize `MaxActiveBinSlippage`:
	if err = decoder.Decode(&obj.MaxActiveBinSlippage); err != nil {
		return fmt.Errorf("error while unmarshaling MaxActiveBinSlippage:%w", err)
	}
	// Deserialize `ShouldClaimFee`:
	if err = decoder.Decode(&obj.ShouldClaimFee); err != nil {
		return fmt.Errorf("error while unmarshaling ShouldClaimFee:%w", err)
	}
	// Deserialize `ShouldClaimReward`:
	if err = decoder.Decode(&obj.ShouldClaimReward); err != nil {
		return fmt.Errorf("error while unmarshaling ShouldClaimReward:%w", err)
	}
	// Deserialize `MinWithdrawXAmount`:
	if err = decoder.Decode(&obj.MinWithdrawXAmount); err != nil {
		return fmt.Errorf("error while unmarshaling MinWithdrawXAmount:%w", err)
	}
	// Deserialize `MaxDepositXAmount`:
	if err = decoder.Decode(&obj.MaxDepositXAmount); err != nil {
		return fmt.Errorf("error while unmarshaling MaxDepositXAmount:%w", err)
	}
	// Deserialize `MinWithdrawYAmount`:
	if err = decoder.Decode(&obj.MinWithdrawYAmount); err != nil {
		return fmt.Errorf("error while unmarshaling MinWithdrawYAmount:%w", err)
	}
	// Deserialize `MaxDepositYAmount`:
	if err = decoder.Decode(&obj.MaxDepositYAmount); err != nil {
		return fmt.Errorf("error while unmarshaling MaxDepositYAmount:%w", err)
	}
	// Deserialize `Padding`:
	if err = decoder.Decode(&obj.Padding); err != nil {
		return fmt.Errorf("error while unmarshaling Padding:%w", err)
	}
	// Deserialize `Removes`:
	if err = decoder.Decode(&obj.Removes); err != nil {
		return fmt.Errorf("error while unmarshaling Removes:%w", err)
	}
	// Deserialize `Adds`:
	if err = decoder.Decode(&obj.Adds); err != nil {
		return fmt.Errorf("error while unmarshaling Adds:%w", err)
	}
	return nil
}

func (obj *RebalanceLiquidityParams) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling RebalanceLiquidityParams: %w", err)
	}
	return nil
}

func UnmarshalRebalanceLiquidityParams(buf []byte) (*RebalanceLiquidityParams, error) {
	obj := new(RebalanceLiquidityParams)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type RemainingAccountsInfo struct {
	Slices []RemainingAccountsSlice
}

func (obj RemainingAccountsInfo) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Slices`:
	if err = encoder.Encode(obj.Slices); err != nil {
		return fmt.Errorf("error while marshaling Slices:%w", err)
	}
	return nil
}

func (obj RemainingAccountsInfo) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding RemainingAccountsInfo: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *RemainingAccountsInfo) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Slices`:
	if err = decoder.Decode(&obj.Slices); err != nil {
		return fmt.Errorf("error while unmarshaling Slices:%w", err)
	}
	return nil
}

func (obj *RemainingAccountsInfo) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling RemainingAccountsInfo: %w", err)
	}
	return nil
}

func UnmarshalRemainingAccountsInfo(buf []byte) (*RemainingAccountsInfo, error) {
	obj := new(RemainingAccountsInfo)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type RemainingAccountsSlice struct {
	AccountsType AccountsType
	Length       uint8
}

func (obj RemainingAccountsSlice) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `AccountsType`:
	{
		if err = EncodeAccountsType(encoder, obj.AccountsType); err != nil {
			return fmt.Errorf("error while marshalingAccountsType:%w", err)
		}
	}
	// Serialize `Length`:
	if err = encoder.Encode(obj.Length); err != nil {
		return fmt.Errorf("error while marshaling Length:%w", err)
	}
	return nil
}

func (obj RemainingAccountsSlice) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding RemainingAccountsSlice: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *RemainingAccountsSlice) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `AccountsType`:
	{
		var err error
		obj.AccountsType, err = DecodeAccountsType(decoder)
		if err != nil {
			return err
		}
	}
	// Deserialize `Length`:
	if err = decoder.Decode(&obj.Length); err != nil {
		return fmt.Errorf("error while unmarshaling Length:%w", err)
	}
	return nil
}

func (obj *RemainingAccountsSlice) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling RemainingAccountsSlice: %w", err)
	}
	return nil
}

func UnmarshalRemainingAccountsSlice(buf []byte) (*RemainingAccountsSlice, error) {
	obj := new(RemainingAccountsSlice)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type RemoveLiquidityParams struct {
	MinBinId *int32 `bin:"optional"`
	MaxBinId *int32 `bin:"optional"`
	Bps      uint16
	Padding  [16]uint8
}

func (obj RemoveLiquidityParams) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `MinBinId` (optional):
	{
		if obj.MinBinId == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling MinBinId optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling MinBinId optionality: %w", err)
			}
			if err = encoder.Encode(obj.MinBinId); err != nil {
				return fmt.Errorf("error while marshaling MinBinId: %w", err)
			}
		}
	}
	// Serialize `MaxBinId` (optional):
	{
		if obj.MaxBinId == nil {
			if err = encoder.WriteOption(false); err != nil {
				return fmt.Errorf("error while marshaling MaxBinId optionality: %w", err)
			}
		} else {
			if err = encoder.WriteOption(true); err != nil {
				return fmt.Errorf("error while marshaling MaxBinId optionality: %w", err)
			}
			if err = encoder.Encode(obj.MaxBinId); err != nil {
				return fmt.Errorf("error while marshaling MaxBinId: %w", err)
			}
		}
	}
	// Serialize `Bps`:
	if err = encoder.Encode(obj.Bps); err != nil {
		return fmt.Errorf("error while marshaling Bps:%w", err)
	}
	// Serialize `Padding`:
	if err = encoder.Encode(obj.Padding); err != nil {
		return fmt.Errorf("error while marshaling Padding:%w", err)
	}
	return nil
}

func (obj RemoveLiquidityParams) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding RemoveLiquidityParams: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *RemoveLiquidityParams) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `MinBinId` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling MinBinId:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.MinBinId); err != nil {
				return fmt.Errorf("error while unmarshaling MinBinId:%w", err)
			}
		}
	}
	// Deserialize `MaxBinId` (optional):
	{
		ok, err := decoder.ReadOption()
		if err != nil {
			return fmt.Errorf("error while unmarshaling MaxBinId:%w", err)
		}
		if ok {
			if err = decoder.Decode(&obj.MaxBinId); err != nil {
				return fmt.Errorf("error while unmarshaling MaxBinId:%w", err)
			}
		}
	}
	// Deserialize `Bps`:
	if err = decoder.Decode(&obj.Bps); err != nil {
		return fmt.Errorf("error while unmarshaling Bps:%w", err)
	}
	// Deserialize `Padding`:
	if err = decoder.Decode(&obj.Padding); err != nil {
		return fmt.Errorf("error while unmarshaling Padding:%w", err)
	}
	return nil
}

func (obj *RemoveLiquidityParams) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling RemoveLiquidityParams: %w", err)
	}
	return nil
}

func UnmarshalRemoveLiquidityParams(buf []byte) (*RemoveLiquidityParams, error) {
	obj := new(RemoveLiquidityParams)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Side of resize, 0 for lower and 1 for upper
type ResizeSide binary.BorshEnum

const (
	ResizeSide_Lower ResizeSide = iota
	ResizeSide_Upper
)

func (value ResizeSide) String() string {
	switch value {
	case ResizeSide_Lower:
		return "Lower"
	case ResizeSide_Upper:
		return "Upper"
	default:
		return ""
	}
}

// Stores the state relevant for tracking liquidity mining rewards
type RewardInfo struct {
	// Reward token mint.
	Mint solanago.PublicKey

	// Reward vault token account.
	Vault solanago.PublicKey

	// Authority account that allows to fund rewards
	Funder solanago.PublicKey

	// TODO check whether we need to store it in pool
	RewardDuration uint64

	// TODO check whether we need to store it in pool
	RewardDurationEnd uint64

	// TODO check whether we need to store it in pool
	RewardRate binary.Uint128

	// The last time reward states were updated.
	LastUpdateTime uint64

	// Accumulated seconds where when farm distribute rewards, but the bin is empty. The reward will be accumulated for next reward time window.
	CumulativeSecondsWithEmptyLiquidityReward uint64
}

func (obj RewardInfo) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Mint`:
	if err = encoder.Encode(obj.Mint); err != nil {
		return fmt.Errorf("error while marshaling Mint:%w", err)
	}
	// Serialize `Vault`:
	if err = encoder.Encode(obj.Vault); err != nil {
		return fmt.Errorf("error while marshaling Vault:%w", err)
	}
	// Serialize `Funder`:
	if err = encoder.Encode(obj.Funder); err != nil {
		return fmt.Errorf("error while marshaling Funder:%w", err)
	}
	// Serialize `RewardDuration`:
	if err = encoder.Encode(obj.RewardDuration); err != nil {
		return fmt.Errorf("error while marshaling RewardDuration:%w", err)
	}
	// Serialize `RewardDurationEnd`:
	if err = encoder.Encode(obj.RewardDurationEnd); err != nil {
		return fmt.Errorf("error while marshaling RewardDurationEnd:%w", err)
	}
	// Serialize `RewardRate`:
	if err = encoder.Encode(obj.RewardRate); err != nil {
		return fmt.Errorf("error while marshaling RewardRate:%w", err)
	}
	// Serialize `LastUpdateTime`:
	if err = encoder.Encode(obj.LastUpdateTime); err != nil {
		return fmt.Errorf("error while marshaling LastUpdateTime:%w", err)
	}
	// Serialize `CumulativeSecondsWithEmptyLiquidityReward`:
	if err = encoder.Encode(obj.CumulativeSecondsWithEmptyLiquidityReward); err != nil {
		return fmt.Errorf("error while marshaling CumulativeSecondsWithEmptyLiquidityReward:%w", err)
	}
	return nil
}

func (obj RewardInfo) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding RewardInfo: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *RewardInfo) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Mint`:
	if err = decoder.Decode(&obj.Mint); err != nil {
		return fmt.Errorf("error while unmarshaling Mint:%w", err)
	}
	// Deserialize `Vault`:
	if err = decoder.Decode(&obj.Vault); err != nil {
		return fmt.Errorf("error while unmarshaling Vault:%w", err)
	}
	// Deserialize `Funder`:
	if err = decoder.Decode(&obj.Funder); err != nil {
		return fmt.Errorf("error while unmarshaling Funder:%w", err)
	}
	// Deserialize `RewardDuration`:
	if err = decoder.Decode(&obj.RewardDuration); err != nil {
		return fmt.Errorf("error while unmarshaling RewardDuration:%w", err)
	}
	// Deserialize `RewardDurationEnd`:
	if err = decoder.Decode(&obj.RewardDurationEnd); err != nil {
		return fmt.Errorf("error while unmarshaling RewardDurationEnd:%w", err)
	}
	// Deserialize `RewardRate`:
	if err = decoder.Decode(&obj.RewardRate); err != nil {
		return fmt.Errorf("error while unmarshaling RewardRate:%w", err)
	}
	// Deserialize `LastUpdateTime`:
	if err = decoder.Decode(&obj.LastUpdateTime); err != nil {
		return fmt.Errorf("error while unmarshaling LastUpdateTime:%w", err)
	}
	// Deserialize `CumulativeSecondsWithEmptyLiquidityReward`:
	if err = decoder.Decode(&obj.CumulativeSecondsWithEmptyLiquidityReward); err != nil {
		return fmt.Errorf("error while unmarshaling CumulativeSecondsWithEmptyLiquidityReward:%w", err)
	}
	return nil
}

func (obj *RewardInfo) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling RewardInfo: %w", err)
	}
	return nil
}

func UnmarshalRewardInfo(buf []byte) (*RewardInfo, error) {
	obj := new(RewardInfo)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type Rounding binary.BorshEnum

const (
	Rounding_Up Rounding = iota
	Rounding_Down
)

func (value Rounding) String() string {
	switch value {
	case Rounding_Up:
		return "Up"
	case Rounding_Down:
		return "Down"
	default:
		return ""
	}
}

// Parameter that set by the protocol
type StaticParameters struct {
	// Used for base fee calculation. base_fee_rate = base_factor * bin_step * 10 * 10^base_fee_power_factor
	BaseFactor uint16

	// Filter period determine high frequency trading time window.
	FilterPeriod uint16

	// Decay period determine when the volatile fee start decay / decrease.
	DecayPeriod uint16

	// Reduction factor controls the volatile fee rate decrement rate.
	ReductionFactor uint16

	// Used to scale the variable fee component depending on the dynamic of the market
	VariableFeeControl uint32

	// Maximum number of bin crossed can be accumulated. Used to cap volatile fee rate.
	MaxVolatilityAccumulator uint32

	// Min bin id supported by the pool based on the configured bin step.
	MinBinId int32

	// Max bin id supported by the pool based on the configured bin step.
	MaxBinId int32

	// Portion of swap fees retained by the protocol by controlling protocol_share parameter. protocol_swap_fee = protocol_share * total_swap_fee
	ProtocolShare uint16

	// Base fee power factor
	BaseFeePowerFactor uint8

	// Padding for bytemuck safe alignment
	Padding [5]uint8
}

func (obj StaticParameters) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `BaseFactor`:
	if err = encoder.Encode(obj.BaseFactor); err != nil {
		return fmt.Errorf("error while marshaling BaseFactor:%w", err)
	}
	// Serialize `FilterPeriod`:
	if err = encoder.Encode(obj.FilterPeriod); err != nil {
		return fmt.Errorf("error while marshaling FilterPeriod:%w", err)
	}
	// Serialize `DecayPeriod`:
	if err = encoder.Encode(obj.DecayPeriod); err != nil {
		return fmt.Errorf("error while marshaling DecayPeriod:%w", err)
	}
	// Serialize `ReductionFactor`:
	if err = encoder.Encode(obj.ReductionFactor); err != nil {
		return fmt.Errorf("error while marshaling ReductionFactor:%w", err)
	}
	// Serialize `VariableFeeControl`:
	if err = encoder.Encode(obj.VariableFeeControl); err != nil {
		return fmt.Errorf("error while marshaling VariableFeeControl:%w", err)
	}
	// Serialize `MaxVolatilityAccumulator`:
	if err = encoder.Encode(obj.MaxVolatilityAccumulator); err != nil {
		return fmt.Errorf("error while marshaling MaxVolatilityAccumulator:%w", err)
	}
	// Serialize `MinBinId`:
	if err = encoder.Encode(obj.MinBinId); err != nil {
		return fmt.Errorf("error while marshaling MinBinId:%w", err)
	}
	// Serialize `MaxBinId`:
	if err = encoder.Encode(obj.MaxBinId); err != nil {
		return fmt.Errorf("error while marshaling MaxBinId:%w", err)
	}
	// Serialize `ProtocolShare`:
	if err = encoder.Encode(obj.ProtocolShare); err != nil {
		return fmt.Errorf("error while marshaling ProtocolShare:%w", err)
	}
	// Serialize `BaseFeePowerFactor`:
	if err = encoder.Encode(obj.BaseFeePowerFactor); err != nil {
		return fmt.Errorf("error while marshaling BaseFeePowerFactor:%w", err)
	}
	// Serialize `Padding`:
	if err = encoder.Encode(obj.Padding); err != nil {
		return fmt.Errorf("error while marshaling Padding:%w", err)
	}
	return nil
}

func (obj StaticParameters) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding StaticParameters: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *StaticParameters) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `BaseFactor`:
	if err = decoder.Decode(&obj.BaseFactor); err != nil {
		return fmt.Errorf("error while unmarshaling BaseFactor:%w", err)
	}
	// Deserialize `FilterPeriod`:
	if err = decoder.Decode(&obj.FilterPeriod); err != nil {
		return fmt.Errorf("error while unmarshaling FilterPeriod:%w", err)
	}
	// Deserialize `DecayPeriod`:
	if err = decoder.Decode(&obj.DecayPeriod); err != nil {
		return fmt.Errorf("error while unmarshaling DecayPeriod:%w", err)
	}
	// Deserialize `ReductionFactor`:
	if err = decoder.Decode(&obj.ReductionFactor); err != nil {
		return fmt.Errorf("error while unmarshaling ReductionFactor:%w", err)
	}
	// Deserialize `VariableFeeControl`:
	if err = decoder.Decode(&obj.VariableFeeControl); err != nil {
		return fmt.Errorf("error while unmarshaling VariableFeeControl:%w", err)
	}
	// Deserialize `MaxVolatilityAccumulator`:
	if err = decoder.Decode(&obj.MaxVolatilityAccumulator); err != nil {
		return fmt.Errorf("error while unmarshaling MaxVolatilityAccumulator:%w", err)
	}
	// Deserialize `MinBinId`:
	if err = decoder.Decode(&obj.MinBinId); err != nil {
		return fmt.Errorf("error while unmarshaling MinBinId:%w", err)
	}
	// Deserialize `MaxBinId`:
	if err = decoder.Decode(&obj.MaxBinId); err != nil {
		return fmt.Errorf("error while unmarshaling MaxBinId:%w", err)
	}
	// Deserialize `ProtocolShare`:
	if err = decoder.Decode(&obj.ProtocolShare); err != nil {
		return fmt.Errorf("error while unmarshaling ProtocolShare:%w", err)
	}
	// Deserialize `BaseFeePowerFactor`:
	if err = decoder.Decode(&obj.BaseFeePowerFactor); err != nil {
		return fmt.Errorf("error while unmarshaling BaseFeePowerFactor:%w", err)
	}
	// Deserialize `Padding`:
	if err = decoder.Decode(&obj.Padding); err != nil {
		return fmt.Errorf("error while unmarshaling Padding:%w", err)
	}
	return nil
}

func (obj *StaticParameters) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling StaticParameters: %w", err)
	}
	return nil
}

func UnmarshalStaticParameters(buf []byte) (*StaticParameters, error) {
	obj := new(StaticParameters)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type StrategyParameters struct {
	// min bin id
	MinBinId int32

	// max bin id
	MaxBinId int32

	// strategy type
	StrategyType StrategyType

	// parameters
	Parameteres [64]uint8
}

func (obj StrategyParameters) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `MinBinId`:
	if err = encoder.Encode(obj.MinBinId); err != nil {
		return fmt.Errorf("error while marshaling MinBinId:%w", err)
	}
	// Serialize `MaxBinId`:
	if err = encoder.Encode(obj.MaxBinId); err != nil {
		return fmt.Errorf("error while marshaling MaxBinId:%w", err)
	}
	// Serialize `StrategyType`:
	if err = encoder.Encode(obj.StrategyType); err != nil {
		return fmt.Errorf("error while marshaling StrategyType:%w", err)
	}
	// Serialize `Parameteres`:
	if err = encoder.Encode(obj.Parameteres); err != nil {
		return fmt.Errorf("error while marshaling Parameteres:%w", err)
	}
	return nil
}

func (obj StrategyParameters) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding StrategyParameters: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *StrategyParameters) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `MinBinId`:
	if err = decoder.Decode(&obj.MinBinId); err != nil {
		return fmt.Errorf("error while unmarshaling MinBinId:%w", err)
	}
	// Deserialize `MaxBinId`:
	if err = decoder.Decode(&obj.MaxBinId); err != nil {
		return fmt.Errorf("error while unmarshaling MaxBinId:%w", err)
	}
	// Deserialize `StrategyType`:
	if err = decoder.Decode(&obj.StrategyType); err != nil {
		return fmt.Errorf("error while unmarshaling StrategyType:%w", err)
	}
	// Deserialize `Parameteres`:
	if err = decoder.Decode(&obj.Parameteres); err != nil {
		return fmt.Errorf("error while unmarshaling Parameteres:%w", err)
	}
	return nil
}

func (obj *StrategyParameters) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling StrategyParameters: %w", err)
	}
	return nil
}

func UnmarshalStrategyParameters(buf []byte) (*StrategyParameters, error) {
	obj := new(StrategyParameters)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

type StrategyType binary.BorshEnum

const (
	StrategyType_SpotOneSide StrategyType = iota
	StrategyType_CurveOneSide
	StrategyType_BidAskOneSide
	StrategyType_SpotBalanced
	StrategyType_CurveBalanced
	StrategyType_BidAskBalanced
	StrategyType_SpotImBalanced
	StrategyType_CurveImBalanced
	StrategyType_BidAskImBalanced
)

func (value StrategyType) String() string {
	switch value {
	case StrategyType_SpotOneSide:
		return "SpotOneSide"
	case StrategyType_CurveOneSide:
		return "CurveOneSide"
	case StrategyType_BidAskOneSide:
		return "BidAskOneSide"
	case StrategyType_SpotBalanced:
		return "SpotBalanced"
	case StrategyType_CurveBalanced:
		return "CurveBalanced"
	case StrategyType_BidAskBalanced:
		return "BidAskBalanced"
	case StrategyType_SpotImBalanced:
		return "SpotImBalanced"
	case StrategyType_CurveImBalanced:
		return "CurveImBalanced"
	case StrategyType_BidAskImBalanced:
		return "BidAskImBalanced"
	default:
		return ""
	}
}

type TokenProgramFlags binary.BorshEnum

const (
	TokenProgramFlags_TokenProgram TokenProgramFlags = iota
	TokenProgramFlags_TokenProgram2022
)

func (value TokenProgramFlags) String() string {
	switch value {
	case TokenProgramFlags_TokenProgram:
		return "TokenProgram"
	case TokenProgramFlags_TokenProgram2022:
		return "TokenProgram2022"
	default:
		return ""
	}
}

type UserRewardInfo struct {
	RewardPerTokenCompletes [2]binary.Uint128
	RewardPendings          [2]uint64
}

func (obj UserRewardInfo) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `RewardPerTokenCompletes`:
	if err = encoder.Encode(obj.RewardPerTokenCompletes); err != nil {
		return fmt.Errorf("error while marshaling RewardPerTokenCompletes:%w", err)
	}
	// Serialize `RewardPendings`:
	if err = encoder.Encode(obj.RewardPendings); err != nil {
		return fmt.Errorf("error while marshaling RewardPendings:%w", err)
	}
	return nil
}

func (obj UserRewardInfo) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding UserRewardInfo: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *UserRewardInfo) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `RewardPerTokenCompletes`:
	if err = decoder.Decode(&obj.RewardPerTokenCompletes); err != nil {
		return fmt.Errorf("error while unmarshaling RewardPerTokenCompletes:%w", err)
	}
	// Deserialize `RewardPendings`:
	if err = decoder.Decode(&obj.RewardPendings); err != nil {
		return fmt.Errorf("error while unmarshaling RewardPendings:%w", err)
	}
	return nil
}

func (obj *UserRewardInfo) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling UserRewardInfo: %w", err)
	}
	return nil
}

func UnmarshalUserRewardInfo(buf []byte) (*UserRewardInfo, error) {
	obj := new(UserRewardInfo)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Parameters that changes based on dynamic of the market
type VariableParameters struct {
	// Volatility accumulator measure the number of bin crossed since reference bin ID. Normally (without filter period taken into consideration), reference bin ID is the active bin of last swap.
	// It affects the variable fee rate
	VolatilityAccumulator uint32

	// Volatility reference is decayed volatility accumulator. It is always <= volatility_accumulator
	VolatilityReference uint32

	// Active bin id of last swap.
	IndexReference int32

	// Padding for bytemuck safe alignment
	Padding [4]uint8

	// Last timestamp the variable parameters was updated
	LastUpdateTimestamp int64

	// Padding for bytemuck safe alignment
	Padding1 [8]uint8
}

func (obj VariableParameters) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `VolatilityAccumulator`:
	if err = encoder.Encode(obj.VolatilityAccumulator); err != nil {
		return fmt.Errorf("error while marshaling VolatilityAccumulator:%w", err)
	}
	// Serialize `VolatilityReference`:
	if err = encoder.Encode(obj.VolatilityReference); err != nil {
		return fmt.Errorf("error while marshaling VolatilityReference:%w", err)
	}
	// Serialize `IndexReference`:
	if err = encoder.Encode(obj.IndexReference); err != nil {
		return fmt.Errorf("error while marshaling IndexReference:%w", err)
	}
	// Serialize `Padding`:
	if err = encoder.Encode(obj.Padding); err != nil {
		return fmt.Errorf("error while marshaling Padding:%w", err)
	}
	// Serialize `LastUpdateTimestamp`:
	if err = encoder.Encode(obj.LastUpdateTimestamp); err != nil {
		return fmt.Errorf("error while marshaling LastUpdateTimestamp:%w", err)
	}
	// Serialize `Padding1`:
	if err = encoder.Encode(obj.Padding1); err != nil {
		return fmt.Errorf("error while marshaling Padding1:%w", err)
	}
	return nil
}

func (obj VariableParameters) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding VariableParameters: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *VariableParameters) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `VolatilityAccumulator`:
	if err = decoder.Decode(&obj.VolatilityAccumulator); err != nil {
		return fmt.Errorf("error while unmarshaling VolatilityAccumulator:%w", err)
	}
	// Deserialize `VolatilityReference`:
	if err = decoder.Decode(&obj.VolatilityReference); err != nil {
		return fmt.Errorf("error while unmarshaling VolatilityReference:%w", err)
	}
	// Deserialize `IndexReference`:
	if err = decoder.Decode(&obj.IndexReference); err != nil {
		return fmt.Errorf("error while unmarshaling IndexReference:%w", err)
	}
	// Deserialize `Padding`:
	if err = decoder.Decode(&obj.Padding); err != nil {
		return fmt.Errorf("error while unmarshaling Padding:%w", err)
	}
	// Deserialize `LastUpdateTimestamp`:
	if err = decoder.Decode(&obj.LastUpdateTimestamp); err != nil {
		return fmt.Errorf("error while unmarshaling LastUpdateTimestamp:%w", err)
	}
	// Deserialize `Padding1`:
	if err = decoder.Decode(&obj.Padding1); err != nil {
		return fmt.Errorf("error while unmarshaling Padding1:%w", err)
	}
	return nil
}

func (obj *VariableParameters) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling VariableParameters: %w", err)
	}
	return nil
}

func UnmarshalVariableParameters(buf []byte) (*VariableParameters, error) {
	obj := new(VariableParameters)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}
