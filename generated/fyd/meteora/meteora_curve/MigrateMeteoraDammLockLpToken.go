// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.

package meteora_curve

import (
	"bytes"
	"fmt"

	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
	programparser "github.com/yydsqu/solana-sdk/program_parser"
)

// Builds a "migrate_meteora_damm_lock_lp_token" instruction.
type MigrateMeteoraDammLockLpToken struct {
	// Params:
	// Accounts:
	// [0] = [] virtual_pool
	VirtualPool solanago.PublicKey `bin:"-"`
	// [1] = [writable] migration_metadata
	MigrationMetadata solanago.PublicKey `bin:"-"`
	// [2] = [writable] pool_authority[FhVo3mqL8PW5pH5U2CN4XE33DokiyZnUwuGpH2hmHLuM]
	PoolAuthority solanago.PublicKey `bin:"-"`
	// [3] = [writable] pool
	Pool solanago.PublicKey `bin:"-"`
	// [4] = [] lp_mint
	LpMint solanago.PublicKey `bin:"-"`
	// [5] = [writable] lock_escrow
	LockEscrow solanago.PublicKey `bin:"-"`
	// [6] = [] owner
	Owner solanago.PublicKey `bin:"-"`
	// [7] = [writable] source_tokens
	SourceTokens solanago.PublicKey `bin:"-"`
	// [8] = [writable] escrow_vault
	EscrowVault solanago.PublicKey `bin:"-"`
	// [9] = [] amm_program[Eo7WjKq67rjJQSZxS6z3YkapzY3eMj6Xy8X5EQVn5UaB]
	AmmProgram solanago.PublicKey `bin:"-"`
	// [10] = [] a_vault
	AVault solanago.PublicKey `bin:"-"`
	// [11] = [] b_vault
	BVault solanago.PublicKey `bin:"-"`
	// [12] = [] a_vault_lp
	AVaultLp solanago.PublicKey `bin:"-"`
	// [13] = [] b_vault_lp
	BVaultLp solanago.PublicKey `bin:"-"`
	// [14] = [] a_vault_lp_mint
	AVaultLpMint solanago.PublicKey `bin:"-"`
	// [15] = [] b_vault_lp_mint
	BVaultLpMint solanago.PublicKey `bin:"-"`
	// [16] = [] token_program[TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA]
	TokenProgram solanago.PublicKey `bin:"-"`
	// PublicKeySlice
	solanago.PublicKeySlice `bin:"-"`
}

func (obj MigrateMeteoraDammLockLpToken) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	return nil
}

func (obj *MigrateMeteoraDammLockLpToken) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	return nil
}

func (obj *MigrateMeteoraDammLockLpToken) SetAccounts(accounts solanago.PublicKeySlice) (err error) {
	if len(accounts) < 17 {
		return fmt.Errorf("too few accounts, expect %d actual %d", 17, len(accounts))
	}
	obj.VirtualPool = accounts[0]
	obj.MigrationMetadata = accounts[1]
	obj.PoolAuthority = accounts[2]
	obj.Pool = accounts[3]
	obj.LpMint = accounts[4]
	obj.LockEscrow = accounts[5]
	obj.Owner = accounts[6]
	obj.SourceTokens = accounts[7]
	obj.EscrowVault = accounts[8]
	obj.AmmProgram = accounts[9]
	obj.AVault = accounts[10]
	obj.BVault = accounts[11]
	obj.AVaultLp = accounts[12]
	obj.BVaultLp = accounts[13]
	obj.AVaultLpMint = accounts[14]
	obj.BVaultLpMint = accounts[15]
	obj.TokenProgram = accounts[16]
	obj.PublicKeySlice = accounts
	return nil
}
func (obj *MigrateMeteoraDammLockLpToken) PublicKeys() solanago.PublicKeySlice {
	return obj.PublicKeySlice
}

func (*MigrateMeteoraDammLockLpToken) TypeID() binary.TypeID {
	return binary.TypeIDFromBytes(Instruction_MigrateMeteoraDammLockLpToken)
}

func (*MigrateMeteoraDammLockLpToken) NewInstance() programparser.Instruction {
	return new(MigrateMeteoraDammLockLpToken)
}

func (obj *MigrateMeteoraDammLockLpToken) GetRemainingAccounts() solanago.PublicKeySlice {
	if len(obj.PublicKeySlice) <= 17 {
		return nil
	}
	return obj.PublicKeySlice[17:]
}

// Builds a "migrate_meteora_damm_lock_lp_token" instruction.
func NewMigrateMeteoraDammLockLpTokenInstruction(
	virtualPool solanago.PublicKey,
	migrationMetadata solanago.PublicKey,
	pool solanago.PublicKey,
	lpMint solanago.PublicKey,
	lockEscrow solanago.PublicKey,
	owner solanago.PublicKey,
	sourceTokens solanago.PublicKey,
	escrowVault solanago.PublicKey,
	aVault solanago.PublicKey,
	bVault solanago.PublicKey,
	aVaultLp solanago.PublicKey,
	bVaultLp solanago.PublicKey,
	aVaultLpMint solanago.PublicKey,
	bVaultLpMint solanago.PublicKey,
	remaining__ ...*solanago.AccountMeta,
) (*solanago.GenericInstruction, error) {
	var (
		err    error
		buf__  = new(bytes.Buffer)
		enc__  = binary.NewBorshEncoder(buf__)
		metas_ = make(solanago.AccountMetaSlice, 17, 17+len(remaining__))
	)

	// Encode the instruction discriminator.
	if err = enc__.WriteBytes(Instruction_MigrateMeteoraDammLockLpToken[:], false); err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}

	// Add the accounts to the instruction.
	{
		// [0] = [] virtual_pool
		metas_[0] = solanago.NewAccountMeta(virtualPool, false, false)
		// [1] = [writable] migration_metadata
		// migration_metadata
		metas_[1] = solanago.NewAccountMeta(migrationMetadata, true, false)
		// [2] = [writable] pool_authority[FhVo3mqL8PW5pH5U2CN4XE33DokiyZnUwuGpH2hmHLuM]
		metas_[2] = solanago.NewAccountMeta(PoolAuthority, true, false)
		// [3] = [writable] pool
		metas_[3] = solanago.NewAccountMeta(pool, true, false)
		// [4] = [] lp_mint
		metas_[4] = solanago.NewAccountMeta(lpMint, false, false)
		// [5] = [writable] lock_escrow
		metas_[5] = solanago.NewAccountMeta(lockEscrow, true, false)
		// [6] = [] owner
		metas_[6] = solanago.NewAccountMeta(owner, false, false)
		// [7] = [writable] source_tokens
		metas_[7] = solanago.NewAccountMeta(sourceTokens, true, false)
		// [8] = [writable] escrow_vault
		metas_[8] = solanago.NewAccountMeta(escrowVault, true, false)
		// [9] = [] amm_program[Eo7WjKq67rjJQSZxS6z3YkapzY3eMj6Xy8X5EQVn5UaB]
		metas_[9] = solanago.NewAccountMeta(AmmProgram, false, false)
		// [10] = [] a_vault
		metas_[10] = solanago.NewAccountMeta(aVault, false, false)
		// [11] = [] b_vault
		metas_[11] = solanago.NewAccountMeta(bVault, false, false)
		// [12] = [] a_vault_lp
		metas_[12] = solanago.NewAccountMeta(aVaultLp, false, false)
		// [13] = [] b_vault_lp
		metas_[13] = solanago.NewAccountMeta(bVaultLp, false, false)
		// [14] = [] a_vault_lp_mint
		metas_[14] = solanago.NewAccountMeta(aVaultLpMint, false, false)
		// [15] = [] b_vault_lp_mint
		metas_[15] = solanago.NewAccountMeta(bVaultLpMint, false, false)
		// [16] = [] token_program[TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA]
		// token_program
		metas_[16] = solanago.NewAccountMeta(TokenProgram, false, false)
		// append remaining metas
		metas_ = append(metas_, remaining__...)
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		metas_,
		buf__.Bytes(),
	), nil
}

// Builds a "BuildMigrateMeteoraDammLockLpToken" instruction.
func BuildMigrateMeteoraDammLockLpToken(
	virtualPool solanago.PublicKey,
	migrationMetadata solanago.PublicKey,
	pool solanago.PublicKey,
	lpMint solanago.PublicKey,
	lockEscrow solanago.PublicKey,
	owner solanago.PublicKey,
	sourceTokens solanago.PublicKey,
	escrowVault solanago.PublicKey,
	aVault solanago.PublicKey,
	bVault solanago.PublicKey,
	aVaultLp solanago.PublicKey,
	bVaultLp solanago.PublicKey,
	aVaultLpMint solanago.PublicKey,
	bVaultLpMint solanago.PublicKey,
	remaining__ ...*solanago.AccountMeta,
) *solanago.GenericInstruction {
	instruction_, _ := NewMigrateMeteoraDammLockLpTokenInstruction(
		virtualPool,
		migrationMetadata,
		pool,
		lpMint,
		lockEscrow,
		owner,
		sourceTokens,
		escrowVault,
		aVault,
		bVault,
		aVaultLp,
		bVaultLp,
		aVaultLpMint,
		bVaultLpMint,
		remaining__...,
	)
	return instruction_
}
