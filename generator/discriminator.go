package generator

import (
	. "github.com/dave/jennifer/jen"
	bin "github.com/gagliardetto/binary"
)

func (g *Generator) genDiscriminators() (*OutputFile, error) {
	file := NewFile(g.options.Package)
	file.HeaderComment("Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.")
	file.HeaderComment("This file contains the discriminators for accounts and events defined in the IDL.")

	{
		accountLen := 0
		accountDiscriminatorsCodes := Empty()
		accountDiscriminatorsCodes.Comment("Account discriminators")
		accountDiscriminatorsCodes.Line()
		accountDiscriminatorsCodes.Var().Parens(
			DoGroup(func(code *Group) {
				for _, account := range g.idl.Accounts {
					accountLen++
					discriminatorName := FormatAccountDiscriminatorName(account.Name)
					{
						code.Id(discriminatorName).Op("=").Index().Byte().Op("{").ListFunc(func(byteGroup *Group) {
							for _, byteVal := range account.Discriminator[:] {
								byteGroup.Lit(int(byteVal))
							}
						}).Op("}")
					}
					code.Line()
				}
			}),
		)

		if accountLen > 0 {
			file.Add(accountDiscriminatorsCodes)
			file.Line()
		}

	}

	{
		eventLen := 0
		// Generate the discriminators for events.
		eventDiscriminatorsCodes := Empty()
		eventDiscriminatorsCodes.Comment("Event discriminators")
		eventDiscriminatorsCodes.Line()
		eventDiscriminatorsCodes.Var().Parens(
			DoGroup(func(code *Group) {
				for _, event := range g.idl.Events {
					eventLen++
					discriminatorName := FormatEventDiscriminatorName(event.Name)
					{
						code.Id(discriminatorName).Op("=").Index().Byte().Op("{").ListFunc(func(byteGroup *Group) {
							for _, byteVal := range event.Discriminator[:] {
								byteGroup.Lit(int(byteVal))
							}
						}).Op("}")
					}
					code.Line()
				}
			}),
		)

		if eventLen > 0 {
			file.Add(eventDiscriminatorsCodes)
			file.Line()
		}
	}

	// 添加指令编码类型
	{
		typeIDEncodingCodes := Empty()
		switch g.options.InstructionTypeIDEncoding {
		case bin.Uvarint32TypeIDEncoding:
			typeIDEncodingCodes.Const().Id("InstructionTypeIDEncoding").Op("=").Qual(PkgBinary, "Uvarint32TypeIDEncoding")
		case bin.Uint32TypeIDEncoding:
			typeIDEncodingCodes.Const().Id("InstructionTypeIDEncoding").Op("=").Qual(PkgBinary, "Uint32TypeIDEncoding")
		case bin.Uint8TypeIDEncoding:
			typeIDEncodingCodes.Const().Id("InstructionTypeIDEncoding").Op("=").Qual(PkgBinary, "Uint8TypeIDEncoding")
		case bin.NoTypeIDEncoding:
			typeIDEncodingCodes.Const().Id("InstructionTypeIDEncoding").Op("=").Qual(PkgBinary, "NoTypeIDEncoding")
		default:
			typeIDEncodingCodes.Const().Id("InstructionTypeIDEncoding").Op("=").Qual(PkgBinary, "AnchorTypeIDEncoding")
		}
		file.Add(typeIDEncodingCodes)
		file.Line()
	}

	{
		instructionLen := 0
		// Generate the discriminators for instructions.
		instructionDiscriminatorsCodes := Empty()
		instructionDiscriminatorsCodes.Comment("Instruction discriminators")
		instructionDiscriminatorsCodes.Line()
		instructionDiscriminatorsCodes.Var().Parens(
			DoGroup(
				func(code *Group) {
					for _, instruction := range g.idl.Instructions {
						if len(instruction.Discriminator) == 0 {
							continue
						}
						instructionLen++
						discriminatorName := FormatInstructionDiscriminatorName(instruction.Name)
						{
							code.Id(discriminatorName).Op("=").Index().Byte().Op("{").ListFunc(func(byteGroup *Group) {
								for _, byteVal := range instruction.Discriminator[:] {
									byteGroup.Lit(int(byteVal))
								}
							}).Op("}")
						}
						code.Line()
					}
				},
			),
		)
		if instructionLen > 0 {
			file.Add(instructionDiscriminatorsCodes)
			file.Line()
		}
	}

	return &OutputFile{
		Name: "discriminators.go",
		File: file,
	}, nil
}
