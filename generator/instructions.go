package generator

import (
	"fmt"
	"strings"

	. "github.com/dave/jennifer/jen"
	"github.com/gagliardetto/anchor-go/idl"
	"github.com/gagliardetto/anchor-go/tools"
)

func (g *Generator) genInstructionFile() ([]*OutputFile, error) {
	var files []*OutputFile
	for _, instruction := range g.idl.Instructions {
		instructionName := tools.ToCamel(instruction.Name)

		file := NewFile(g.options.Package)
		file.HeaderComment("Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.")
		file.Commentf("Builds a %q instruction.", instruction.Name)
		{
			if len(instruction.Docs) > 0 {
				file.Line()
				// Add documentation comments for the instruction.
				for _, doc := range instruction.Docs {
					file.Comment(doc)
				}
			}
		}
		accounts, err := g.GetInstructionAccount(instruction.Accounts)
		if err != nil {
			return nil, err
		}
		// 构建结构体信息
		file.Type().Id(instructionName).StructFunc(func(fieldsGroup *Group) {
			fieldsGroup.Comment("Params:")

			for _, param := range instruction.Args {
				fieldsGroup.Add(newStatement().Id(tools.ToCamelUpper(param.Name)).
					Add(func() Code {
						if isComplexEnum(param.Ty) {
							return nil
						}
						if IsOption(param.Ty) || IsCOption(param.Ty) {
							return Op("*")
						}
						return nil
					}()).
					Add(genTypeName(param.Ty))).
					Add(Add(func() Code {
						tagMap := map[string]string{}
						if IsOption(param.Ty) {
							tagMap["bin"] = "optional"
						}
						if IsCOption(param.Ty) {
							tagMap["bin"] = "coption"
						}
						return Tag(tagMap)
					}()))

			}

			fieldsGroup.Comment("Accounts:")

			for i, account := range accounts {
				var tags []string
				if account.Signer {
					tags = append(tags, "signer")
				}
				if account.Writable {
					tags = append(tags, "writable")
				}
				fieldsGroup.Comment(formatAccountCommentDocs(i, account))
				fieldsGroup.Add(Id(tools.ToCamelUpper(account.Name))).Qual(PkgSolanaGo, "PublicKey").Tag(map[string]string{
					"bin": "-",
				})
			}
			fieldsGroup.Comment("PublicKeySlice")
			fieldsGroup.Add(Qual(PkgSolanaGo, "PublicKeySlice").Tag(map[string]string{
				"bin": "-",
			}))
		})
		file.Line().Line().Add(g.GenMarshalWithEncoderInstruction(instructionName, instruction))
		file.Line().Line().Add(g.GenUnMarshalWithEncoderInstruction(instructionName, instruction))
		file.Line().Line().Add(g.GenSetAccounts(instructionName, instruction, accounts))

		file.Line().Line().Add(Empty().Func().
			Params(Op("*").Id(instructionName)).Id("TypeID").
			Params(
				ListFunc(func(params *Group) {}),
			).
			Params(
				ListFunc(func(results *Group) {
					// Results:
					results.Add(Empty().Qual(PkgBinary, "TypeID"))
				}),
			).
			BlockFunc(func(body *Group) {
				body.Return(Qual(PkgBinary, "TypeIDFromBytes").Call(Id(FormatInstructionDiscriminatorName(instruction.Name))))
			}))

		file.Line().Line().Add(Empty().Func().
			Params(Op("*").Id(instructionName)).Id("NewInstance").
			Params(ListFunc(func(params *Group) {})).
			Params(ListFunc(func(results *Group) {
				results.Add(Empty().Qual(PkgProgramParser, "Instruction"))
			})).
			BlockFunc(func(body *Group) {
				body.Return(Id("new").Call(Id(instructionName)))
			}))
		// 生成获取剩余账户的方法
		file.Line().Line().Add(Empty().Func().
			Params(Id("obj").Op("*").Id(instructionName)).Id("GetRemainingAccounts").
			Params(
				ListFunc(func(params *Group) {
					// 无参数
				}),
			).
			Params(
				ListFunc(func(results *Group) {
					// 返回结果 solanago.PublicKeySlice
					results.Qual(PkgSolanaGo, "PublicKeySlice")
				}),
			).
			BlockFunc(func(body *Group) {
				// Body:
				// 生成：if len(obj.PublicKeySlice) <= 6 {
				// 	return nil
				// }
				body.If(Len(Id("obj").Dot("PublicKeySlice")).Op("<=").Lit(len(instruction.Accounts))).
					Block(
						Return(Nil()),
					)
				body.Return(Id("obj").Dot("PublicKeySlice").Index(Lit(len(instruction.Accounts)).Op(":")))
			}),
		)
		// 生成构建交易信息
		file.Add(g.GetNewInstructionCode(instruction))

		file.Add(g.GetBuildInstructionCode(instruction))

		files = append(files, &OutputFile{
			Name: instructionName + ".go",
			File: file,
		})
	}
	return files, nil
}

func (g *Generator) GenMarshalWithEncoderInstruction(instructionName string, instruction idl.IdlInstruction) Code {
	code := Empty()
	code.Func().Params(Id("obj").Id(instructionName)).Id("MarshalWithEncoder").
		Params(
			ListFunc(func(params *Group) {
				// Parameters:
				params.Id("encoder").Op("*").Qual(PkgBinary, "Encoder")
			}),
		).
		Params(
			ListFunc(func(results *Group) {
				// Results:
				results.Err().Error()
			}),
		).
		BlockFunc(func(body *Group) {
			if len(instruction.Args) == 0 {
				body.Return(Nil())
				return
			}
			// 序列化参数信息
			genMarshalDefinedfieldsnamed(
				body,
				instruction.Args,
				true,
				func(param idl.IdlField) *Statement {
					return Id("obj." + tools.ToCamelUpper(param.Name))
				},
				"encoder",
				false, // returnNilErr
				func(param idl.IdlField) string {
					return formatParamName(param.Name)
				},
			)
			body.Return(Nil())
		})

	return code
}

func (g *Generator) GenUnMarshalWithEncoderInstruction(instructionName string, instruction idl.IdlInstruction) Code {
	code := Empty()
	code.Func().Params(Id("obj").Op("*").Id(instructionName)).Id("UnmarshalWithDecoder").
		Params(
			ListFunc(func(params *Group) {
				// Parameters: encoder *ag_binary.Encoder
				params.Id("decoder").Op("*").Qual(PkgBinary, "Decoder")
			}),
		).
		Params(
			ListFunc(func(results *Group) {
				// Results:
				results.Err().Error()
			}),
		).
		BlockFunc(func(body *Group) {
			if len(instruction.Args) == 0 {
				body.Return(Nil())
				return
			}

			gen_unmarshal_DefinedFieldsNamed(body, instruction.Args)

			body.Return(Nil())
		})

	return code
}

func (g *Generator) GenSetAccounts(instructionName string, instruction idl.IdlInstruction, accounts []*idl.IdlInstructionAccount) Code {
	code := Empty()
	code.Func().Params(Id("obj").Op("*").Id(instructionName)).Id("SetAccounts").
		Params(
			ListFunc(func(params *Group) {
				params.Id("accounts").Qual(PkgSolanaGo, "PublicKeySlice")
			}),
		).
		Params(
			ListFunc(func(results *Group) {
				// Results:
				results.Err().Error()
			}),
		).
		BlockFunc(func(body *Group) {
			body.If(Len(Id("accounts")).Op("<").Lit(len(accounts))).Block(
				Return(Qual("fmt", "Errorf").Call(Lit("too few accounts, expect %d actual %d"), Lit(len(accounts)), Len(Id("accounts")))),
			)
			for i, account := range accounts {
				body.Add(Id("obj").Dot(tools.ToCamelUpper(account.Name)).Op("=").Id("accounts").Index(Lit(i)))
			}
			body.Add(Id("obj").Dot("PublicKeySlice").Op("=").Id("accounts"))
			body.Return(Nil())
		})

	code.Line().Add(Empty().Func().
		Params(Id("obj").Op("*").Id(instructionName)).Id("PublicKeys").
		Params(ListFunc(func(params *Group) {})).
		Params(ListFunc(func(results *Group) {
			results.Add(Qual(PkgSolanaGo, "PublicKeySlice"))
		})).
		BlockFunc(func(body *Group) {
			body.Return(Id("obj").Dot("PublicKeySlice"))
		}))

	return code
}

func (g *Generator) GetNewInstructionCode(instruction idl.IdlInstruction) *Statement {
	ixCode := Empty()
	declarerName := newInstructionFuncName(instruction.Name)
	ixCode.Commentf("Builds a %q instruction.", instruction.Name)
	{
		if len(instruction.Docs) > 0 {
			ixCode.Line()
			// Add documentation comments for the instruction.
			for _, doc := range instruction.Docs {
				ixCode.Comment(doc)
			}
		}
	}
	ixCode.Line()
	accounts, err := g.GetInstructionAccount(instruction.Accounts)
	if err != nil {
		panic(fmt.Errorf("get instruction account failure,%s", instruction.Name))
	}

	ixCode.Func().Id(declarerName).
		Params(
			DoGroup(
				func(g *Group) {
					addCommentSections := len(instruction.Args) > 0 && len(instruction.Accounts) > 0
					if addCommentSections {
						g.Line().Comment("Params:")
					}
					g.Add(
						ListMultiline(
							func(paramsCode *Group) {
								for _, param := range instruction.Args {
									paramType := genTypeName(param.Ty)
									if IsOption(param.Ty) || IsCOption(param.Ty) {
										paramType = Op("*").Add(paramType)
									}
									paramsCode.Id(formatParamName(param.Name)).Add(paramType)
								}
							},
						),
					)
					if addCommentSections {
						g.Line().Comment("Accounts:")
					}
					g.Add(
						ListMultiline(
							func(accountsCode *Group) {
								for _, account := range accounts {
									if account.Address.IsSome() {
										continue
									}
									accountsCode.Id(formatAccountNameParam(account.Name)).Qual(PkgSolanaGo, "PublicKey")
								}
							},
						),
					)
					g.Add(Id("remaining__").Op("...*").Qual(PkgSolanaGo, "AccountMeta").Op(","))
					g.Line()
				},
			),
		).
		ParamsFunc(func(returnsCode *Group) {
			returnsCode.Op("*").Qual(PkgSolanaGo, "GenericInstruction")
			returnsCode.Error()
		}).BlockFunc(func(body *Group) {
		body.Var().Defs(
			Id("err").Error(),
			Id("buf__").Op("=").New(Qual("bytes", "Buffer")),
			Id("enc__").Op("=").Qual(PkgBinary, "NewBorshEncoder").Call(Id("buf__")),
			Id("metas_").Op("=").Make(Qual(PkgSolanaGo, "AccountMetaSlice"), Lit(len(accounts)), Lit(len(accounts)).Op("+").Len(Id("remaining__"))),
		)

		// if len(instruction.Discriminator) > 0 {
		body.Line().Comment("Encode the instruction discriminator.")
		body.If(
			Err().Op("=").Id("enc__").Dot("WriteBytes").Call(Id(FormatInstructionDiscriminatorName(instruction.Name)).Index(Op(":")), False()),
			Err().Op("!=").Nil()).Block(
			Return(
				Nil(),
				Qual("fmt", "Errorf").Call(Lit("failed to write instruction discriminator: %w"), Err()),
			),
		)
		body.Line()
		// }

		if len(instruction.Args) > 0 {
			body.BlockFunc(func(g *Group) {
				genMarshalDefinedfieldsnamed(
					g,
					instruction.Args,
					true,
					func(param idl.IdlField) *Statement {
						return Id(formatParamName(param.Name))
					},
					"enc__",
					true,
					func(param idl.IdlField) string {
						return formatParamName(param.Name)
					},
				)
			})
		}

		body.Line().Comment("Add the accounts to the instruction.")

		body.Block(
			DoGroup(func(body *Group) {
				for ai, account := range accounts {
					{
						if ai > 0 {
							body.Line()
						}
						body.Comment(formatAccountCommentDocs(ai, account))
						body.Line()
						{
							// add comment for the account
							if len(account.Docs) > 0 {
								for _, doc := range account.Docs {
									body.Comment(doc).Line()
								}
							}
						}
						accountName := formatAccountNameParam(account.Name)
						if account.Address.IsSome() {
							accountName = tools.ToCamelUpper(account.Name)
						}
						body.Id("metas_").Index(Lit(ai)).Op("=").Qual(PkgSolanaGo, "NewAccountMeta").Call(
							Id(accountName),
							Lit(account.Writable),
							Lit(account.Signer),
						)
					}
				}
			}),
			Comment("append remaining metas"),
			Id("metas_").Op("=").Append(Id("metas_"), Id("remaining__...")),
		)

		// create the return instruction
		body.Line().Comment("Create the instruction.")
		body.Return(
			Qual(PkgSolanaGo, "NewInstruction").CallFunc(
				func(g *Group) {
					g.Add(
						ListMultiline(func(gg *Group) {
							gg.Id("ProgramID")
							gg.Id("metas_")
							gg.Id("buf__").Dot("Bytes").Call()
						}),
					)
				},
			),
			Nil(),
		)
	})

	return ixCode
}

func (g *Generator) GetBuildInstructionCode(instruction idl.IdlInstruction) *Statement {
	ixCode := Empty()
	declarerName := buildInstructionFuncName(instruction.Name)
	NewDeclarerName := newInstructionFuncName(instruction.Name)
	ixCode.Commentf("Builds a %q instruction.", declarerName)
	{
		if len(instruction.Docs) > 0 {
			ixCode.Line()
			// Add documentation comments for the instruction.
			for _, doc := range instruction.Docs {
				ixCode.Comment(doc)
			}
		}
	}
	ixCode.Line()
	accounts, err := g.GetInstructionAccount(instruction.Accounts)
	if err != nil {
		panic(fmt.Errorf("get instruction account failure,%s", instruction.Name))
	}

	ixCode.Func().Id(declarerName).
		Params(
			DoGroup(
				func(g *Group) {
					addCommentSections := len(instruction.Args) > 0 && len(instruction.Accounts) > 0
					if addCommentSections {
						g.Line().Comment("Params:")
					}
					g.Add(
						ListMultiline(
							func(paramsCode *Group) {
								for _, param := range instruction.Args {
									paramType := genTypeName(param.Ty)
									if IsOption(param.Ty) || IsCOption(param.Ty) {
										paramType = Op("*").Add(paramType)
									}
									paramsCode.Id(formatParamName(param.Name)).Add(paramType)
								}
							},
						),
					)
					if addCommentSections {
						g.Line().Comment("Accounts:")
					}
					g.Add(
						ListMultiline(
							func(accountsCode *Group) {
								for _, account := range accounts {
									if account.Address.IsSome() {
										continue
									}
									accountsCode.Id(formatAccountNameParam(account.Name)).Qual(PkgSolanaGo, "PublicKey")
								}
							},
						),
					)
					g.Add(Id("remaining__").Op("...*").Qual(PkgSolanaGo, "AccountMeta").Op(","))
					g.Line()
				},
			),
		).
		ParamsFunc(
			func(returnsCode *Group) {
				returnsCode.Op("*").Qual(PkgSolanaGo, "GenericInstruction")
			}).
		BlockFunc(func(body *Group) {
			body.Id("instruction_,_").Op(":=").Id(NewDeclarerName).Call(DoGroup(
				func(g *Group) {
					g.Add(ListMultiline(func(paramsCode *Group) {
						for _, param := range instruction.Args {
							paramsCode.Id(formatParamName(param.Name))
						}
						for _, account := range accounts {
							if account.Address.IsSome() {
								continue
							}
							paramsCode.Id(formatAccountNameParam(account.Name))
						}
						paramsCode.Add(Id("remaining__").Op("..."))
					}))

				},
			))
			// 更新信息
			body.Return(Id("instruction_"))
		})

	return ixCode
}

func (g *Generator) GetInstructionAccount(accounts []idl.IdlInstructionAccountItem) ([]*idl.IdlInstructionAccount, error) {
	var item []*idl.IdlInstructionAccount
	for _, account := range accounts {
		switch v := account.(type) {
		case *idl.IdlInstructionAccount:
			item = append(item, v)
		case *idl.IdlInstructionAccounts:
			instructionAccount, err := g.GetInstructionAccount(v.Accounts)
			if err != nil {
				return nil, err
			}
			item = append(item, instructionAccount...)
		}
	}
	return item, nil
}

func formatAccountNameParam(accountName string) string {
	if tools.IsReservedKeyword(accountName) {
		return accountName + "_"
	}
	if !tools.IsValidIdent(accountName) {
		return "a_" + tools.ToCamelUpper(accountName)
	}
	return tools.ToCamelLower(accountName)
}

func formatParamName(paramName string) string {
	paramName = paramName + "Param"
	if tools.IsReservedKeyword(paramName) {
		return paramName + "_"
	}
	if !tools.IsValidIdent(paramName) {
		return "p_" + tools.ToCamelUpper(paramName)
	}
	return tools.ToCamelLower(paramName)
}

func newInstructionFuncName(instructionName string) string {
	return "New" + tools.ToCamelUpper(instructionName) + "Instruction"
}

func buildInstructionFuncName(instructionName string) string {
	return "Build" + tools.ToCamelUpper(instructionName)
}

func formatAccountCommentDocs(index int, account *idl.IdlInstructionAccount) string {
	buf := new(strings.Builder)
	// [0] = [] target_account
	buf.WriteString(fmt.Sprintf("[%d] = [", index))
	buf.WriteString("")
	if account.Writable {
		buf.WriteString("writable")
	}

	if account.Signer {
		buf.WriteString(",signer")
	}

	if account.Optional {
		buf.WriteString(",optional")
	}
	buf.WriteString(fmt.Sprintf("] %s", account.Name))

	if account.Address.IsSome() && !account.Address.Unwrap().IsZero() {
		buf.WriteString(fmt.Sprintf("[%s]", account.Address.Unwrap().String()))
	}

	return buf.String()
}
